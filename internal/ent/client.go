// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"gigaboo.io/lem/internal/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"gigaboo.io/lem/internal/ent/achievement"
	"gigaboo.io/lem/internal/ent/app"
	"gigaboo.io/lem/internal/ent/assignment"
	"gigaboo.io/lem/internal/ent/assignmentsubmission"
	"gigaboo.io/lem/internal/ent/battleroom"
	"gigaboo.io/lem/internal/ent/battlesession"
	"gigaboo.io/lem/internal/ent/classroom"
	"gigaboo.io/lem/internal/ent/classroommembership"
	"gigaboo.io/lem/internal/ent/classroomsession"
	"gigaboo.io/lem/internal/ent/emailtemplate"
	"gigaboo.io/lem/internal/ent/livesession"
	"gigaboo.io/lem/internal/ent/livesessionstudent"
	"gigaboo.io/lem/internal/ent/organization"
	"gigaboo.io/lem/internal/ent/organizationinvitation"
	"gigaboo.io/lem/internal/ent/organizationmember"
	"gigaboo.io/lem/internal/ent/plan"
	"gigaboo.io/lem/internal/ent/shenbiprofile"
	"gigaboo.io/lem/internal/ent/shenbisettings"
	"gigaboo.io/lem/internal/ent/subscription"
	"gigaboo.io/lem/internal/ent/user"
	"gigaboo.io/lem/internal/ent/userapp"
	"gigaboo.io/lem/internal/ent/userprogress"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Achievement is the client for interacting with the Achievement builders.
	Achievement *AchievementClient
	// App is the client for interacting with the App builders.
	App *AppClient
	// Assignment is the client for interacting with the Assignment builders.
	Assignment *AssignmentClient
	// AssignmentSubmission is the client for interacting with the AssignmentSubmission builders.
	AssignmentSubmission *AssignmentSubmissionClient
	// BattleRoom is the client for interacting with the BattleRoom builders.
	BattleRoom *BattleRoomClient
	// BattleSession is the client for interacting with the BattleSession builders.
	BattleSession *BattleSessionClient
	// Classroom is the client for interacting with the Classroom builders.
	Classroom *ClassroomClient
	// ClassroomMembership is the client for interacting with the ClassroomMembership builders.
	ClassroomMembership *ClassroomMembershipClient
	// ClassroomSession is the client for interacting with the ClassroomSession builders.
	ClassroomSession *ClassroomSessionClient
	// EmailTemplate is the client for interacting with the EmailTemplate builders.
	EmailTemplate *EmailTemplateClient
	// LiveSession is the client for interacting with the LiveSession builders.
	LiveSession *LiveSessionClient
	// LiveSessionStudent is the client for interacting with the LiveSessionStudent builders.
	LiveSessionStudent *LiveSessionStudentClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// OrganizationInvitation is the client for interacting with the OrganizationInvitation builders.
	OrganizationInvitation *OrganizationInvitationClient
	// OrganizationMember is the client for interacting with the OrganizationMember builders.
	OrganizationMember *OrganizationMemberClient
	// Plan is the client for interacting with the Plan builders.
	Plan *PlanClient
	// ShenbiProfile is the client for interacting with the ShenbiProfile builders.
	ShenbiProfile *ShenbiProfileClient
	// ShenbiSettings is the client for interacting with the ShenbiSettings builders.
	ShenbiSettings *ShenbiSettingsClient
	// Subscription is the client for interacting with the Subscription builders.
	Subscription *SubscriptionClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserApp is the client for interacting with the UserApp builders.
	UserApp *UserAppClient
	// UserProgress is the client for interacting with the UserProgress builders.
	UserProgress *UserProgressClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Achievement = NewAchievementClient(c.config)
	c.App = NewAppClient(c.config)
	c.Assignment = NewAssignmentClient(c.config)
	c.AssignmentSubmission = NewAssignmentSubmissionClient(c.config)
	c.BattleRoom = NewBattleRoomClient(c.config)
	c.BattleSession = NewBattleSessionClient(c.config)
	c.Classroom = NewClassroomClient(c.config)
	c.ClassroomMembership = NewClassroomMembershipClient(c.config)
	c.ClassroomSession = NewClassroomSessionClient(c.config)
	c.EmailTemplate = NewEmailTemplateClient(c.config)
	c.LiveSession = NewLiveSessionClient(c.config)
	c.LiveSessionStudent = NewLiveSessionStudentClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.OrganizationInvitation = NewOrganizationInvitationClient(c.config)
	c.OrganizationMember = NewOrganizationMemberClient(c.config)
	c.Plan = NewPlanClient(c.config)
	c.ShenbiProfile = NewShenbiProfileClient(c.config)
	c.ShenbiSettings = NewShenbiSettingsClient(c.config)
	c.Subscription = NewSubscriptionClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserApp = NewUserAppClient(c.config)
	c.UserProgress = NewUserProgressClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Achievement:            NewAchievementClient(cfg),
		App:                    NewAppClient(cfg),
		Assignment:             NewAssignmentClient(cfg),
		AssignmentSubmission:   NewAssignmentSubmissionClient(cfg),
		BattleRoom:             NewBattleRoomClient(cfg),
		BattleSession:          NewBattleSessionClient(cfg),
		Classroom:              NewClassroomClient(cfg),
		ClassroomMembership:    NewClassroomMembershipClient(cfg),
		ClassroomSession:       NewClassroomSessionClient(cfg),
		EmailTemplate:          NewEmailTemplateClient(cfg),
		LiveSession:            NewLiveSessionClient(cfg),
		LiveSessionStudent:     NewLiveSessionStudentClient(cfg),
		Organization:           NewOrganizationClient(cfg),
		OrganizationInvitation: NewOrganizationInvitationClient(cfg),
		OrganizationMember:     NewOrganizationMemberClient(cfg),
		Plan:                   NewPlanClient(cfg),
		ShenbiProfile:          NewShenbiProfileClient(cfg),
		ShenbiSettings:         NewShenbiSettingsClient(cfg),
		Subscription:           NewSubscriptionClient(cfg),
		User:                   NewUserClient(cfg),
		UserApp:                NewUserAppClient(cfg),
		UserProgress:           NewUserProgressClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Achievement:            NewAchievementClient(cfg),
		App:                    NewAppClient(cfg),
		Assignment:             NewAssignmentClient(cfg),
		AssignmentSubmission:   NewAssignmentSubmissionClient(cfg),
		BattleRoom:             NewBattleRoomClient(cfg),
		BattleSession:          NewBattleSessionClient(cfg),
		Classroom:              NewClassroomClient(cfg),
		ClassroomMembership:    NewClassroomMembershipClient(cfg),
		ClassroomSession:       NewClassroomSessionClient(cfg),
		EmailTemplate:          NewEmailTemplateClient(cfg),
		LiveSession:            NewLiveSessionClient(cfg),
		LiveSessionStudent:     NewLiveSessionStudentClient(cfg),
		Organization:           NewOrganizationClient(cfg),
		OrganizationInvitation: NewOrganizationInvitationClient(cfg),
		OrganizationMember:     NewOrganizationMemberClient(cfg),
		Plan:                   NewPlanClient(cfg),
		ShenbiProfile:          NewShenbiProfileClient(cfg),
		ShenbiSettings:         NewShenbiSettingsClient(cfg),
		Subscription:           NewSubscriptionClient(cfg),
		User:                   NewUserClient(cfg),
		UserApp:                NewUserAppClient(cfg),
		UserProgress:           NewUserProgressClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Achievement.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Achievement, c.App, c.Assignment, c.AssignmentSubmission, c.BattleRoom,
		c.BattleSession, c.Classroom, c.ClassroomMembership, c.ClassroomSession,
		c.EmailTemplate, c.LiveSession, c.LiveSessionStudent, c.Organization,
		c.OrganizationInvitation, c.OrganizationMember, c.Plan, c.ShenbiProfile,
		c.ShenbiSettings, c.Subscription, c.User, c.UserApp, c.UserProgress,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Achievement, c.App, c.Assignment, c.AssignmentSubmission, c.BattleRoom,
		c.BattleSession, c.Classroom, c.ClassroomMembership, c.ClassroomSession,
		c.EmailTemplate, c.LiveSession, c.LiveSessionStudent, c.Organization,
		c.OrganizationInvitation, c.OrganizationMember, c.Plan, c.ShenbiProfile,
		c.ShenbiSettings, c.Subscription, c.User, c.UserApp, c.UserProgress,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AchievementMutation:
		return c.Achievement.mutate(ctx, m)
	case *AppMutation:
		return c.App.mutate(ctx, m)
	case *AssignmentMutation:
		return c.Assignment.mutate(ctx, m)
	case *AssignmentSubmissionMutation:
		return c.AssignmentSubmission.mutate(ctx, m)
	case *BattleRoomMutation:
		return c.BattleRoom.mutate(ctx, m)
	case *BattleSessionMutation:
		return c.BattleSession.mutate(ctx, m)
	case *ClassroomMutation:
		return c.Classroom.mutate(ctx, m)
	case *ClassroomMembershipMutation:
		return c.ClassroomMembership.mutate(ctx, m)
	case *ClassroomSessionMutation:
		return c.ClassroomSession.mutate(ctx, m)
	case *EmailTemplateMutation:
		return c.EmailTemplate.mutate(ctx, m)
	case *LiveSessionMutation:
		return c.LiveSession.mutate(ctx, m)
	case *LiveSessionStudentMutation:
		return c.LiveSessionStudent.mutate(ctx, m)
	case *OrganizationMutation:
		return c.Organization.mutate(ctx, m)
	case *OrganizationInvitationMutation:
		return c.OrganizationInvitation.mutate(ctx, m)
	case *OrganizationMemberMutation:
		return c.OrganizationMember.mutate(ctx, m)
	case *PlanMutation:
		return c.Plan.mutate(ctx, m)
	case *ShenbiProfileMutation:
		return c.ShenbiProfile.mutate(ctx, m)
	case *ShenbiSettingsMutation:
		return c.ShenbiSettings.mutate(ctx, m)
	case *SubscriptionMutation:
		return c.Subscription.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserAppMutation:
		return c.UserApp.mutate(ctx, m)
	case *UserProgressMutation:
		return c.UserProgress.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AchievementClient is a client for the Achievement schema.
type AchievementClient struct {
	config
}

// NewAchievementClient returns a client for the Achievement from the given config.
func NewAchievementClient(c config) *AchievementClient {
	return &AchievementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `achievement.Hooks(f(g(h())))`.
func (c *AchievementClient) Use(hooks ...Hook) {
	c.hooks.Achievement = append(c.hooks.Achievement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `achievement.Intercept(f(g(h())))`.
func (c *AchievementClient) Intercept(interceptors ...Interceptor) {
	c.inters.Achievement = append(c.inters.Achievement, interceptors...)
}

// Create returns a builder for creating a Achievement entity.
func (c *AchievementClient) Create() *AchievementCreate {
	mutation := newAchievementMutation(c.config, OpCreate)
	return &AchievementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Achievement entities.
func (c *AchievementClient) CreateBulk(builders ...*AchievementCreate) *AchievementCreateBulk {
	return &AchievementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AchievementClient) MapCreateBulk(slice any, setFunc func(*AchievementCreate, int)) *AchievementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AchievementCreateBulk{err: fmt.Errorf("calling to AchievementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AchievementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AchievementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Achievement.
func (c *AchievementClient) Update() *AchievementUpdate {
	mutation := newAchievementMutation(c.config, OpUpdate)
	return &AchievementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AchievementClient) UpdateOne(_m *Achievement) *AchievementUpdateOne {
	mutation := newAchievementMutation(c.config, OpUpdateOne, withAchievement(_m))
	return &AchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AchievementClient) UpdateOneID(id int) *AchievementUpdateOne {
	mutation := newAchievementMutation(c.config, OpUpdateOne, withAchievementID(id))
	return &AchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Achievement.
func (c *AchievementClient) Delete() *AchievementDelete {
	mutation := newAchievementMutation(c.config, OpDelete)
	return &AchievementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AchievementClient) DeleteOne(_m *Achievement) *AchievementDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AchievementClient) DeleteOneID(id int) *AchievementDeleteOne {
	builder := c.Delete().Where(achievement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AchievementDeleteOne{builder}
}

// Query returns a query builder for Achievement.
func (c *AchievementClient) Query() *AchievementQuery {
	return &AchievementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAchievement},
		inters: c.Interceptors(),
	}
}

// Get returns a Achievement entity by its id.
func (c *AchievementClient) Get(ctx context.Context, id int) (*Achievement, error) {
	return c.Query().Where(achievement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AchievementClient) GetX(ctx context.Context, id int) *Achievement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a Achievement.
func (c *AchievementClient) QueryApp(_m *Achievement) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(achievement.Table, achievement.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, achievement.AppTable, achievement.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Achievement.
func (c *AchievementClient) QueryUser(_m *Achievement) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(achievement.Table, achievement.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, achievement.UserTable, achievement.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AchievementClient) Hooks() []Hook {
	return c.hooks.Achievement
}

// Interceptors returns the client interceptors.
func (c *AchievementClient) Interceptors() []Interceptor {
	return c.inters.Achievement
}

func (c *AchievementClient) mutate(ctx context.Context, m *AchievementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AchievementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AchievementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AchievementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Achievement mutation op: %q", m.Op())
	}
}

// AppClient is a client for the App schema.
type AppClient struct {
	config
}

// NewAppClient returns a client for the App from the given config.
func NewAppClient(c config) *AppClient {
	return &AppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `app.Hooks(f(g(h())))`.
func (c *AppClient) Use(hooks ...Hook) {
	c.hooks.App = append(c.hooks.App, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `app.Intercept(f(g(h())))`.
func (c *AppClient) Intercept(interceptors ...Interceptor) {
	c.inters.App = append(c.inters.App, interceptors...)
}

// Create returns a builder for creating a App entity.
func (c *AppClient) Create() *AppCreate {
	mutation := newAppMutation(c.config, OpCreate)
	return &AppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of App entities.
func (c *AppClient) CreateBulk(builders ...*AppCreate) *AppCreateBulk {
	return &AppCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppClient) MapCreateBulk(slice any, setFunc func(*AppCreate, int)) *AppCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppCreateBulk{err: fmt.Errorf("calling to AppClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for App.
func (c *AppClient) Update() *AppUpdate {
	mutation := newAppMutation(c.config, OpUpdate)
	return &AppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppClient) UpdateOne(_m *App) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withApp(_m))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppClient) UpdateOneID(id int) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withAppID(id))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for App.
func (c *AppClient) Delete() *AppDelete {
	mutation := newAppMutation(c.config, OpDelete)
	return &AppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppClient) DeleteOne(_m *App) *AppDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppClient) DeleteOneID(id int) *AppDeleteOne {
	builder := c.Delete().Where(app.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDeleteOne{builder}
}

// Query returns a query builder for App.
func (c *AppClient) Query() *AppQuery {
	return &AppQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApp},
		inters: c.Interceptors(),
	}
}

// Get returns a App entity by its id.
func (c *AppClient) Get(ctx context.Context, id int) (*App, error) {
	return c.Query().Where(app.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppClient) GetX(ctx context.Context, id int) *App {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserApps queries the user_apps edge of a App.
func (c *AppClient) QueryUserApps(_m *App) *UserAppQuery {
	query := (&UserAppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(userapp.Table, userapp.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.UserAppsTable, app.UserAppsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizations queries the organizations edge of a App.
func (c *AppClient) QueryOrganizations(_m *App) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.OrganizationsTable, app.OrganizationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlans queries the plans edge of a App.
func (c *AppClient) QueryPlans(_m *App) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.PlansTable, app.PlansColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a App.
func (c *AppClient) QuerySubscriptions(_m *App) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.SubscriptionsTable, app.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmailTemplates queries the email_templates edge of a App.
func (c *AppClient) QueryEmailTemplates(_m *App) *EmailTemplateQuery {
	query := (&EmailTemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(emailtemplate.Table, emailtemplate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.EmailTemplatesTable, app.EmailTemplatesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShenbiProfiles queries the shenbi_profiles edge of a App.
func (c *AppClient) QueryShenbiProfiles(_m *App) *ShenbiProfileQuery {
	query := (&ShenbiProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(shenbiprofile.Table, shenbiprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.ShenbiProfilesTable, app.ShenbiProfilesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClassrooms queries the classrooms edge of a App.
func (c *AppClient) QueryClassrooms(_m *App) *ClassroomQuery {
	query := (&ClassroomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(classroom.Table, classroom.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.ClassroomsTable, app.ClassroomsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserProgress queries the user_progress edge of a App.
func (c *AppClient) QueryUserProgress(_m *App) *UserProgressQuery {
	query := (&UserProgressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(userprogress.Table, userprogress.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.UserProgressTable, app.UserProgressColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAchievements queries the achievements edge of a App.
func (c *AppClient) QueryAchievements(_m *App) *AchievementQuery {
	query := (&AchievementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(achievement.Table, achievement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.AchievementsTable, app.AchievementsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBattleRooms queries the battle_rooms edge of a App.
func (c *AppClient) QueryBattleRooms(_m *App) *BattleRoomQuery {
	query := (&BattleRoomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(battleroom.Table, battleroom.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.BattleRoomsTable, app.BattleRoomsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBattleSessions queries the battle_sessions edge of a App.
func (c *AppClient) QueryBattleSessions(_m *App) *BattleSessionQuery {
	query := (&BattleSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(battlesession.Table, battlesession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.BattleSessionsTable, app.BattleSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLiveSessions queries the live_sessions edge of a App.
func (c *AppClient) QueryLiveSessions(_m *App) *LiveSessionQuery {
	query := (&LiveSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(livesession.Table, livesession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.LiveSessionsTable, app.LiveSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClassroomSessions queries the classroom_sessions edge of a App.
func (c *AppClient) QueryClassroomSessions(_m *App) *ClassroomSessionQuery {
	query := (&ClassroomSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(classroomsession.Table, classroomsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.ClassroomSessionsTable, app.ClassroomSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShenbiSettings queries the shenbi_settings edge of a App.
func (c *AppClient) QueryShenbiSettings(_m *App) *ShenbiSettingsQuery {
	query := (&ShenbiSettingsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(shenbisettings.Table, shenbisettings.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.ShenbiSettingsTable, app.ShenbiSettingsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppClient) Hooks() []Hook {
	return c.hooks.App
}

// Interceptors returns the client interceptors.
func (c *AppClient) Interceptors() []Interceptor {
	return c.inters.App
}

func (c *AppClient) mutate(ctx context.Context, m *AppMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown App mutation op: %q", m.Op())
	}
}

// AssignmentClient is a client for the Assignment schema.
type AssignmentClient struct {
	config
}

// NewAssignmentClient returns a client for the Assignment from the given config.
func NewAssignmentClient(c config) *AssignmentClient {
	return &AssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assignment.Hooks(f(g(h())))`.
func (c *AssignmentClient) Use(hooks ...Hook) {
	c.hooks.Assignment = append(c.hooks.Assignment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assignment.Intercept(f(g(h())))`.
func (c *AssignmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Assignment = append(c.inters.Assignment, interceptors...)
}

// Create returns a builder for creating a Assignment entity.
func (c *AssignmentClient) Create() *AssignmentCreate {
	mutation := newAssignmentMutation(c.config, OpCreate)
	return &AssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Assignment entities.
func (c *AssignmentClient) CreateBulk(builders ...*AssignmentCreate) *AssignmentCreateBulk {
	return &AssignmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssignmentClient) MapCreateBulk(slice any, setFunc func(*AssignmentCreate, int)) *AssignmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssignmentCreateBulk{err: fmt.Errorf("calling to AssignmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssignmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Assignment.
func (c *AssignmentClient) Update() *AssignmentUpdate {
	mutation := newAssignmentMutation(c.config, OpUpdate)
	return &AssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssignmentClient) UpdateOne(_m *Assignment) *AssignmentUpdateOne {
	mutation := newAssignmentMutation(c.config, OpUpdateOne, withAssignment(_m))
	return &AssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssignmentClient) UpdateOneID(id int) *AssignmentUpdateOne {
	mutation := newAssignmentMutation(c.config, OpUpdateOne, withAssignmentID(id))
	return &AssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Assignment.
func (c *AssignmentClient) Delete() *AssignmentDelete {
	mutation := newAssignmentMutation(c.config, OpDelete)
	return &AssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssignmentClient) DeleteOne(_m *Assignment) *AssignmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssignmentClient) DeleteOneID(id int) *AssignmentDeleteOne {
	builder := c.Delete().Where(assignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssignmentDeleteOne{builder}
}

// Query returns a query builder for Assignment.
func (c *AssignmentClient) Query() *AssignmentQuery {
	return &AssignmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssignment},
		inters: c.Interceptors(),
	}
}

// Get returns a Assignment entity by its id.
func (c *AssignmentClient) Get(ctx context.Context, id int) (*Assignment, error) {
	return c.Query().Where(assignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssignmentClient) GetX(ctx context.Context, id int) *Assignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClassroom queries the classroom edge of a Assignment.
func (c *AssignmentClient) QueryClassroom(_m *Assignment) *ClassroomQuery {
	query := (&ClassroomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assignment.Table, assignment.FieldID, id),
			sqlgraph.To(classroom.Table, classroom.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assignment.ClassroomTable, assignment.ClassroomColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubmissions queries the submissions edge of a Assignment.
func (c *AssignmentClient) QuerySubmissions(_m *Assignment) *AssignmentSubmissionQuery {
	query := (&AssignmentSubmissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assignment.Table, assignment.FieldID, id),
			sqlgraph.To(assignmentsubmission.Table, assignmentsubmission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, assignment.SubmissionsTable, assignment.SubmissionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssignmentClient) Hooks() []Hook {
	return c.hooks.Assignment
}

// Interceptors returns the client interceptors.
func (c *AssignmentClient) Interceptors() []Interceptor {
	return c.inters.Assignment
}

func (c *AssignmentClient) mutate(ctx context.Context, m *AssignmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Assignment mutation op: %q", m.Op())
	}
}

// AssignmentSubmissionClient is a client for the AssignmentSubmission schema.
type AssignmentSubmissionClient struct {
	config
}

// NewAssignmentSubmissionClient returns a client for the AssignmentSubmission from the given config.
func NewAssignmentSubmissionClient(c config) *AssignmentSubmissionClient {
	return &AssignmentSubmissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assignmentsubmission.Hooks(f(g(h())))`.
func (c *AssignmentSubmissionClient) Use(hooks ...Hook) {
	c.hooks.AssignmentSubmission = append(c.hooks.AssignmentSubmission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assignmentsubmission.Intercept(f(g(h())))`.
func (c *AssignmentSubmissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.AssignmentSubmission = append(c.inters.AssignmentSubmission, interceptors...)
}

// Create returns a builder for creating a AssignmentSubmission entity.
func (c *AssignmentSubmissionClient) Create() *AssignmentSubmissionCreate {
	mutation := newAssignmentSubmissionMutation(c.config, OpCreate)
	return &AssignmentSubmissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssignmentSubmission entities.
func (c *AssignmentSubmissionClient) CreateBulk(builders ...*AssignmentSubmissionCreate) *AssignmentSubmissionCreateBulk {
	return &AssignmentSubmissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssignmentSubmissionClient) MapCreateBulk(slice any, setFunc func(*AssignmentSubmissionCreate, int)) *AssignmentSubmissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssignmentSubmissionCreateBulk{err: fmt.Errorf("calling to AssignmentSubmissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssignmentSubmissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssignmentSubmissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssignmentSubmission.
func (c *AssignmentSubmissionClient) Update() *AssignmentSubmissionUpdate {
	mutation := newAssignmentSubmissionMutation(c.config, OpUpdate)
	return &AssignmentSubmissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssignmentSubmissionClient) UpdateOne(_m *AssignmentSubmission) *AssignmentSubmissionUpdateOne {
	mutation := newAssignmentSubmissionMutation(c.config, OpUpdateOne, withAssignmentSubmission(_m))
	return &AssignmentSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssignmentSubmissionClient) UpdateOneID(id int) *AssignmentSubmissionUpdateOne {
	mutation := newAssignmentSubmissionMutation(c.config, OpUpdateOne, withAssignmentSubmissionID(id))
	return &AssignmentSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssignmentSubmission.
func (c *AssignmentSubmissionClient) Delete() *AssignmentSubmissionDelete {
	mutation := newAssignmentSubmissionMutation(c.config, OpDelete)
	return &AssignmentSubmissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssignmentSubmissionClient) DeleteOne(_m *AssignmentSubmission) *AssignmentSubmissionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssignmentSubmissionClient) DeleteOneID(id int) *AssignmentSubmissionDeleteOne {
	builder := c.Delete().Where(assignmentsubmission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssignmentSubmissionDeleteOne{builder}
}

// Query returns a query builder for AssignmentSubmission.
func (c *AssignmentSubmissionClient) Query() *AssignmentSubmissionQuery {
	return &AssignmentSubmissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssignmentSubmission},
		inters: c.Interceptors(),
	}
}

// Get returns a AssignmentSubmission entity by its id.
func (c *AssignmentSubmissionClient) Get(ctx context.Context, id int) (*AssignmentSubmission, error) {
	return c.Query().Where(assignmentsubmission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssignmentSubmissionClient) GetX(ctx context.Context, id int) *AssignmentSubmission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAssignment queries the assignment edge of a AssignmentSubmission.
func (c *AssignmentSubmissionClient) QueryAssignment(_m *AssignmentSubmission) *AssignmentQuery {
	query := (&AssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assignmentsubmission.Table, assignmentsubmission.FieldID, id),
			sqlgraph.To(assignment.Table, assignment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assignmentsubmission.AssignmentTable, assignmentsubmission.AssignmentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudent queries the student edge of a AssignmentSubmission.
func (c *AssignmentSubmissionClient) QueryStudent(_m *AssignmentSubmission) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assignmentsubmission.Table, assignmentsubmission.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assignmentsubmission.StudentTable, assignmentsubmission.StudentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssignmentSubmissionClient) Hooks() []Hook {
	return c.hooks.AssignmentSubmission
}

// Interceptors returns the client interceptors.
func (c *AssignmentSubmissionClient) Interceptors() []Interceptor {
	return c.inters.AssignmentSubmission
}

func (c *AssignmentSubmissionClient) mutate(ctx context.Context, m *AssignmentSubmissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssignmentSubmissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssignmentSubmissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssignmentSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssignmentSubmissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AssignmentSubmission mutation op: %q", m.Op())
	}
}

// BattleRoomClient is a client for the BattleRoom schema.
type BattleRoomClient struct {
	config
}

// NewBattleRoomClient returns a client for the BattleRoom from the given config.
func NewBattleRoomClient(c config) *BattleRoomClient {
	return &BattleRoomClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `battleroom.Hooks(f(g(h())))`.
func (c *BattleRoomClient) Use(hooks ...Hook) {
	c.hooks.BattleRoom = append(c.hooks.BattleRoom, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `battleroom.Intercept(f(g(h())))`.
func (c *BattleRoomClient) Intercept(interceptors ...Interceptor) {
	c.inters.BattleRoom = append(c.inters.BattleRoom, interceptors...)
}

// Create returns a builder for creating a BattleRoom entity.
func (c *BattleRoomClient) Create() *BattleRoomCreate {
	mutation := newBattleRoomMutation(c.config, OpCreate)
	return &BattleRoomCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BattleRoom entities.
func (c *BattleRoomClient) CreateBulk(builders ...*BattleRoomCreate) *BattleRoomCreateBulk {
	return &BattleRoomCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BattleRoomClient) MapCreateBulk(slice any, setFunc func(*BattleRoomCreate, int)) *BattleRoomCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BattleRoomCreateBulk{err: fmt.Errorf("calling to BattleRoomClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BattleRoomCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BattleRoomCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BattleRoom.
func (c *BattleRoomClient) Update() *BattleRoomUpdate {
	mutation := newBattleRoomMutation(c.config, OpUpdate)
	return &BattleRoomUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BattleRoomClient) UpdateOne(_m *BattleRoom) *BattleRoomUpdateOne {
	mutation := newBattleRoomMutation(c.config, OpUpdateOne, withBattleRoom(_m))
	return &BattleRoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BattleRoomClient) UpdateOneID(id int) *BattleRoomUpdateOne {
	mutation := newBattleRoomMutation(c.config, OpUpdateOne, withBattleRoomID(id))
	return &BattleRoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BattleRoom.
func (c *BattleRoomClient) Delete() *BattleRoomDelete {
	mutation := newBattleRoomMutation(c.config, OpDelete)
	return &BattleRoomDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BattleRoomClient) DeleteOne(_m *BattleRoom) *BattleRoomDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BattleRoomClient) DeleteOneID(id int) *BattleRoomDeleteOne {
	builder := c.Delete().Where(battleroom.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BattleRoomDeleteOne{builder}
}

// Query returns a query builder for BattleRoom.
func (c *BattleRoomClient) Query() *BattleRoomQuery {
	return &BattleRoomQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBattleRoom},
		inters: c.Interceptors(),
	}
}

// Get returns a BattleRoom entity by its id.
func (c *BattleRoomClient) Get(ctx context.Context, id int) (*BattleRoom, error) {
	return c.Query().Where(battleroom.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BattleRoomClient) GetX(ctx context.Context, id int) *BattleRoom {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a BattleRoom.
func (c *BattleRoomClient) QueryApp(_m *BattleRoom) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(battleroom.Table, battleroom.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, battleroom.AppTable, battleroom.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHost queries the host edge of a BattleRoom.
func (c *BattleRoomClient) QueryHost(_m *BattleRoom) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(battleroom.Table, battleroom.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, battleroom.HostTable, battleroom.HostColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BattleRoomClient) Hooks() []Hook {
	return c.hooks.BattleRoom
}

// Interceptors returns the client interceptors.
func (c *BattleRoomClient) Interceptors() []Interceptor {
	return c.inters.BattleRoom
}

func (c *BattleRoomClient) mutate(ctx context.Context, m *BattleRoomMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BattleRoomCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BattleRoomUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BattleRoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BattleRoomDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BattleRoom mutation op: %q", m.Op())
	}
}

// BattleSessionClient is a client for the BattleSession schema.
type BattleSessionClient struct {
	config
}

// NewBattleSessionClient returns a client for the BattleSession from the given config.
func NewBattleSessionClient(c config) *BattleSessionClient {
	return &BattleSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `battlesession.Hooks(f(g(h())))`.
func (c *BattleSessionClient) Use(hooks ...Hook) {
	c.hooks.BattleSession = append(c.hooks.BattleSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `battlesession.Intercept(f(g(h())))`.
func (c *BattleSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.BattleSession = append(c.inters.BattleSession, interceptors...)
}

// Create returns a builder for creating a BattleSession entity.
func (c *BattleSessionClient) Create() *BattleSessionCreate {
	mutation := newBattleSessionMutation(c.config, OpCreate)
	return &BattleSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BattleSession entities.
func (c *BattleSessionClient) CreateBulk(builders ...*BattleSessionCreate) *BattleSessionCreateBulk {
	return &BattleSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BattleSessionClient) MapCreateBulk(slice any, setFunc func(*BattleSessionCreate, int)) *BattleSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BattleSessionCreateBulk{err: fmt.Errorf("calling to BattleSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BattleSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BattleSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BattleSession.
func (c *BattleSessionClient) Update() *BattleSessionUpdate {
	mutation := newBattleSessionMutation(c.config, OpUpdate)
	return &BattleSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BattleSessionClient) UpdateOne(_m *BattleSession) *BattleSessionUpdateOne {
	mutation := newBattleSessionMutation(c.config, OpUpdateOne, withBattleSession(_m))
	return &BattleSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BattleSessionClient) UpdateOneID(id int) *BattleSessionUpdateOne {
	mutation := newBattleSessionMutation(c.config, OpUpdateOne, withBattleSessionID(id))
	return &BattleSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BattleSession.
func (c *BattleSessionClient) Delete() *BattleSessionDelete {
	mutation := newBattleSessionMutation(c.config, OpDelete)
	return &BattleSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BattleSessionClient) DeleteOne(_m *BattleSession) *BattleSessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BattleSessionClient) DeleteOneID(id int) *BattleSessionDeleteOne {
	builder := c.Delete().Where(battlesession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BattleSessionDeleteOne{builder}
}

// Query returns a query builder for BattleSession.
func (c *BattleSessionClient) Query() *BattleSessionQuery {
	return &BattleSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBattleSession},
		inters: c.Interceptors(),
	}
}

// Get returns a BattleSession entity by its id.
func (c *BattleSessionClient) Get(ctx context.Context, id int) (*BattleSession, error) {
	return c.Query().Where(battlesession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BattleSessionClient) GetX(ctx context.Context, id int) *BattleSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a BattleSession.
func (c *BattleSessionClient) QueryApp(_m *BattleSession) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(battlesession.Table, battlesession.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, battlesession.AppTable, battlesession.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a BattleSession.
func (c *BattleSessionClient) QueryUser(_m *BattleSession) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(battlesession.Table, battlesession.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, battlesession.UserTable, battlesession.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BattleSessionClient) Hooks() []Hook {
	return c.hooks.BattleSession
}

// Interceptors returns the client interceptors.
func (c *BattleSessionClient) Interceptors() []Interceptor {
	return c.inters.BattleSession
}

func (c *BattleSessionClient) mutate(ctx context.Context, m *BattleSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BattleSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BattleSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BattleSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BattleSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BattleSession mutation op: %q", m.Op())
	}
}

// ClassroomClient is a client for the Classroom schema.
type ClassroomClient struct {
	config
}

// NewClassroomClient returns a client for the Classroom from the given config.
func NewClassroomClient(c config) *ClassroomClient {
	return &ClassroomClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `classroom.Hooks(f(g(h())))`.
func (c *ClassroomClient) Use(hooks ...Hook) {
	c.hooks.Classroom = append(c.hooks.Classroom, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `classroom.Intercept(f(g(h())))`.
func (c *ClassroomClient) Intercept(interceptors ...Interceptor) {
	c.inters.Classroom = append(c.inters.Classroom, interceptors...)
}

// Create returns a builder for creating a Classroom entity.
func (c *ClassroomClient) Create() *ClassroomCreate {
	mutation := newClassroomMutation(c.config, OpCreate)
	return &ClassroomCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Classroom entities.
func (c *ClassroomClient) CreateBulk(builders ...*ClassroomCreate) *ClassroomCreateBulk {
	return &ClassroomCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClassroomClient) MapCreateBulk(slice any, setFunc func(*ClassroomCreate, int)) *ClassroomCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClassroomCreateBulk{err: fmt.Errorf("calling to ClassroomClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClassroomCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClassroomCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Classroom.
func (c *ClassroomClient) Update() *ClassroomUpdate {
	mutation := newClassroomMutation(c.config, OpUpdate)
	return &ClassroomUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClassroomClient) UpdateOne(_m *Classroom) *ClassroomUpdateOne {
	mutation := newClassroomMutation(c.config, OpUpdateOne, withClassroom(_m))
	return &ClassroomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClassroomClient) UpdateOneID(id int) *ClassroomUpdateOne {
	mutation := newClassroomMutation(c.config, OpUpdateOne, withClassroomID(id))
	return &ClassroomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Classroom.
func (c *ClassroomClient) Delete() *ClassroomDelete {
	mutation := newClassroomMutation(c.config, OpDelete)
	return &ClassroomDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClassroomClient) DeleteOne(_m *Classroom) *ClassroomDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClassroomClient) DeleteOneID(id int) *ClassroomDeleteOne {
	builder := c.Delete().Where(classroom.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClassroomDeleteOne{builder}
}

// Query returns a query builder for Classroom.
func (c *ClassroomClient) Query() *ClassroomQuery {
	return &ClassroomQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClassroom},
		inters: c.Interceptors(),
	}
}

// Get returns a Classroom entity by its id.
func (c *ClassroomClient) Get(ctx context.Context, id int) (*Classroom, error) {
	return c.Query().Where(classroom.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClassroomClient) GetX(ctx context.Context, id int) *Classroom {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a Classroom.
func (c *ClassroomClient) QueryApp(_m *Classroom) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(classroom.Table, classroom.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, classroom.AppTable, classroom.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeacher queries the teacher edge of a Classroom.
func (c *ClassroomClient) QueryTeacher(_m *Classroom) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(classroom.Table, classroom.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, classroom.TeacherTable, classroom.TeacherColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberships queries the memberships edge of a Classroom.
func (c *ClassroomClient) QueryMemberships(_m *Classroom) *ClassroomMembershipQuery {
	query := (&ClassroomMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(classroom.Table, classroom.FieldID, id),
			sqlgraph.To(classroommembership.Table, classroommembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, classroom.MembershipsTable, classroom.MembershipsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignments queries the assignments edge of a Classroom.
func (c *ClassroomClient) QueryAssignments(_m *Classroom) *AssignmentQuery {
	query := (&AssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(classroom.Table, classroom.FieldID, id),
			sqlgraph.To(assignment.Table, assignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, classroom.AssignmentsTable, classroom.AssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLiveSessions queries the live_sessions edge of a Classroom.
func (c *ClassroomClient) QueryLiveSessions(_m *Classroom) *LiveSessionQuery {
	query := (&LiveSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(classroom.Table, classroom.FieldID, id),
			sqlgraph.To(livesession.Table, livesession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, classroom.LiveSessionsTable, classroom.LiveSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClassroomSessions queries the classroom_sessions edge of a Classroom.
func (c *ClassroomClient) QueryClassroomSessions(_m *Classroom) *ClassroomSessionQuery {
	query := (&ClassroomSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(classroom.Table, classroom.FieldID, id),
			sqlgraph.To(classroomsession.Table, classroomsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, classroom.ClassroomSessionsTable, classroom.ClassroomSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClassroomClient) Hooks() []Hook {
	return c.hooks.Classroom
}

// Interceptors returns the client interceptors.
func (c *ClassroomClient) Interceptors() []Interceptor {
	return c.inters.Classroom
}

func (c *ClassroomClient) mutate(ctx context.Context, m *ClassroomMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClassroomCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClassroomUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClassroomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClassroomDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Classroom mutation op: %q", m.Op())
	}
}

// ClassroomMembershipClient is a client for the ClassroomMembership schema.
type ClassroomMembershipClient struct {
	config
}

// NewClassroomMembershipClient returns a client for the ClassroomMembership from the given config.
func NewClassroomMembershipClient(c config) *ClassroomMembershipClient {
	return &ClassroomMembershipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `classroommembership.Hooks(f(g(h())))`.
func (c *ClassroomMembershipClient) Use(hooks ...Hook) {
	c.hooks.ClassroomMembership = append(c.hooks.ClassroomMembership, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `classroommembership.Intercept(f(g(h())))`.
func (c *ClassroomMembershipClient) Intercept(interceptors ...Interceptor) {
	c.inters.ClassroomMembership = append(c.inters.ClassroomMembership, interceptors...)
}

// Create returns a builder for creating a ClassroomMembership entity.
func (c *ClassroomMembershipClient) Create() *ClassroomMembershipCreate {
	mutation := newClassroomMembershipMutation(c.config, OpCreate)
	return &ClassroomMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ClassroomMembership entities.
func (c *ClassroomMembershipClient) CreateBulk(builders ...*ClassroomMembershipCreate) *ClassroomMembershipCreateBulk {
	return &ClassroomMembershipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClassroomMembershipClient) MapCreateBulk(slice any, setFunc func(*ClassroomMembershipCreate, int)) *ClassroomMembershipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClassroomMembershipCreateBulk{err: fmt.Errorf("calling to ClassroomMembershipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClassroomMembershipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClassroomMembershipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ClassroomMembership.
func (c *ClassroomMembershipClient) Update() *ClassroomMembershipUpdate {
	mutation := newClassroomMembershipMutation(c.config, OpUpdate)
	return &ClassroomMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClassroomMembershipClient) UpdateOne(_m *ClassroomMembership) *ClassroomMembershipUpdateOne {
	mutation := newClassroomMembershipMutation(c.config, OpUpdateOne, withClassroomMembership(_m))
	return &ClassroomMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClassroomMembershipClient) UpdateOneID(id int) *ClassroomMembershipUpdateOne {
	mutation := newClassroomMembershipMutation(c.config, OpUpdateOne, withClassroomMembershipID(id))
	return &ClassroomMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ClassroomMembership.
func (c *ClassroomMembershipClient) Delete() *ClassroomMembershipDelete {
	mutation := newClassroomMembershipMutation(c.config, OpDelete)
	return &ClassroomMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClassroomMembershipClient) DeleteOne(_m *ClassroomMembership) *ClassroomMembershipDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClassroomMembershipClient) DeleteOneID(id int) *ClassroomMembershipDeleteOne {
	builder := c.Delete().Where(classroommembership.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClassroomMembershipDeleteOne{builder}
}

// Query returns a query builder for ClassroomMembership.
func (c *ClassroomMembershipClient) Query() *ClassroomMembershipQuery {
	return &ClassroomMembershipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClassroomMembership},
		inters: c.Interceptors(),
	}
}

// Get returns a ClassroomMembership entity by its id.
func (c *ClassroomMembershipClient) Get(ctx context.Context, id int) (*ClassroomMembership, error) {
	return c.Query().Where(classroommembership.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClassroomMembershipClient) GetX(ctx context.Context, id int) *ClassroomMembership {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClassroom queries the classroom edge of a ClassroomMembership.
func (c *ClassroomMembershipClient) QueryClassroom(_m *ClassroomMembership) *ClassroomQuery {
	query := (&ClassroomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(classroommembership.Table, classroommembership.FieldID, id),
			sqlgraph.To(classroom.Table, classroom.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, classroommembership.ClassroomTable, classroommembership.ClassroomColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudent queries the student edge of a ClassroomMembership.
func (c *ClassroomMembershipClient) QueryStudent(_m *ClassroomMembership) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(classroommembership.Table, classroommembership.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, classroommembership.StudentTable, classroommembership.StudentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClassroomMembershipClient) Hooks() []Hook {
	return c.hooks.ClassroomMembership
}

// Interceptors returns the client interceptors.
func (c *ClassroomMembershipClient) Interceptors() []Interceptor {
	return c.inters.ClassroomMembership
}

func (c *ClassroomMembershipClient) mutate(ctx context.Context, m *ClassroomMembershipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClassroomMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClassroomMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClassroomMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClassroomMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ClassroomMembership mutation op: %q", m.Op())
	}
}

// ClassroomSessionClient is a client for the ClassroomSession schema.
type ClassroomSessionClient struct {
	config
}

// NewClassroomSessionClient returns a client for the ClassroomSession from the given config.
func NewClassroomSessionClient(c config) *ClassroomSessionClient {
	return &ClassroomSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `classroomsession.Hooks(f(g(h())))`.
func (c *ClassroomSessionClient) Use(hooks ...Hook) {
	c.hooks.ClassroomSession = append(c.hooks.ClassroomSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `classroomsession.Intercept(f(g(h())))`.
func (c *ClassroomSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.ClassroomSession = append(c.inters.ClassroomSession, interceptors...)
}

// Create returns a builder for creating a ClassroomSession entity.
func (c *ClassroomSessionClient) Create() *ClassroomSessionCreate {
	mutation := newClassroomSessionMutation(c.config, OpCreate)
	return &ClassroomSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ClassroomSession entities.
func (c *ClassroomSessionClient) CreateBulk(builders ...*ClassroomSessionCreate) *ClassroomSessionCreateBulk {
	return &ClassroomSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClassroomSessionClient) MapCreateBulk(slice any, setFunc func(*ClassroomSessionCreate, int)) *ClassroomSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClassroomSessionCreateBulk{err: fmt.Errorf("calling to ClassroomSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClassroomSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClassroomSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ClassroomSession.
func (c *ClassroomSessionClient) Update() *ClassroomSessionUpdate {
	mutation := newClassroomSessionMutation(c.config, OpUpdate)
	return &ClassroomSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClassroomSessionClient) UpdateOne(_m *ClassroomSession) *ClassroomSessionUpdateOne {
	mutation := newClassroomSessionMutation(c.config, OpUpdateOne, withClassroomSession(_m))
	return &ClassroomSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClassroomSessionClient) UpdateOneID(id int) *ClassroomSessionUpdateOne {
	mutation := newClassroomSessionMutation(c.config, OpUpdateOne, withClassroomSessionID(id))
	return &ClassroomSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ClassroomSession.
func (c *ClassroomSessionClient) Delete() *ClassroomSessionDelete {
	mutation := newClassroomSessionMutation(c.config, OpDelete)
	return &ClassroomSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClassroomSessionClient) DeleteOne(_m *ClassroomSession) *ClassroomSessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClassroomSessionClient) DeleteOneID(id int) *ClassroomSessionDeleteOne {
	builder := c.Delete().Where(classroomsession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClassroomSessionDeleteOne{builder}
}

// Query returns a query builder for ClassroomSession.
func (c *ClassroomSessionClient) Query() *ClassroomSessionQuery {
	return &ClassroomSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClassroomSession},
		inters: c.Interceptors(),
	}
}

// Get returns a ClassroomSession entity by its id.
func (c *ClassroomSessionClient) Get(ctx context.Context, id int) (*ClassroomSession, error) {
	return c.Query().Where(classroomsession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClassroomSessionClient) GetX(ctx context.Context, id int) *ClassroomSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a ClassroomSession.
func (c *ClassroomSessionClient) QueryApp(_m *ClassroomSession) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(classroomsession.Table, classroomsession.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, classroomsession.AppTable, classroomsession.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ClassroomSession.
func (c *ClassroomSessionClient) QueryUser(_m *ClassroomSession) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(classroomsession.Table, classroomsession.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, classroomsession.UserTable, classroomsession.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClassroom queries the classroom edge of a ClassroomSession.
func (c *ClassroomSessionClient) QueryClassroom(_m *ClassroomSession) *ClassroomQuery {
	query := (&ClassroomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(classroomsession.Table, classroomsession.FieldID, id),
			sqlgraph.To(classroom.Table, classroom.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, classroomsession.ClassroomTable, classroomsession.ClassroomColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClassroomSessionClient) Hooks() []Hook {
	return c.hooks.ClassroomSession
}

// Interceptors returns the client interceptors.
func (c *ClassroomSessionClient) Interceptors() []Interceptor {
	return c.inters.ClassroomSession
}

func (c *ClassroomSessionClient) mutate(ctx context.Context, m *ClassroomSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClassroomSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClassroomSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClassroomSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClassroomSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ClassroomSession mutation op: %q", m.Op())
	}
}

// EmailTemplateClient is a client for the EmailTemplate schema.
type EmailTemplateClient struct {
	config
}

// NewEmailTemplateClient returns a client for the EmailTemplate from the given config.
func NewEmailTemplateClient(c config) *EmailTemplateClient {
	return &EmailTemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emailtemplate.Hooks(f(g(h())))`.
func (c *EmailTemplateClient) Use(hooks ...Hook) {
	c.hooks.EmailTemplate = append(c.hooks.EmailTemplate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `emailtemplate.Intercept(f(g(h())))`.
func (c *EmailTemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmailTemplate = append(c.inters.EmailTemplate, interceptors...)
}

// Create returns a builder for creating a EmailTemplate entity.
func (c *EmailTemplateClient) Create() *EmailTemplateCreate {
	mutation := newEmailTemplateMutation(c.config, OpCreate)
	return &EmailTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailTemplate entities.
func (c *EmailTemplateClient) CreateBulk(builders ...*EmailTemplateCreate) *EmailTemplateCreateBulk {
	return &EmailTemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmailTemplateClient) MapCreateBulk(slice any, setFunc func(*EmailTemplateCreate, int)) *EmailTemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmailTemplateCreateBulk{err: fmt.Errorf("calling to EmailTemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmailTemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmailTemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailTemplate.
func (c *EmailTemplateClient) Update() *EmailTemplateUpdate {
	mutation := newEmailTemplateMutation(c.config, OpUpdate)
	return &EmailTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailTemplateClient) UpdateOne(_m *EmailTemplate) *EmailTemplateUpdateOne {
	mutation := newEmailTemplateMutation(c.config, OpUpdateOne, withEmailTemplate(_m))
	return &EmailTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailTemplateClient) UpdateOneID(id int) *EmailTemplateUpdateOne {
	mutation := newEmailTemplateMutation(c.config, OpUpdateOne, withEmailTemplateID(id))
	return &EmailTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailTemplate.
func (c *EmailTemplateClient) Delete() *EmailTemplateDelete {
	mutation := newEmailTemplateMutation(c.config, OpDelete)
	return &EmailTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmailTemplateClient) DeleteOne(_m *EmailTemplate) *EmailTemplateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmailTemplateClient) DeleteOneID(id int) *EmailTemplateDeleteOne {
	builder := c.Delete().Where(emailtemplate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailTemplateDeleteOne{builder}
}

// Query returns a query builder for EmailTemplate.
func (c *EmailTemplateClient) Query() *EmailTemplateQuery {
	return &EmailTemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmailTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a EmailTemplate entity by its id.
func (c *EmailTemplateClient) Get(ctx context.Context, id int) (*EmailTemplate, error) {
	return c.Query().Where(emailtemplate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailTemplateClient) GetX(ctx context.Context, id int) *EmailTemplate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a EmailTemplate.
func (c *EmailTemplateClient) QueryApp(_m *EmailTemplate) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailtemplate.Table, emailtemplate.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailtemplate.AppTable, emailtemplate.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailTemplateClient) Hooks() []Hook {
	return c.hooks.EmailTemplate
}

// Interceptors returns the client interceptors.
func (c *EmailTemplateClient) Interceptors() []Interceptor {
	return c.inters.EmailTemplate
}

func (c *EmailTemplateClient) mutate(ctx context.Context, m *EmailTemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmailTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmailTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmailTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmailTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmailTemplate mutation op: %q", m.Op())
	}
}

// LiveSessionClient is a client for the LiveSession schema.
type LiveSessionClient struct {
	config
}

// NewLiveSessionClient returns a client for the LiveSession from the given config.
func NewLiveSessionClient(c config) *LiveSessionClient {
	return &LiveSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `livesession.Hooks(f(g(h())))`.
func (c *LiveSessionClient) Use(hooks ...Hook) {
	c.hooks.LiveSession = append(c.hooks.LiveSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `livesession.Intercept(f(g(h())))`.
func (c *LiveSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.LiveSession = append(c.inters.LiveSession, interceptors...)
}

// Create returns a builder for creating a LiveSession entity.
func (c *LiveSessionClient) Create() *LiveSessionCreate {
	mutation := newLiveSessionMutation(c.config, OpCreate)
	return &LiveSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LiveSession entities.
func (c *LiveSessionClient) CreateBulk(builders ...*LiveSessionCreate) *LiveSessionCreateBulk {
	return &LiveSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LiveSessionClient) MapCreateBulk(slice any, setFunc func(*LiveSessionCreate, int)) *LiveSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LiveSessionCreateBulk{err: fmt.Errorf("calling to LiveSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LiveSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LiveSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LiveSession.
func (c *LiveSessionClient) Update() *LiveSessionUpdate {
	mutation := newLiveSessionMutation(c.config, OpUpdate)
	return &LiveSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LiveSessionClient) UpdateOne(_m *LiveSession) *LiveSessionUpdateOne {
	mutation := newLiveSessionMutation(c.config, OpUpdateOne, withLiveSession(_m))
	return &LiveSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LiveSessionClient) UpdateOneID(id int) *LiveSessionUpdateOne {
	mutation := newLiveSessionMutation(c.config, OpUpdateOne, withLiveSessionID(id))
	return &LiveSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LiveSession.
func (c *LiveSessionClient) Delete() *LiveSessionDelete {
	mutation := newLiveSessionMutation(c.config, OpDelete)
	return &LiveSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LiveSessionClient) DeleteOne(_m *LiveSession) *LiveSessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LiveSessionClient) DeleteOneID(id int) *LiveSessionDeleteOne {
	builder := c.Delete().Where(livesession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LiveSessionDeleteOne{builder}
}

// Query returns a query builder for LiveSession.
func (c *LiveSessionClient) Query() *LiveSessionQuery {
	return &LiveSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLiveSession},
		inters: c.Interceptors(),
	}
}

// Get returns a LiveSession entity by its id.
func (c *LiveSessionClient) Get(ctx context.Context, id int) (*LiveSession, error) {
	return c.Query().Where(livesession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LiveSessionClient) GetX(ctx context.Context, id int) *LiveSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a LiveSession.
func (c *LiveSessionClient) QueryApp(_m *LiveSession) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(livesession.Table, livesession.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, livesession.AppTable, livesession.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClassroom queries the classroom edge of a LiveSession.
func (c *LiveSessionClient) QueryClassroom(_m *LiveSession) *ClassroomQuery {
	query := (&ClassroomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(livesession.Table, livesession.FieldID, id),
			sqlgraph.To(classroom.Table, classroom.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, livesession.ClassroomTable, livesession.ClassroomColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeacher queries the teacher edge of a LiveSession.
func (c *LiveSessionClient) QueryTeacher(_m *LiveSession) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(livesession.Table, livesession.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, livesession.TeacherTable, livesession.TeacherColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudents queries the students edge of a LiveSession.
func (c *LiveSessionClient) QueryStudents(_m *LiveSession) *LiveSessionStudentQuery {
	query := (&LiveSessionStudentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(livesession.Table, livesession.FieldID, id),
			sqlgraph.To(livesessionstudent.Table, livesessionstudent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, livesession.StudentsTable, livesession.StudentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LiveSessionClient) Hooks() []Hook {
	return c.hooks.LiveSession
}

// Interceptors returns the client interceptors.
func (c *LiveSessionClient) Interceptors() []Interceptor {
	return c.inters.LiveSession
}

func (c *LiveSessionClient) mutate(ctx context.Context, m *LiveSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LiveSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LiveSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LiveSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LiveSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LiveSession mutation op: %q", m.Op())
	}
}

// LiveSessionStudentClient is a client for the LiveSessionStudent schema.
type LiveSessionStudentClient struct {
	config
}

// NewLiveSessionStudentClient returns a client for the LiveSessionStudent from the given config.
func NewLiveSessionStudentClient(c config) *LiveSessionStudentClient {
	return &LiveSessionStudentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `livesessionstudent.Hooks(f(g(h())))`.
func (c *LiveSessionStudentClient) Use(hooks ...Hook) {
	c.hooks.LiveSessionStudent = append(c.hooks.LiveSessionStudent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `livesessionstudent.Intercept(f(g(h())))`.
func (c *LiveSessionStudentClient) Intercept(interceptors ...Interceptor) {
	c.inters.LiveSessionStudent = append(c.inters.LiveSessionStudent, interceptors...)
}

// Create returns a builder for creating a LiveSessionStudent entity.
func (c *LiveSessionStudentClient) Create() *LiveSessionStudentCreate {
	mutation := newLiveSessionStudentMutation(c.config, OpCreate)
	return &LiveSessionStudentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LiveSessionStudent entities.
func (c *LiveSessionStudentClient) CreateBulk(builders ...*LiveSessionStudentCreate) *LiveSessionStudentCreateBulk {
	return &LiveSessionStudentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LiveSessionStudentClient) MapCreateBulk(slice any, setFunc func(*LiveSessionStudentCreate, int)) *LiveSessionStudentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LiveSessionStudentCreateBulk{err: fmt.Errorf("calling to LiveSessionStudentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LiveSessionStudentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LiveSessionStudentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LiveSessionStudent.
func (c *LiveSessionStudentClient) Update() *LiveSessionStudentUpdate {
	mutation := newLiveSessionStudentMutation(c.config, OpUpdate)
	return &LiveSessionStudentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LiveSessionStudentClient) UpdateOne(_m *LiveSessionStudent) *LiveSessionStudentUpdateOne {
	mutation := newLiveSessionStudentMutation(c.config, OpUpdateOne, withLiveSessionStudent(_m))
	return &LiveSessionStudentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LiveSessionStudentClient) UpdateOneID(id int) *LiveSessionStudentUpdateOne {
	mutation := newLiveSessionStudentMutation(c.config, OpUpdateOne, withLiveSessionStudentID(id))
	return &LiveSessionStudentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LiveSessionStudent.
func (c *LiveSessionStudentClient) Delete() *LiveSessionStudentDelete {
	mutation := newLiveSessionStudentMutation(c.config, OpDelete)
	return &LiveSessionStudentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LiveSessionStudentClient) DeleteOne(_m *LiveSessionStudent) *LiveSessionStudentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LiveSessionStudentClient) DeleteOneID(id int) *LiveSessionStudentDeleteOne {
	builder := c.Delete().Where(livesessionstudent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LiveSessionStudentDeleteOne{builder}
}

// Query returns a query builder for LiveSessionStudent.
func (c *LiveSessionStudentClient) Query() *LiveSessionStudentQuery {
	return &LiveSessionStudentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLiveSessionStudent},
		inters: c.Interceptors(),
	}
}

// Get returns a LiveSessionStudent entity by its id.
func (c *LiveSessionStudentClient) Get(ctx context.Context, id int) (*LiveSessionStudent, error) {
	return c.Query().Where(livesessionstudent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LiveSessionStudentClient) GetX(ctx context.Context, id int) *LiveSessionStudent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySession queries the session edge of a LiveSessionStudent.
func (c *LiveSessionStudentClient) QuerySession(_m *LiveSessionStudent) *LiveSessionQuery {
	query := (&LiveSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(livesessionstudent.Table, livesessionstudent.FieldID, id),
			sqlgraph.To(livesession.Table, livesession.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, livesessionstudent.SessionTable, livesessionstudent.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudent queries the student edge of a LiveSessionStudent.
func (c *LiveSessionStudentClient) QueryStudent(_m *LiveSessionStudent) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(livesessionstudent.Table, livesessionstudent.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, livesessionstudent.StudentTable, livesessionstudent.StudentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LiveSessionStudentClient) Hooks() []Hook {
	return c.hooks.LiveSessionStudent
}

// Interceptors returns the client interceptors.
func (c *LiveSessionStudentClient) Interceptors() []Interceptor {
	return c.inters.LiveSessionStudent
}

func (c *LiveSessionStudentClient) mutate(ctx context.Context, m *LiveSessionStudentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LiveSessionStudentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LiveSessionStudentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LiveSessionStudentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LiveSessionStudentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LiveSessionStudent mutation op: %q", m.Op())
	}
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organization.Intercept(f(g(h())))`.
func (c *OrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organization = append(c.inters.Organization, interceptors...)
}

// Create returns a builder for creating a Organization entity.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationClient) MapCreateBulk(slice any, setFunc func(*OrganizationCreate, int)) *OrganizationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationCreateBulk{err: fmt.Errorf("calling to OrganizationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(_m *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(_m))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id int) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationClient) DeleteOne(_m *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationClient) DeleteOneID(id int) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id int) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id int) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a Organization.
func (c *OrganizationClient) QueryApp(_m *Organization) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organization.AppTable, organization.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Organization.
func (c *OrganizationClient) QueryMembers(_m *Organization) *OrganizationMemberQuery {
	query := (&OrganizationMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organizationmember.Table, organizationmember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.MembersTable, organization.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvitations queries the invitations edge of a Organization.
func (c *OrganizationClient) QueryInvitations(_m *Organization) *OrganizationInvitationQuery {
	query := (&OrganizationInvitationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organizationinvitation.Table, organizationinvitation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.InvitationsTable, organization.InvitationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a Organization.
func (c *OrganizationClient) QuerySubscriptions(_m *Organization) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.SubscriptionsTable, organization.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	return c.hooks.Organization
}

// Interceptors returns the client interceptors.
func (c *OrganizationClient) Interceptors() []Interceptor {
	return c.inters.Organization
}

func (c *OrganizationClient) mutate(ctx context.Context, m *OrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Organization mutation op: %q", m.Op())
	}
}

// OrganizationInvitationClient is a client for the OrganizationInvitation schema.
type OrganizationInvitationClient struct {
	config
}

// NewOrganizationInvitationClient returns a client for the OrganizationInvitation from the given config.
func NewOrganizationInvitationClient(c config) *OrganizationInvitationClient {
	return &OrganizationInvitationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organizationinvitation.Hooks(f(g(h())))`.
func (c *OrganizationInvitationClient) Use(hooks ...Hook) {
	c.hooks.OrganizationInvitation = append(c.hooks.OrganizationInvitation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organizationinvitation.Intercept(f(g(h())))`.
func (c *OrganizationInvitationClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrganizationInvitation = append(c.inters.OrganizationInvitation, interceptors...)
}

// Create returns a builder for creating a OrganizationInvitation entity.
func (c *OrganizationInvitationClient) Create() *OrganizationInvitationCreate {
	mutation := newOrganizationInvitationMutation(c.config, OpCreate)
	return &OrganizationInvitationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrganizationInvitation entities.
func (c *OrganizationInvitationClient) CreateBulk(builders ...*OrganizationInvitationCreate) *OrganizationInvitationCreateBulk {
	return &OrganizationInvitationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationInvitationClient) MapCreateBulk(slice any, setFunc func(*OrganizationInvitationCreate, int)) *OrganizationInvitationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationInvitationCreateBulk{err: fmt.Errorf("calling to OrganizationInvitationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationInvitationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationInvitationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrganizationInvitation.
func (c *OrganizationInvitationClient) Update() *OrganizationInvitationUpdate {
	mutation := newOrganizationInvitationMutation(c.config, OpUpdate)
	return &OrganizationInvitationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationInvitationClient) UpdateOne(_m *OrganizationInvitation) *OrganizationInvitationUpdateOne {
	mutation := newOrganizationInvitationMutation(c.config, OpUpdateOne, withOrganizationInvitation(_m))
	return &OrganizationInvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationInvitationClient) UpdateOneID(id int) *OrganizationInvitationUpdateOne {
	mutation := newOrganizationInvitationMutation(c.config, OpUpdateOne, withOrganizationInvitationID(id))
	return &OrganizationInvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrganizationInvitation.
func (c *OrganizationInvitationClient) Delete() *OrganizationInvitationDelete {
	mutation := newOrganizationInvitationMutation(c.config, OpDelete)
	return &OrganizationInvitationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationInvitationClient) DeleteOne(_m *OrganizationInvitation) *OrganizationInvitationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationInvitationClient) DeleteOneID(id int) *OrganizationInvitationDeleteOne {
	builder := c.Delete().Where(organizationinvitation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationInvitationDeleteOne{builder}
}

// Query returns a query builder for OrganizationInvitation.
func (c *OrganizationInvitationClient) Query() *OrganizationInvitationQuery {
	return &OrganizationInvitationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganizationInvitation},
		inters: c.Interceptors(),
	}
}

// Get returns a OrganizationInvitation entity by its id.
func (c *OrganizationInvitationClient) Get(ctx context.Context, id int) (*OrganizationInvitation, error) {
	return c.Query().Where(organizationinvitation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationInvitationClient) GetX(ctx context.Context, id int) *OrganizationInvitation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a OrganizationInvitation.
func (c *OrganizationInvitationClient) QueryOrganization(_m *OrganizationInvitation) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationinvitation.Table, organizationinvitation.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organizationinvitation.OrganizationTable, organizationinvitation.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvitedBy queries the invited_by edge of a OrganizationInvitation.
func (c *OrganizationInvitationClient) QueryInvitedBy(_m *OrganizationInvitation) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationinvitation.Table, organizationinvitation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organizationinvitation.InvitedByTable, organizationinvitation.InvitedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationInvitationClient) Hooks() []Hook {
	return c.hooks.OrganizationInvitation
}

// Interceptors returns the client interceptors.
func (c *OrganizationInvitationClient) Interceptors() []Interceptor {
	return c.inters.OrganizationInvitation
}

func (c *OrganizationInvitationClient) mutate(ctx context.Context, m *OrganizationInvitationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationInvitationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationInvitationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationInvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationInvitationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrganizationInvitation mutation op: %q", m.Op())
	}
}

// OrganizationMemberClient is a client for the OrganizationMember schema.
type OrganizationMemberClient struct {
	config
}

// NewOrganizationMemberClient returns a client for the OrganizationMember from the given config.
func NewOrganizationMemberClient(c config) *OrganizationMemberClient {
	return &OrganizationMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organizationmember.Hooks(f(g(h())))`.
func (c *OrganizationMemberClient) Use(hooks ...Hook) {
	c.hooks.OrganizationMember = append(c.hooks.OrganizationMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organizationmember.Intercept(f(g(h())))`.
func (c *OrganizationMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrganizationMember = append(c.inters.OrganizationMember, interceptors...)
}

// Create returns a builder for creating a OrganizationMember entity.
func (c *OrganizationMemberClient) Create() *OrganizationMemberCreate {
	mutation := newOrganizationMemberMutation(c.config, OpCreate)
	return &OrganizationMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrganizationMember entities.
func (c *OrganizationMemberClient) CreateBulk(builders ...*OrganizationMemberCreate) *OrganizationMemberCreateBulk {
	return &OrganizationMemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationMemberClient) MapCreateBulk(slice any, setFunc func(*OrganizationMemberCreate, int)) *OrganizationMemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationMemberCreateBulk{err: fmt.Errorf("calling to OrganizationMemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationMemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrganizationMember.
func (c *OrganizationMemberClient) Update() *OrganizationMemberUpdate {
	mutation := newOrganizationMemberMutation(c.config, OpUpdate)
	return &OrganizationMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationMemberClient) UpdateOne(_m *OrganizationMember) *OrganizationMemberUpdateOne {
	mutation := newOrganizationMemberMutation(c.config, OpUpdateOne, withOrganizationMember(_m))
	return &OrganizationMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationMemberClient) UpdateOneID(id int) *OrganizationMemberUpdateOne {
	mutation := newOrganizationMemberMutation(c.config, OpUpdateOne, withOrganizationMemberID(id))
	return &OrganizationMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrganizationMember.
func (c *OrganizationMemberClient) Delete() *OrganizationMemberDelete {
	mutation := newOrganizationMemberMutation(c.config, OpDelete)
	return &OrganizationMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationMemberClient) DeleteOne(_m *OrganizationMember) *OrganizationMemberDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationMemberClient) DeleteOneID(id int) *OrganizationMemberDeleteOne {
	builder := c.Delete().Where(organizationmember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationMemberDeleteOne{builder}
}

// Query returns a query builder for OrganizationMember.
func (c *OrganizationMemberClient) Query() *OrganizationMemberQuery {
	return &OrganizationMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganizationMember},
		inters: c.Interceptors(),
	}
}

// Get returns a OrganizationMember entity by its id.
func (c *OrganizationMemberClient) Get(ctx context.Context, id int) (*OrganizationMember, error) {
	return c.Query().Where(organizationmember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationMemberClient) GetX(ctx context.Context, id int) *OrganizationMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a OrganizationMember.
func (c *OrganizationMemberClient) QueryOrganization(_m *OrganizationMember) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationmember.Table, organizationmember.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organizationmember.OrganizationTable, organizationmember.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OrganizationMember.
func (c *OrganizationMemberClient) QueryUser(_m *OrganizationMember) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationmember.Table, organizationmember.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organizationmember.UserTable, organizationmember.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationMemberClient) Hooks() []Hook {
	return c.hooks.OrganizationMember
}

// Interceptors returns the client interceptors.
func (c *OrganizationMemberClient) Interceptors() []Interceptor {
	return c.inters.OrganizationMember
}

func (c *OrganizationMemberClient) mutate(ctx context.Context, m *OrganizationMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrganizationMember mutation op: %q", m.Op())
	}
}

// PlanClient is a client for the Plan schema.
type PlanClient struct {
	config
}

// NewPlanClient returns a client for the Plan from the given config.
func NewPlanClient(c config) *PlanClient {
	return &PlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `plan.Hooks(f(g(h())))`.
func (c *PlanClient) Use(hooks ...Hook) {
	c.hooks.Plan = append(c.hooks.Plan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `plan.Intercept(f(g(h())))`.
func (c *PlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Plan = append(c.inters.Plan, interceptors...)
}

// Create returns a builder for creating a Plan entity.
func (c *PlanClient) Create() *PlanCreate {
	mutation := newPlanMutation(c.config, OpCreate)
	return &PlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Plan entities.
func (c *PlanClient) CreateBulk(builders ...*PlanCreate) *PlanCreateBulk {
	return &PlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlanClient) MapCreateBulk(slice any, setFunc func(*PlanCreate, int)) *PlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlanCreateBulk{err: fmt.Errorf("calling to PlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Plan.
func (c *PlanClient) Update() *PlanUpdate {
	mutation := newPlanMutation(c.config, OpUpdate)
	return &PlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlanClient) UpdateOne(_m *Plan) *PlanUpdateOne {
	mutation := newPlanMutation(c.config, OpUpdateOne, withPlan(_m))
	return &PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlanClient) UpdateOneID(id int) *PlanUpdateOne {
	mutation := newPlanMutation(c.config, OpUpdateOne, withPlanID(id))
	return &PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Plan.
func (c *PlanClient) Delete() *PlanDelete {
	mutation := newPlanMutation(c.config, OpDelete)
	return &PlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlanClient) DeleteOne(_m *Plan) *PlanDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlanClient) DeleteOneID(id int) *PlanDeleteOne {
	builder := c.Delete().Where(plan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlanDeleteOne{builder}
}

// Query returns a query builder for Plan.
func (c *PlanClient) Query() *PlanQuery {
	return &PlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlan},
		inters: c.Interceptors(),
	}
}

// Get returns a Plan entity by its id.
func (c *PlanClient) Get(ctx context.Context, id int) (*Plan, error) {
	return c.Query().Where(plan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlanClient) GetX(ctx context.Context, id int) *Plan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a Plan.
func (c *PlanClient) QueryApp(_m *Plan) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, plan.AppTable, plan.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a Plan.
func (c *PlanClient) QuerySubscriptions(_m *Plan) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, plan.SubscriptionsTable, plan.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlanClient) Hooks() []Hook {
	return c.hooks.Plan
}

// Interceptors returns the client interceptors.
func (c *PlanClient) Interceptors() []Interceptor {
	return c.inters.Plan
}

func (c *PlanClient) mutate(ctx context.Context, m *PlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Plan mutation op: %q", m.Op())
	}
}

// ShenbiProfileClient is a client for the ShenbiProfile schema.
type ShenbiProfileClient struct {
	config
}

// NewShenbiProfileClient returns a client for the ShenbiProfile from the given config.
func NewShenbiProfileClient(c config) *ShenbiProfileClient {
	return &ShenbiProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `shenbiprofile.Hooks(f(g(h())))`.
func (c *ShenbiProfileClient) Use(hooks ...Hook) {
	c.hooks.ShenbiProfile = append(c.hooks.ShenbiProfile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `shenbiprofile.Intercept(f(g(h())))`.
func (c *ShenbiProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.ShenbiProfile = append(c.inters.ShenbiProfile, interceptors...)
}

// Create returns a builder for creating a ShenbiProfile entity.
func (c *ShenbiProfileClient) Create() *ShenbiProfileCreate {
	mutation := newShenbiProfileMutation(c.config, OpCreate)
	return &ShenbiProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ShenbiProfile entities.
func (c *ShenbiProfileClient) CreateBulk(builders ...*ShenbiProfileCreate) *ShenbiProfileCreateBulk {
	return &ShenbiProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ShenbiProfileClient) MapCreateBulk(slice any, setFunc func(*ShenbiProfileCreate, int)) *ShenbiProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ShenbiProfileCreateBulk{err: fmt.Errorf("calling to ShenbiProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ShenbiProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ShenbiProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ShenbiProfile.
func (c *ShenbiProfileClient) Update() *ShenbiProfileUpdate {
	mutation := newShenbiProfileMutation(c.config, OpUpdate)
	return &ShenbiProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ShenbiProfileClient) UpdateOne(_m *ShenbiProfile) *ShenbiProfileUpdateOne {
	mutation := newShenbiProfileMutation(c.config, OpUpdateOne, withShenbiProfile(_m))
	return &ShenbiProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ShenbiProfileClient) UpdateOneID(id int) *ShenbiProfileUpdateOne {
	mutation := newShenbiProfileMutation(c.config, OpUpdateOne, withShenbiProfileID(id))
	return &ShenbiProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ShenbiProfile.
func (c *ShenbiProfileClient) Delete() *ShenbiProfileDelete {
	mutation := newShenbiProfileMutation(c.config, OpDelete)
	return &ShenbiProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ShenbiProfileClient) DeleteOne(_m *ShenbiProfile) *ShenbiProfileDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ShenbiProfileClient) DeleteOneID(id int) *ShenbiProfileDeleteOne {
	builder := c.Delete().Where(shenbiprofile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ShenbiProfileDeleteOne{builder}
}

// Query returns a query builder for ShenbiProfile.
func (c *ShenbiProfileClient) Query() *ShenbiProfileQuery {
	return &ShenbiProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeShenbiProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a ShenbiProfile entity by its id.
func (c *ShenbiProfileClient) Get(ctx context.Context, id int) (*ShenbiProfile, error) {
	return c.Query().Where(shenbiprofile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ShenbiProfileClient) GetX(ctx context.Context, id int) *ShenbiProfile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a ShenbiProfile.
func (c *ShenbiProfileClient) QueryApp(_m *ShenbiProfile) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(shenbiprofile.Table, shenbiprofile.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, shenbiprofile.AppTable, shenbiprofile.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ShenbiProfile.
func (c *ShenbiProfileClient) QueryUser(_m *ShenbiProfile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(shenbiprofile.Table, shenbiprofile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, shenbiprofile.UserTable, shenbiprofile.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ShenbiProfileClient) Hooks() []Hook {
	return c.hooks.ShenbiProfile
}

// Interceptors returns the client interceptors.
func (c *ShenbiProfileClient) Interceptors() []Interceptor {
	return c.inters.ShenbiProfile
}

func (c *ShenbiProfileClient) mutate(ctx context.Context, m *ShenbiProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ShenbiProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ShenbiProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ShenbiProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ShenbiProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ShenbiProfile mutation op: %q", m.Op())
	}
}

// ShenbiSettingsClient is a client for the ShenbiSettings schema.
type ShenbiSettingsClient struct {
	config
}

// NewShenbiSettingsClient returns a client for the ShenbiSettings from the given config.
func NewShenbiSettingsClient(c config) *ShenbiSettingsClient {
	return &ShenbiSettingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `shenbisettings.Hooks(f(g(h())))`.
func (c *ShenbiSettingsClient) Use(hooks ...Hook) {
	c.hooks.ShenbiSettings = append(c.hooks.ShenbiSettings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `shenbisettings.Intercept(f(g(h())))`.
func (c *ShenbiSettingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.ShenbiSettings = append(c.inters.ShenbiSettings, interceptors...)
}

// Create returns a builder for creating a ShenbiSettings entity.
func (c *ShenbiSettingsClient) Create() *ShenbiSettingsCreate {
	mutation := newShenbiSettingsMutation(c.config, OpCreate)
	return &ShenbiSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ShenbiSettings entities.
func (c *ShenbiSettingsClient) CreateBulk(builders ...*ShenbiSettingsCreate) *ShenbiSettingsCreateBulk {
	return &ShenbiSettingsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ShenbiSettingsClient) MapCreateBulk(slice any, setFunc func(*ShenbiSettingsCreate, int)) *ShenbiSettingsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ShenbiSettingsCreateBulk{err: fmt.Errorf("calling to ShenbiSettingsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ShenbiSettingsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ShenbiSettingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ShenbiSettings.
func (c *ShenbiSettingsClient) Update() *ShenbiSettingsUpdate {
	mutation := newShenbiSettingsMutation(c.config, OpUpdate)
	return &ShenbiSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ShenbiSettingsClient) UpdateOne(_m *ShenbiSettings) *ShenbiSettingsUpdateOne {
	mutation := newShenbiSettingsMutation(c.config, OpUpdateOne, withShenbiSettings(_m))
	return &ShenbiSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ShenbiSettingsClient) UpdateOneID(id int) *ShenbiSettingsUpdateOne {
	mutation := newShenbiSettingsMutation(c.config, OpUpdateOne, withShenbiSettingsID(id))
	return &ShenbiSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ShenbiSettings.
func (c *ShenbiSettingsClient) Delete() *ShenbiSettingsDelete {
	mutation := newShenbiSettingsMutation(c.config, OpDelete)
	return &ShenbiSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ShenbiSettingsClient) DeleteOne(_m *ShenbiSettings) *ShenbiSettingsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ShenbiSettingsClient) DeleteOneID(id int) *ShenbiSettingsDeleteOne {
	builder := c.Delete().Where(shenbisettings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ShenbiSettingsDeleteOne{builder}
}

// Query returns a query builder for ShenbiSettings.
func (c *ShenbiSettingsClient) Query() *ShenbiSettingsQuery {
	return &ShenbiSettingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeShenbiSettings},
		inters: c.Interceptors(),
	}
}

// Get returns a ShenbiSettings entity by its id.
func (c *ShenbiSettingsClient) Get(ctx context.Context, id int) (*ShenbiSettings, error) {
	return c.Query().Where(shenbisettings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ShenbiSettingsClient) GetX(ctx context.Context, id int) *ShenbiSettings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a ShenbiSettings.
func (c *ShenbiSettingsClient) QueryApp(_m *ShenbiSettings) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(shenbisettings.Table, shenbisettings.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, shenbisettings.AppTable, shenbisettings.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ShenbiSettings.
func (c *ShenbiSettingsClient) QueryUser(_m *ShenbiSettings) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(shenbisettings.Table, shenbisettings.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, shenbisettings.UserTable, shenbisettings.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ShenbiSettingsClient) Hooks() []Hook {
	return c.hooks.ShenbiSettings
}

// Interceptors returns the client interceptors.
func (c *ShenbiSettingsClient) Interceptors() []Interceptor {
	return c.inters.ShenbiSettings
}

func (c *ShenbiSettingsClient) mutate(ctx context.Context, m *ShenbiSettingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ShenbiSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ShenbiSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ShenbiSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ShenbiSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ShenbiSettings mutation op: %q", m.Op())
	}
}

// SubscriptionClient is a client for the Subscription schema.
type SubscriptionClient struct {
	config
}

// NewSubscriptionClient returns a client for the Subscription from the given config.
func NewSubscriptionClient(c config) *SubscriptionClient {
	return &SubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscription.Hooks(f(g(h())))`.
func (c *SubscriptionClient) Use(hooks ...Hook) {
	c.hooks.Subscription = append(c.hooks.Subscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscription.Intercept(f(g(h())))`.
func (c *SubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subscription = append(c.inters.Subscription, interceptors...)
}

// Create returns a builder for creating a Subscription entity.
func (c *SubscriptionClient) Create() *SubscriptionCreate {
	mutation := newSubscriptionMutation(c.config, OpCreate)
	return &SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subscription entities.
func (c *SubscriptionClient) CreateBulk(builders ...*SubscriptionCreate) *SubscriptionCreateBulk {
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriptionClient) MapCreateBulk(slice any, setFunc func(*SubscriptionCreate, int)) *SubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriptionCreateBulk{err: fmt.Errorf("calling to SubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subscription.
func (c *SubscriptionClient) Update() *SubscriptionUpdate {
	mutation := newSubscriptionMutation(c.config, OpUpdate)
	return &SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriptionClient) UpdateOne(_m *Subscription) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscription(_m))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriptionClient) UpdateOneID(id int) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscriptionID(id))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subscription.
func (c *SubscriptionClient) Delete() *SubscriptionDelete {
	mutation := newSubscriptionMutation(c.config, OpDelete)
	return &SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriptionClient) DeleteOne(_m *Subscription) *SubscriptionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriptionClient) DeleteOneID(id int) *SubscriptionDeleteOne {
	builder := c.Delete().Where(subscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriptionDeleteOne{builder}
}

// Query returns a query builder for Subscription.
func (c *SubscriptionClient) Query() *SubscriptionQuery {
	return &SubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a Subscription entity by its id.
func (c *SubscriptionClient) Get(ctx context.Context, id int) (*Subscription, error) {
	return c.Query().Where(subscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriptionClient) GetX(ctx context.Context, id int) *Subscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Subscription.
func (c *SubscriptionClient) QueryUser(_m *Subscription) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscription.UserTable, subscription.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a Subscription.
func (c *SubscriptionClient) QueryOrganization(_m *Subscription) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscription.OrganizationTable, subscription.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApp queries the app edge of a Subscription.
func (c *SubscriptionClient) QueryApp(_m *Subscription) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscription.AppTable, subscription.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the plan edge of a Subscription.
func (c *SubscriptionClient) QueryPlan(_m *Subscription) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscription.PlanTable, subscription.PlanColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubscriptionClient) Hooks() []Hook {
	return c.hooks.Subscription
}

// Interceptors returns the client interceptors.
func (c *SubscriptionClient) Interceptors() []Interceptor {
	return c.inters.Subscription
}

func (c *SubscriptionClient) mutate(ctx context.Context, m *SubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Subscription mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserApps queries the user_apps edge of a User.
func (c *UserClient) QueryUserApps(_m *User) *UserAppQuery {
	query := (&UserAppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userapp.Table, userapp.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserAppsTable, user.UserAppsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizationMemberships queries the organization_memberships edge of a User.
func (c *UserClient) QueryOrganizationMemberships(_m *User) *OrganizationMemberQuery {
	query := (&OrganizationMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(organizationmember.Table, organizationmember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OrganizationMembershipsTable, user.OrganizationMembershipsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a User.
func (c *UserClient) QuerySubscriptions(_m *User) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SubscriptionsTable, user.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShenbiProfile queries the shenbi_profile edge of a User.
func (c *UserClient) QueryShenbiProfile(_m *User) *ShenbiProfileQuery {
	query := (&ShenbiProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(shenbiprofile.Table, shenbiprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.ShenbiProfileTable, user.ShenbiProfileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClassroomsTeaching queries the classrooms_teaching edge of a User.
func (c *UserClient) QueryClassroomsTeaching(_m *User) *ClassroomQuery {
	query := (&ClassroomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(classroom.Table, classroom.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ClassroomsTeachingTable, user.ClassroomsTeachingColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClassroomMemberships queries the classroom_memberships edge of a User.
func (c *UserClient) QueryClassroomMemberships(_m *User) *ClassroomMembershipQuery {
	query := (&ClassroomMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(classroommembership.Table, classroommembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ClassroomMembershipsTable, user.ClassroomMembershipsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignmentSubmissions queries the assignment_submissions edge of a User.
func (c *UserClient) QueryAssignmentSubmissions(_m *User) *AssignmentSubmissionQuery {
	query := (&AssignmentSubmissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(assignmentsubmission.Table, assignmentsubmission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AssignmentSubmissionsTable, user.AssignmentSubmissionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserProgress queries the user_progress edge of a User.
func (c *UserClient) QueryUserProgress(_m *User) *UserProgressQuery {
	query := (&UserProgressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userprogress.Table, userprogress.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserProgressTable, user.UserProgressColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAchievements queries the achievements edge of a User.
func (c *UserClient) QueryAchievements(_m *User) *AchievementQuery {
	query := (&AchievementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(achievement.Table, achievement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AchievementsTable, user.AchievementsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBattleRoomsHosted queries the battle_rooms_hosted edge of a User.
func (c *UserClient) QueryBattleRoomsHosted(_m *User) *BattleRoomQuery {
	query := (&BattleRoomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(battleroom.Table, battleroom.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BattleRoomsHostedTable, user.BattleRoomsHostedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBattleSessions queries the battle_sessions edge of a User.
func (c *UserClient) QueryBattleSessions(_m *User) *BattleSessionQuery {
	query := (&BattleSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(battlesession.Table, battlesession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BattleSessionsTable, user.BattleSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLiveSessionsTeaching queries the live_sessions_teaching edge of a User.
func (c *UserClient) QueryLiveSessionsTeaching(_m *User) *LiveSessionQuery {
	query := (&LiveSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(livesession.Table, livesession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LiveSessionsTeachingTable, user.LiveSessionsTeachingColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLiveSessionParticipations queries the live_session_participations edge of a User.
func (c *UserClient) QueryLiveSessionParticipations(_m *User) *LiveSessionStudentQuery {
	query := (&LiveSessionStudentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(livesessionstudent.Table, livesessionstudent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LiveSessionParticipationsTable, user.LiveSessionParticipationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClassroomSessions queries the classroom_sessions edge of a User.
func (c *UserClient) QueryClassroomSessions(_m *User) *ClassroomSessionQuery {
	query := (&ClassroomSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(classroomsession.Table, classroomsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ClassroomSessionsTable, user.ClassroomSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShenbiSettings queries the shenbi_settings edge of a User.
func (c *UserClient) QueryShenbiSettings(_m *User) *ShenbiSettingsQuery {
	query := (&ShenbiSettingsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(shenbisettings.Table, shenbisettings.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.ShenbiSettingsTable, user.ShenbiSettingsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySentInvitations queries the sent_invitations edge of a User.
func (c *UserClient) QuerySentInvitations(_m *User) *OrganizationInvitationQuery {
	query := (&OrganizationInvitationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(organizationinvitation.Table, organizationinvitation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SentInvitationsTable, user.SentInvitationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserAppClient is a client for the UserApp schema.
type UserAppClient struct {
	config
}

// NewUserAppClient returns a client for the UserApp from the given config.
func NewUserAppClient(c config) *UserAppClient {
	return &UserAppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userapp.Hooks(f(g(h())))`.
func (c *UserAppClient) Use(hooks ...Hook) {
	c.hooks.UserApp = append(c.hooks.UserApp, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userapp.Intercept(f(g(h())))`.
func (c *UserAppClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserApp = append(c.inters.UserApp, interceptors...)
}

// Create returns a builder for creating a UserApp entity.
func (c *UserAppClient) Create() *UserAppCreate {
	mutation := newUserAppMutation(c.config, OpCreate)
	return &UserAppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserApp entities.
func (c *UserAppClient) CreateBulk(builders ...*UserAppCreate) *UserAppCreateBulk {
	return &UserAppCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserAppClient) MapCreateBulk(slice any, setFunc func(*UserAppCreate, int)) *UserAppCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserAppCreateBulk{err: fmt.Errorf("calling to UserAppClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserAppCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserAppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserApp.
func (c *UserAppClient) Update() *UserAppUpdate {
	mutation := newUserAppMutation(c.config, OpUpdate)
	return &UserAppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserAppClient) UpdateOne(_m *UserApp) *UserAppUpdateOne {
	mutation := newUserAppMutation(c.config, OpUpdateOne, withUserApp(_m))
	return &UserAppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserAppClient) UpdateOneID(id int) *UserAppUpdateOne {
	mutation := newUserAppMutation(c.config, OpUpdateOne, withUserAppID(id))
	return &UserAppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserApp.
func (c *UserAppClient) Delete() *UserAppDelete {
	mutation := newUserAppMutation(c.config, OpDelete)
	return &UserAppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserAppClient) DeleteOne(_m *UserApp) *UserAppDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserAppClient) DeleteOneID(id int) *UserAppDeleteOne {
	builder := c.Delete().Where(userapp.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserAppDeleteOne{builder}
}

// Query returns a query builder for UserApp.
func (c *UserAppClient) Query() *UserAppQuery {
	return &UserAppQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserApp},
		inters: c.Interceptors(),
	}
}

// Get returns a UserApp entity by its id.
func (c *UserAppClient) Get(ctx context.Context, id int) (*UserApp, error) {
	return c.Query().Where(userapp.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserAppClient) GetX(ctx context.Context, id int) *UserApp {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserApp.
func (c *UserAppClient) QueryUser(_m *UserApp) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userapp.Table, userapp.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userapp.UserTable, userapp.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApp queries the app edge of a UserApp.
func (c *UserAppClient) QueryApp(_m *UserApp) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userapp.Table, userapp.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userapp.AppTable, userapp.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserAppClient) Hooks() []Hook {
	return c.hooks.UserApp
}

// Interceptors returns the client interceptors.
func (c *UserAppClient) Interceptors() []Interceptor {
	return c.inters.UserApp
}

func (c *UserAppClient) mutate(ctx context.Context, m *UserAppMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserAppCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserAppUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserAppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserAppDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserApp mutation op: %q", m.Op())
	}
}

// UserProgressClient is a client for the UserProgress schema.
type UserProgressClient struct {
	config
}

// NewUserProgressClient returns a client for the UserProgress from the given config.
func NewUserProgressClient(c config) *UserProgressClient {
	return &UserProgressClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userprogress.Hooks(f(g(h())))`.
func (c *UserProgressClient) Use(hooks ...Hook) {
	c.hooks.UserProgress = append(c.hooks.UserProgress, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userprogress.Intercept(f(g(h())))`.
func (c *UserProgressClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserProgress = append(c.inters.UserProgress, interceptors...)
}

// Create returns a builder for creating a UserProgress entity.
func (c *UserProgressClient) Create() *UserProgressCreate {
	mutation := newUserProgressMutation(c.config, OpCreate)
	return &UserProgressCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserProgress entities.
func (c *UserProgressClient) CreateBulk(builders ...*UserProgressCreate) *UserProgressCreateBulk {
	return &UserProgressCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserProgressClient) MapCreateBulk(slice any, setFunc func(*UserProgressCreate, int)) *UserProgressCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserProgressCreateBulk{err: fmt.Errorf("calling to UserProgressClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserProgressCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserProgressCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserProgress.
func (c *UserProgressClient) Update() *UserProgressUpdate {
	mutation := newUserProgressMutation(c.config, OpUpdate)
	return &UserProgressUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserProgressClient) UpdateOne(_m *UserProgress) *UserProgressUpdateOne {
	mutation := newUserProgressMutation(c.config, OpUpdateOne, withUserProgress(_m))
	return &UserProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserProgressClient) UpdateOneID(id int) *UserProgressUpdateOne {
	mutation := newUserProgressMutation(c.config, OpUpdateOne, withUserProgressID(id))
	return &UserProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserProgress.
func (c *UserProgressClient) Delete() *UserProgressDelete {
	mutation := newUserProgressMutation(c.config, OpDelete)
	return &UserProgressDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserProgressClient) DeleteOne(_m *UserProgress) *UserProgressDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserProgressClient) DeleteOneID(id int) *UserProgressDeleteOne {
	builder := c.Delete().Where(userprogress.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserProgressDeleteOne{builder}
}

// Query returns a query builder for UserProgress.
func (c *UserProgressClient) Query() *UserProgressQuery {
	return &UserProgressQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserProgress},
		inters: c.Interceptors(),
	}
}

// Get returns a UserProgress entity by its id.
func (c *UserProgressClient) Get(ctx context.Context, id int) (*UserProgress, error) {
	return c.Query().Where(userprogress.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserProgressClient) GetX(ctx context.Context, id int) *UserProgress {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a UserProgress.
func (c *UserProgressClient) QueryApp(_m *UserProgress) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userprogress.Table, userprogress.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userprogress.AppTable, userprogress.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a UserProgress.
func (c *UserProgressClient) QueryUser(_m *UserProgress) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userprogress.Table, userprogress.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userprogress.UserTable, userprogress.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserProgressClient) Hooks() []Hook {
	return c.hooks.UserProgress
}

// Interceptors returns the client interceptors.
func (c *UserProgressClient) Interceptors() []Interceptor {
	return c.inters.UserProgress
}

func (c *UserProgressClient) mutate(ctx context.Context, m *UserProgressMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserProgressCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserProgressUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserProgressDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserProgress mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Achievement, App, Assignment, AssignmentSubmission, BattleRoom, BattleSession,
		Classroom, ClassroomMembership, ClassroomSession, EmailTemplate, LiveSession,
		LiveSessionStudent, Organization, OrganizationInvitation, OrganizationMember,
		Plan, ShenbiProfile, ShenbiSettings, Subscription, User, UserApp,
		UserProgress []ent.Hook
	}
	inters struct {
		Achievement, App, Assignment, AssignmentSubmission, BattleRoom, BattleSession,
		Classroom, ClassroomMembership, ClassroomSession, EmailTemplate, LiveSession,
		LiveSessionStudent, Organization, OrganizationInvitation, OrganizationMember,
		Plan, ShenbiProfile, ShenbiSettings, Subscription, User, UserApp,
		UserProgress []ent.Interceptor
	}
)
