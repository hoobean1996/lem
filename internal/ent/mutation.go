// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"gigaboo.io/lem/internal/ent/achievement"
	"gigaboo.io/lem/internal/ent/app"
	"gigaboo.io/lem/internal/ent/assignment"
	"gigaboo.io/lem/internal/ent/assignmentsubmission"
	"gigaboo.io/lem/internal/ent/battleroom"
	"gigaboo.io/lem/internal/ent/battlesession"
	"gigaboo.io/lem/internal/ent/classroom"
	"gigaboo.io/lem/internal/ent/classroommembership"
	"gigaboo.io/lem/internal/ent/classroomsession"
	"gigaboo.io/lem/internal/ent/emailtemplate"
	"gigaboo.io/lem/internal/ent/livesession"
	"gigaboo.io/lem/internal/ent/livesessionstudent"
	"gigaboo.io/lem/internal/ent/organization"
	"gigaboo.io/lem/internal/ent/organizationinvitation"
	"gigaboo.io/lem/internal/ent/organizationmember"
	"gigaboo.io/lem/internal/ent/plan"
	"gigaboo.io/lem/internal/ent/predicate"
	"gigaboo.io/lem/internal/ent/shenbiprofile"
	"gigaboo.io/lem/internal/ent/shenbisettings"
	"gigaboo.io/lem/internal/ent/subscription"
	"gigaboo.io/lem/internal/ent/user"
	"gigaboo.io/lem/internal/ent/userapp"
	"gigaboo.io/lem/internal/ent/userprogress"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAchievement            = "Achievement"
	TypeApp                    = "App"
	TypeAssignment             = "Assignment"
	TypeAssignmentSubmission   = "AssignmentSubmission"
	TypeBattleRoom             = "BattleRoom"
	TypeBattleSession          = "BattleSession"
	TypeClassroom              = "Classroom"
	TypeClassroomMembership    = "ClassroomMembership"
	TypeClassroomSession       = "ClassroomSession"
	TypeEmailTemplate          = "EmailTemplate"
	TypeLiveSession            = "LiveSession"
	TypeLiveSessionStudent     = "LiveSessionStudent"
	TypeOrganization           = "Organization"
	TypeOrganizationInvitation = "OrganizationInvitation"
	TypeOrganizationMember     = "OrganizationMember"
	TypePlan                   = "Plan"
	TypeShenbiProfile          = "ShenbiProfile"
	TypeShenbiSettings         = "ShenbiSettings"
	TypeSubscription           = "Subscription"
	TypeUser                   = "User"
	TypeUserApp                = "UserApp"
	TypeUserProgress           = "UserProgress"
)

// AchievementMutation represents an operation that mutates the Achievement nodes in the graph.
type AchievementMutation struct {
	config
	op             Op
	typ            string
	id             *int
	achievement_id *string
	earned_at      *time.Time
	clearedFields  map[string]struct{}
	app            *int
	clearedapp     bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Achievement, error)
	predicates     []predicate.Achievement
}

var _ ent.Mutation = (*AchievementMutation)(nil)

// achievementOption allows management of the mutation configuration using functional options.
type achievementOption func(*AchievementMutation)

// newAchievementMutation creates new mutation for the Achievement entity.
func newAchievementMutation(c config, op Op, opts ...achievementOption) *AchievementMutation {
	m := &AchievementMutation{
		config:        c,
		op:            op,
		typ:           TypeAchievement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAchievementID sets the ID field of the mutation.
func withAchievementID(id int) achievementOption {
	return func(m *AchievementMutation) {
		var (
			err   error
			once  sync.Once
			value *Achievement
		)
		m.oldValue = func(ctx context.Context) (*Achievement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Achievement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAchievement sets the old Achievement of the mutation.
func withAchievement(node *Achievement) achievementOption {
	return func(m *AchievementMutation) {
		m.oldValue = func(context.Context) (*Achievement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AchievementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AchievementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AchievementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AchievementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Achievement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAchievementID sets the "achievement_id" field.
func (m *AchievementMutation) SetAchievementID(s string) {
	m.achievement_id = &s
}

// AchievementID returns the value of the "achievement_id" field in the mutation.
func (m *AchievementMutation) AchievementID() (r string, exists bool) {
	v := m.achievement_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAchievementID returns the old "achievement_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldAchievementID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAchievementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAchievementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAchievementID: %w", err)
	}
	return oldValue.AchievementID, nil
}

// ResetAchievementID resets all changes to the "achievement_id" field.
func (m *AchievementMutation) ResetAchievementID() {
	m.achievement_id = nil
}

// SetEarnedAt sets the "earned_at" field.
func (m *AchievementMutation) SetEarnedAt(t time.Time) {
	m.earned_at = &t
}

// EarnedAt returns the value of the "earned_at" field in the mutation.
func (m *AchievementMutation) EarnedAt() (r time.Time, exists bool) {
	v := m.earned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEarnedAt returns the old "earned_at" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldEarnedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEarnedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEarnedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarnedAt: %w", err)
	}
	return oldValue.EarnedAt, nil
}

// ResetEarnedAt resets all changes to the "earned_at" field.
func (m *AchievementMutation) ResetEarnedAt() {
	m.earned_at = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *AchievementMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *AchievementMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AchievementMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *AchievementMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AchievementMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AchievementMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AchievementMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AchievementMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AchievementMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AchievementMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AchievementMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AchievementMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AchievementMutation builder.
func (m *AchievementMutation) Where(ps ...predicate.Achievement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AchievementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AchievementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Achievement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AchievementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AchievementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Achievement).
func (m *AchievementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AchievementMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.achievement_id != nil {
		fields = append(fields, achievement.FieldAchievementID)
	}
	if m.earned_at != nil {
		fields = append(fields, achievement.FieldEarnedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AchievementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case achievement.FieldAchievementID:
		return m.AchievementID()
	case achievement.FieldEarnedAt:
		return m.EarnedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AchievementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case achievement.FieldAchievementID:
		return m.OldAchievementID(ctx)
	case achievement.FieldEarnedAt:
		return m.OldEarnedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Achievement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AchievementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case achievement.FieldAchievementID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAchievementID(v)
		return nil
	case achievement.FieldEarnedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarnedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Achievement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AchievementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AchievementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AchievementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Achievement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AchievementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AchievementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AchievementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Achievement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AchievementMutation) ResetField(name string) error {
	switch name {
	case achievement.FieldAchievementID:
		m.ResetAchievementID()
		return nil
	case achievement.FieldEarnedAt:
		m.ResetEarnedAt()
		return nil
	}
	return fmt.Errorf("unknown Achievement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AchievementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, achievement.EdgeApp)
	}
	if m.user != nil {
		edges = append(edges, achievement.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AchievementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case achievement.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case achievement.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AchievementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AchievementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AchievementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, achievement.EdgeApp)
	}
	if m.cleareduser {
		edges = append(edges, achievement.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AchievementMutation) EdgeCleared(name string) bool {
	switch name {
	case achievement.EdgeApp:
		return m.clearedapp
	case achievement.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AchievementMutation) ClearEdge(name string) error {
	switch name {
	case achievement.EdgeApp:
		m.ClearApp()
		return nil
	case achievement.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Achievement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AchievementMutation) ResetEdge(name string) error {
	switch name {
	case achievement.EdgeApp:
		m.ResetApp()
		return nil
	case achievement.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Achievement edge %s", name)
}

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	slug                      *string
	api_key                   *string
	api_secret                *string
	allowed_origins           *[]string
	appendallowed_origins     []string
	webhook_url               *string
	stripe_product_id         *string
	is_active                 *bool
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	user_apps                 map[int]struct{}
	removeduser_apps          map[int]struct{}
	cleareduser_apps          bool
	organizations             map[int]struct{}
	removedorganizations      map[int]struct{}
	clearedorganizations      bool
	plans                     map[int]struct{}
	removedplans              map[int]struct{}
	clearedplans              bool
	subscriptions             map[int]struct{}
	removedsubscriptions      map[int]struct{}
	clearedsubscriptions      bool
	email_templates           map[int]struct{}
	removedemail_templates    map[int]struct{}
	clearedemail_templates    bool
	shenbi_profiles           map[int]struct{}
	removedshenbi_profiles    map[int]struct{}
	clearedshenbi_profiles    bool
	classrooms                map[int]struct{}
	removedclassrooms         map[int]struct{}
	clearedclassrooms         bool
	user_progress             map[int]struct{}
	removeduser_progress      map[int]struct{}
	cleareduser_progress      bool
	achievements              map[int]struct{}
	removedachievements       map[int]struct{}
	clearedachievements       bool
	battle_rooms              map[int]struct{}
	removedbattle_rooms       map[int]struct{}
	clearedbattle_rooms       bool
	battle_sessions           map[int]struct{}
	removedbattle_sessions    map[int]struct{}
	clearedbattle_sessions    bool
	live_sessions             map[int]struct{}
	removedlive_sessions      map[int]struct{}
	clearedlive_sessions      bool
	classroom_sessions        map[int]struct{}
	removedclassroom_sessions map[int]struct{}
	clearedclassroom_sessions bool
	shenbi_settings           map[int]struct{}
	removedshenbi_settings    map[int]struct{}
	clearedshenbi_settings    bool
	done                      bool
	oldValue                  func(context.Context) (*App, error)
	predicates                []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id int) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *AppMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *AppMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *AppMutation) ResetSlug() {
	m.slug = nil
}

// SetAPIKey sets the "api_key" field.
func (m *AppMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *AppMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *AppMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetAPISecret sets the "api_secret" field.
func (m *AppMutation) SetAPISecret(s string) {
	m.api_secret = &s
}

// APISecret returns the value of the "api_secret" field in the mutation.
func (m *AppMutation) APISecret() (r string, exists bool) {
	v := m.api_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldAPISecret returns the old "api_secret" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAPISecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPISecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPISecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPISecret: %w", err)
	}
	return oldValue.APISecret, nil
}

// ClearAPISecret clears the value of the "api_secret" field.
func (m *AppMutation) ClearAPISecret() {
	m.api_secret = nil
	m.clearedFields[app.FieldAPISecret] = struct{}{}
}

// APISecretCleared returns if the "api_secret" field was cleared in this mutation.
func (m *AppMutation) APISecretCleared() bool {
	_, ok := m.clearedFields[app.FieldAPISecret]
	return ok
}

// ResetAPISecret resets all changes to the "api_secret" field.
func (m *AppMutation) ResetAPISecret() {
	m.api_secret = nil
	delete(m.clearedFields, app.FieldAPISecret)
}

// SetAllowedOrigins sets the "allowed_origins" field.
func (m *AppMutation) SetAllowedOrigins(s []string) {
	m.allowed_origins = &s
	m.appendallowed_origins = nil
}

// AllowedOrigins returns the value of the "allowed_origins" field in the mutation.
func (m *AppMutation) AllowedOrigins() (r []string, exists bool) {
	v := m.allowed_origins
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedOrigins returns the old "allowed_origins" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAllowedOrigins(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedOrigins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedOrigins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedOrigins: %w", err)
	}
	return oldValue.AllowedOrigins, nil
}

// AppendAllowedOrigins adds s to the "allowed_origins" field.
func (m *AppMutation) AppendAllowedOrigins(s []string) {
	m.appendallowed_origins = append(m.appendallowed_origins, s...)
}

// AppendedAllowedOrigins returns the list of values that were appended to the "allowed_origins" field in this mutation.
func (m *AppMutation) AppendedAllowedOrigins() ([]string, bool) {
	if len(m.appendallowed_origins) == 0 {
		return nil, false
	}
	return m.appendallowed_origins, true
}

// ClearAllowedOrigins clears the value of the "allowed_origins" field.
func (m *AppMutation) ClearAllowedOrigins() {
	m.allowed_origins = nil
	m.appendallowed_origins = nil
	m.clearedFields[app.FieldAllowedOrigins] = struct{}{}
}

// AllowedOriginsCleared returns if the "allowed_origins" field was cleared in this mutation.
func (m *AppMutation) AllowedOriginsCleared() bool {
	_, ok := m.clearedFields[app.FieldAllowedOrigins]
	return ok
}

// ResetAllowedOrigins resets all changes to the "allowed_origins" field.
func (m *AppMutation) ResetAllowedOrigins() {
	m.allowed_origins = nil
	m.appendallowed_origins = nil
	delete(m.clearedFields, app.FieldAllowedOrigins)
}

// SetWebhookURL sets the "webhook_url" field.
func (m *AppMutation) SetWebhookURL(s string) {
	m.webhook_url = &s
}

// WebhookURL returns the value of the "webhook_url" field in the mutation.
func (m *AppMutation) WebhookURL() (r string, exists bool) {
	v := m.webhook_url
	if v == nil {
		return
	}
	return *v, true
}

// OldWebhookURL returns the old "webhook_url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldWebhookURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebhookURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebhookURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebhookURL: %w", err)
	}
	return oldValue.WebhookURL, nil
}

// ClearWebhookURL clears the value of the "webhook_url" field.
func (m *AppMutation) ClearWebhookURL() {
	m.webhook_url = nil
	m.clearedFields[app.FieldWebhookURL] = struct{}{}
}

// WebhookURLCleared returns if the "webhook_url" field was cleared in this mutation.
func (m *AppMutation) WebhookURLCleared() bool {
	_, ok := m.clearedFields[app.FieldWebhookURL]
	return ok
}

// ResetWebhookURL resets all changes to the "webhook_url" field.
func (m *AppMutation) ResetWebhookURL() {
	m.webhook_url = nil
	delete(m.clearedFields, app.FieldWebhookURL)
}

// SetStripeProductID sets the "stripe_product_id" field.
func (m *AppMutation) SetStripeProductID(s string) {
	m.stripe_product_id = &s
}

// StripeProductID returns the value of the "stripe_product_id" field in the mutation.
func (m *AppMutation) StripeProductID() (r string, exists bool) {
	v := m.stripe_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeProductID returns the old "stripe_product_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldStripeProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeProductID: %w", err)
	}
	return oldValue.StripeProductID, nil
}

// ClearStripeProductID clears the value of the "stripe_product_id" field.
func (m *AppMutation) ClearStripeProductID() {
	m.stripe_product_id = nil
	m.clearedFields[app.FieldStripeProductID] = struct{}{}
}

// StripeProductIDCleared returns if the "stripe_product_id" field was cleared in this mutation.
func (m *AppMutation) StripeProductIDCleared() bool {
	_, ok := m.clearedFields[app.FieldStripeProductID]
	return ok
}

// ResetStripeProductID resets all changes to the "stripe_product_id" field.
func (m *AppMutation) ResetStripeProductID() {
	m.stripe_product_id = nil
	delete(m.clearedFields, app.FieldStripeProductID)
}

// SetIsActive sets the "is_active" field.
func (m *AppMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *AppMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *AppMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUserAppIDs adds the "user_apps" edge to the UserApp entity by ids.
func (m *AppMutation) AddUserAppIDs(ids ...int) {
	if m.user_apps == nil {
		m.user_apps = make(map[int]struct{})
	}
	for i := range ids {
		m.user_apps[ids[i]] = struct{}{}
	}
}

// ClearUserApps clears the "user_apps" edge to the UserApp entity.
func (m *AppMutation) ClearUserApps() {
	m.cleareduser_apps = true
}

// UserAppsCleared reports if the "user_apps" edge to the UserApp entity was cleared.
func (m *AppMutation) UserAppsCleared() bool {
	return m.cleareduser_apps
}

// RemoveUserAppIDs removes the "user_apps" edge to the UserApp entity by IDs.
func (m *AppMutation) RemoveUserAppIDs(ids ...int) {
	if m.removeduser_apps == nil {
		m.removeduser_apps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_apps, ids[i])
		m.removeduser_apps[ids[i]] = struct{}{}
	}
}

// RemovedUserApps returns the removed IDs of the "user_apps" edge to the UserApp entity.
func (m *AppMutation) RemovedUserAppsIDs() (ids []int) {
	for id := range m.removeduser_apps {
		ids = append(ids, id)
	}
	return
}

// UserAppsIDs returns the "user_apps" edge IDs in the mutation.
func (m *AppMutation) UserAppsIDs() (ids []int) {
	for id := range m.user_apps {
		ids = append(ids, id)
	}
	return
}

// ResetUserApps resets all changes to the "user_apps" edge.
func (m *AppMutation) ResetUserApps() {
	m.user_apps = nil
	m.cleareduser_apps = false
	m.removeduser_apps = nil
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *AppMutation) AddOrganizationIDs(ids ...int) {
	if m.organizations == nil {
		m.organizations = make(map[int]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *AppMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *AppMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *AppMutation) RemoveOrganizationIDs(ids ...int) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *AppMutation) RemovedOrganizationsIDs() (ids []int) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *AppMutation) OrganizationsIDs() (ids []int) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *AppMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// AddPlanIDs adds the "plans" edge to the Plan entity by ids.
func (m *AppMutation) AddPlanIDs(ids ...int) {
	if m.plans == nil {
		m.plans = make(map[int]struct{})
	}
	for i := range ids {
		m.plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "plans" edge to the Plan entity.
func (m *AppMutation) ClearPlans() {
	m.clearedplans = true
}

// PlansCleared reports if the "plans" edge to the Plan entity was cleared.
func (m *AppMutation) PlansCleared() bool {
	return m.clearedplans
}

// RemovePlanIDs removes the "plans" edge to the Plan entity by IDs.
func (m *AppMutation) RemovePlanIDs(ids ...int) {
	if m.removedplans == nil {
		m.removedplans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.plans, ids[i])
		m.removedplans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "plans" edge to the Plan entity.
func (m *AppMutation) RemovedPlansIDs() (ids []int) {
	for id := range m.removedplans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "plans" edge IDs in the mutation.
func (m *AppMutation) PlansIDs() (ids []int) {
	for id := range m.plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "plans" edge.
func (m *AppMutation) ResetPlans() {
	m.plans = nil
	m.clearedplans = false
	m.removedplans = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *AppMutation) AddSubscriptionIDs(ids ...int) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *AppMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *AppMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *AppMutation) RemoveSubscriptionIDs(ids ...int) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *AppMutation) RemovedSubscriptionsIDs() (ids []int) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *AppMutation) SubscriptionsIDs() (ids []int) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *AppMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddEmailTemplateIDs adds the "email_templates" edge to the EmailTemplate entity by ids.
func (m *AppMutation) AddEmailTemplateIDs(ids ...int) {
	if m.email_templates == nil {
		m.email_templates = make(map[int]struct{})
	}
	for i := range ids {
		m.email_templates[ids[i]] = struct{}{}
	}
}

// ClearEmailTemplates clears the "email_templates" edge to the EmailTemplate entity.
func (m *AppMutation) ClearEmailTemplates() {
	m.clearedemail_templates = true
}

// EmailTemplatesCleared reports if the "email_templates" edge to the EmailTemplate entity was cleared.
func (m *AppMutation) EmailTemplatesCleared() bool {
	return m.clearedemail_templates
}

// RemoveEmailTemplateIDs removes the "email_templates" edge to the EmailTemplate entity by IDs.
func (m *AppMutation) RemoveEmailTemplateIDs(ids ...int) {
	if m.removedemail_templates == nil {
		m.removedemail_templates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.email_templates, ids[i])
		m.removedemail_templates[ids[i]] = struct{}{}
	}
}

// RemovedEmailTemplates returns the removed IDs of the "email_templates" edge to the EmailTemplate entity.
func (m *AppMutation) RemovedEmailTemplatesIDs() (ids []int) {
	for id := range m.removedemail_templates {
		ids = append(ids, id)
	}
	return
}

// EmailTemplatesIDs returns the "email_templates" edge IDs in the mutation.
func (m *AppMutation) EmailTemplatesIDs() (ids []int) {
	for id := range m.email_templates {
		ids = append(ids, id)
	}
	return
}

// ResetEmailTemplates resets all changes to the "email_templates" edge.
func (m *AppMutation) ResetEmailTemplates() {
	m.email_templates = nil
	m.clearedemail_templates = false
	m.removedemail_templates = nil
}

// AddShenbiProfileIDs adds the "shenbi_profiles" edge to the ShenbiProfile entity by ids.
func (m *AppMutation) AddShenbiProfileIDs(ids ...int) {
	if m.shenbi_profiles == nil {
		m.shenbi_profiles = make(map[int]struct{})
	}
	for i := range ids {
		m.shenbi_profiles[ids[i]] = struct{}{}
	}
}

// ClearShenbiProfiles clears the "shenbi_profiles" edge to the ShenbiProfile entity.
func (m *AppMutation) ClearShenbiProfiles() {
	m.clearedshenbi_profiles = true
}

// ShenbiProfilesCleared reports if the "shenbi_profiles" edge to the ShenbiProfile entity was cleared.
func (m *AppMutation) ShenbiProfilesCleared() bool {
	return m.clearedshenbi_profiles
}

// RemoveShenbiProfileIDs removes the "shenbi_profiles" edge to the ShenbiProfile entity by IDs.
func (m *AppMutation) RemoveShenbiProfileIDs(ids ...int) {
	if m.removedshenbi_profiles == nil {
		m.removedshenbi_profiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.shenbi_profiles, ids[i])
		m.removedshenbi_profiles[ids[i]] = struct{}{}
	}
}

// RemovedShenbiProfiles returns the removed IDs of the "shenbi_profiles" edge to the ShenbiProfile entity.
func (m *AppMutation) RemovedShenbiProfilesIDs() (ids []int) {
	for id := range m.removedshenbi_profiles {
		ids = append(ids, id)
	}
	return
}

// ShenbiProfilesIDs returns the "shenbi_profiles" edge IDs in the mutation.
func (m *AppMutation) ShenbiProfilesIDs() (ids []int) {
	for id := range m.shenbi_profiles {
		ids = append(ids, id)
	}
	return
}

// ResetShenbiProfiles resets all changes to the "shenbi_profiles" edge.
func (m *AppMutation) ResetShenbiProfiles() {
	m.shenbi_profiles = nil
	m.clearedshenbi_profiles = false
	m.removedshenbi_profiles = nil
}

// AddClassroomIDs adds the "classrooms" edge to the Classroom entity by ids.
func (m *AppMutation) AddClassroomIDs(ids ...int) {
	if m.classrooms == nil {
		m.classrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.classrooms[ids[i]] = struct{}{}
	}
}

// ClearClassrooms clears the "classrooms" edge to the Classroom entity.
func (m *AppMutation) ClearClassrooms() {
	m.clearedclassrooms = true
}

// ClassroomsCleared reports if the "classrooms" edge to the Classroom entity was cleared.
func (m *AppMutation) ClassroomsCleared() bool {
	return m.clearedclassrooms
}

// RemoveClassroomIDs removes the "classrooms" edge to the Classroom entity by IDs.
func (m *AppMutation) RemoveClassroomIDs(ids ...int) {
	if m.removedclassrooms == nil {
		m.removedclassrooms = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.classrooms, ids[i])
		m.removedclassrooms[ids[i]] = struct{}{}
	}
}

// RemovedClassrooms returns the removed IDs of the "classrooms" edge to the Classroom entity.
func (m *AppMutation) RemovedClassroomsIDs() (ids []int) {
	for id := range m.removedclassrooms {
		ids = append(ids, id)
	}
	return
}

// ClassroomsIDs returns the "classrooms" edge IDs in the mutation.
func (m *AppMutation) ClassroomsIDs() (ids []int) {
	for id := range m.classrooms {
		ids = append(ids, id)
	}
	return
}

// ResetClassrooms resets all changes to the "classrooms" edge.
func (m *AppMutation) ResetClassrooms() {
	m.classrooms = nil
	m.clearedclassrooms = false
	m.removedclassrooms = nil
}

// AddUserProgresIDs adds the "user_progress" edge to the UserProgress entity by ids.
func (m *AppMutation) AddUserProgresIDs(ids ...int) {
	if m.user_progress == nil {
		m.user_progress = make(map[int]struct{})
	}
	for i := range ids {
		m.user_progress[ids[i]] = struct{}{}
	}
}

// ClearUserProgress clears the "user_progress" edge to the UserProgress entity.
func (m *AppMutation) ClearUserProgress() {
	m.cleareduser_progress = true
}

// UserProgressCleared reports if the "user_progress" edge to the UserProgress entity was cleared.
func (m *AppMutation) UserProgressCleared() bool {
	return m.cleareduser_progress
}

// RemoveUserProgresIDs removes the "user_progress" edge to the UserProgress entity by IDs.
func (m *AppMutation) RemoveUserProgresIDs(ids ...int) {
	if m.removeduser_progress == nil {
		m.removeduser_progress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_progress, ids[i])
		m.removeduser_progress[ids[i]] = struct{}{}
	}
}

// RemovedUserProgress returns the removed IDs of the "user_progress" edge to the UserProgress entity.
func (m *AppMutation) RemovedUserProgressIDs() (ids []int) {
	for id := range m.removeduser_progress {
		ids = append(ids, id)
	}
	return
}

// UserProgressIDs returns the "user_progress" edge IDs in the mutation.
func (m *AppMutation) UserProgressIDs() (ids []int) {
	for id := range m.user_progress {
		ids = append(ids, id)
	}
	return
}

// ResetUserProgress resets all changes to the "user_progress" edge.
func (m *AppMutation) ResetUserProgress() {
	m.user_progress = nil
	m.cleareduser_progress = false
	m.removeduser_progress = nil
}

// AddAchievementIDs adds the "achievements" edge to the Achievement entity by ids.
func (m *AppMutation) AddAchievementIDs(ids ...int) {
	if m.achievements == nil {
		m.achievements = make(map[int]struct{})
	}
	for i := range ids {
		m.achievements[ids[i]] = struct{}{}
	}
}

// ClearAchievements clears the "achievements" edge to the Achievement entity.
func (m *AppMutation) ClearAchievements() {
	m.clearedachievements = true
}

// AchievementsCleared reports if the "achievements" edge to the Achievement entity was cleared.
func (m *AppMutation) AchievementsCleared() bool {
	return m.clearedachievements
}

// RemoveAchievementIDs removes the "achievements" edge to the Achievement entity by IDs.
func (m *AppMutation) RemoveAchievementIDs(ids ...int) {
	if m.removedachievements == nil {
		m.removedachievements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.achievements, ids[i])
		m.removedachievements[ids[i]] = struct{}{}
	}
}

// RemovedAchievements returns the removed IDs of the "achievements" edge to the Achievement entity.
func (m *AppMutation) RemovedAchievementsIDs() (ids []int) {
	for id := range m.removedachievements {
		ids = append(ids, id)
	}
	return
}

// AchievementsIDs returns the "achievements" edge IDs in the mutation.
func (m *AppMutation) AchievementsIDs() (ids []int) {
	for id := range m.achievements {
		ids = append(ids, id)
	}
	return
}

// ResetAchievements resets all changes to the "achievements" edge.
func (m *AppMutation) ResetAchievements() {
	m.achievements = nil
	m.clearedachievements = false
	m.removedachievements = nil
}

// AddBattleRoomIDs adds the "battle_rooms" edge to the BattleRoom entity by ids.
func (m *AppMutation) AddBattleRoomIDs(ids ...int) {
	if m.battle_rooms == nil {
		m.battle_rooms = make(map[int]struct{})
	}
	for i := range ids {
		m.battle_rooms[ids[i]] = struct{}{}
	}
}

// ClearBattleRooms clears the "battle_rooms" edge to the BattleRoom entity.
func (m *AppMutation) ClearBattleRooms() {
	m.clearedbattle_rooms = true
}

// BattleRoomsCleared reports if the "battle_rooms" edge to the BattleRoom entity was cleared.
func (m *AppMutation) BattleRoomsCleared() bool {
	return m.clearedbattle_rooms
}

// RemoveBattleRoomIDs removes the "battle_rooms" edge to the BattleRoom entity by IDs.
func (m *AppMutation) RemoveBattleRoomIDs(ids ...int) {
	if m.removedbattle_rooms == nil {
		m.removedbattle_rooms = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.battle_rooms, ids[i])
		m.removedbattle_rooms[ids[i]] = struct{}{}
	}
}

// RemovedBattleRooms returns the removed IDs of the "battle_rooms" edge to the BattleRoom entity.
func (m *AppMutation) RemovedBattleRoomsIDs() (ids []int) {
	for id := range m.removedbattle_rooms {
		ids = append(ids, id)
	}
	return
}

// BattleRoomsIDs returns the "battle_rooms" edge IDs in the mutation.
func (m *AppMutation) BattleRoomsIDs() (ids []int) {
	for id := range m.battle_rooms {
		ids = append(ids, id)
	}
	return
}

// ResetBattleRooms resets all changes to the "battle_rooms" edge.
func (m *AppMutation) ResetBattleRooms() {
	m.battle_rooms = nil
	m.clearedbattle_rooms = false
	m.removedbattle_rooms = nil
}

// AddBattleSessionIDs adds the "battle_sessions" edge to the BattleSession entity by ids.
func (m *AppMutation) AddBattleSessionIDs(ids ...int) {
	if m.battle_sessions == nil {
		m.battle_sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.battle_sessions[ids[i]] = struct{}{}
	}
}

// ClearBattleSessions clears the "battle_sessions" edge to the BattleSession entity.
func (m *AppMutation) ClearBattleSessions() {
	m.clearedbattle_sessions = true
}

// BattleSessionsCleared reports if the "battle_sessions" edge to the BattleSession entity was cleared.
func (m *AppMutation) BattleSessionsCleared() bool {
	return m.clearedbattle_sessions
}

// RemoveBattleSessionIDs removes the "battle_sessions" edge to the BattleSession entity by IDs.
func (m *AppMutation) RemoveBattleSessionIDs(ids ...int) {
	if m.removedbattle_sessions == nil {
		m.removedbattle_sessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.battle_sessions, ids[i])
		m.removedbattle_sessions[ids[i]] = struct{}{}
	}
}

// RemovedBattleSessions returns the removed IDs of the "battle_sessions" edge to the BattleSession entity.
func (m *AppMutation) RemovedBattleSessionsIDs() (ids []int) {
	for id := range m.removedbattle_sessions {
		ids = append(ids, id)
	}
	return
}

// BattleSessionsIDs returns the "battle_sessions" edge IDs in the mutation.
func (m *AppMutation) BattleSessionsIDs() (ids []int) {
	for id := range m.battle_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetBattleSessions resets all changes to the "battle_sessions" edge.
func (m *AppMutation) ResetBattleSessions() {
	m.battle_sessions = nil
	m.clearedbattle_sessions = false
	m.removedbattle_sessions = nil
}

// AddLiveSessionIDs adds the "live_sessions" edge to the LiveSession entity by ids.
func (m *AppMutation) AddLiveSessionIDs(ids ...int) {
	if m.live_sessions == nil {
		m.live_sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.live_sessions[ids[i]] = struct{}{}
	}
}

// ClearLiveSessions clears the "live_sessions" edge to the LiveSession entity.
func (m *AppMutation) ClearLiveSessions() {
	m.clearedlive_sessions = true
}

// LiveSessionsCleared reports if the "live_sessions" edge to the LiveSession entity was cleared.
func (m *AppMutation) LiveSessionsCleared() bool {
	return m.clearedlive_sessions
}

// RemoveLiveSessionIDs removes the "live_sessions" edge to the LiveSession entity by IDs.
func (m *AppMutation) RemoveLiveSessionIDs(ids ...int) {
	if m.removedlive_sessions == nil {
		m.removedlive_sessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.live_sessions, ids[i])
		m.removedlive_sessions[ids[i]] = struct{}{}
	}
}

// RemovedLiveSessions returns the removed IDs of the "live_sessions" edge to the LiveSession entity.
func (m *AppMutation) RemovedLiveSessionsIDs() (ids []int) {
	for id := range m.removedlive_sessions {
		ids = append(ids, id)
	}
	return
}

// LiveSessionsIDs returns the "live_sessions" edge IDs in the mutation.
func (m *AppMutation) LiveSessionsIDs() (ids []int) {
	for id := range m.live_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetLiveSessions resets all changes to the "live_sessions" edge.
func (m *AppMutation) ResetLiveSessions() {
	m.live_sessions = nil
	m.clearedlive_sessions = false
	m.removedlive_sessions = nil
}

// AddClassroomSessionIDs adds the "classroom_sessions" edge to the ClassroomSession entity by ids.
func (m *AppMutation) AddClassroomSessionIDs(ids ...int) {
	if m.classroom_sessions == nil {
		m.classroom_sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.classroom_sessions[ids[i]] = struct{}{}
	}
}

// ClearClassroomSessions clears the "classroom_sessions" edge to the ClassroomSession entity.
func (m *AppMutation) ClearClassroomSessions() {
	m.clearedclassroom_sessions = true
}

// ClassroomSessionsCleared reports if the "classroom_sessions" edge to the ClassroomSession entity was cleared.
func (m *AppMutation) ClassroomSessionsCleared() bool {
	return m.clearedclassroom_sessions
}

// RemoveClassroomSessionIDs removes the "classroom_sessions" edge to the ClassroomSession entity by IDs.
func (m *AppMutation) RemoveClassroomSessionIDs(ids ...int) {
	if m.removedclassroom_sessions == nil {
		m.removedclassroom_sessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.classroom_sessions, ids[i])
		m.removedclassroom_sessions[ids[i]] = struct{}{}
	}
}

// RemovedClassroomSessions returns the removed IDs of the "classroom_sessions" edge to the ClassroomSession entity.
func (m *AppMutation) RemovedClassroomSessionsIDs() (ids []int) {
	for id := range m.removedclassroom_sessions {
		ids = append(ids, id)
	}
	return
}

// ClassroomSessionsIDs returns the "classroom_sessions" edge IDs in the mutation.
func (m *AppMutation) ClassroomSessionsIDs() (ids []int) {
	for id := range m.classroom_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetClassroomSessions resets all changes to the "classroom_sessions" edge.
func (m *AppMutation) ResetClassroomSessions() {
	m.classroom_sessions = nil
	m.clearedclassroom_sessions = false
	m.removedclassroom_sessions = nil
}

// AddShenbiSettingIDs adds the "shenbi_settings" edge to the ShenbiSettings entity by ids.
func (m *AppMutation) AddShenbiSettingIDs(ids ...int) {
	if m.shenbi_settings == nil {
		m.shenbi_settings = make(map[int]struct{})
	}
	for i := range ids {
		m.shenbi_settings[ids[i]] = struct{}{}
	}
}

// ClearShenbiSettings clears the "shenbi_settings" edge to the ShenbiSettings entity.
func (m *AppMutation) ClearShenbiSettings() {
	m.clearedshenbi_settings = true
}

// ShenbiSettingsCleared reports if the "shenbi_settings" edge to the ShenbiSettings entity was cleared.
func (m *AppMutation) ShenbiSettingsCleared() bool {
	return m.clearedshenbi_settings
}

// RemoveShenbiSettingIDs removes the "shenbi_settings" edge to the ShenbiSettings entity by IDs.
func (m *AppMutation) RemoveShenbiSettingIDs(ids ...int) {
	if m.removedshenbi_settings == nil {
		m.removedshenbi_settings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.shenbi_settings, ids[i])
		m.removedshenbi_settings[ids[i]] = struct{}{}
	}
}

// RemovedShenbiSettings returns the removed IDs of the "shenbi_settings" edge to the ShenbiSettings entity.
func (m *AppMutation) RemovedShenbiSettingsIDs() (ids []int) {
	for id := range m.removedshenbi_settings {
		ids = append(ids, id)
	}
	return
}

// ShenbiSettingsIDs returns the "shenbi_settings" edge IDs in the mutation.
func (m *AppMutation) ShenbiSettingsIDs() (ids []int) {
	for id := range m.shenbi_settings {
		ids = append(ids, id)
	}
	return
}

// ResetShenbiSettings resets all changes to the "shenbi_settings" edge.
func (m *AppMutation) ResetShenbiSettings() {
	m.shenbi_settings = nil
	m.clearedshenbi_settings = false
	m.removedshenbi_settings = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, app.FieldSlug)
	}
	if m.api_key != nil {
		fields = append(fields, app.FieldAPIKey)
	}
	if m.api_secret != nil {
		fields = append(fields, app.FieldAPISecret)
	}
	if m.allowed_origins != nil {
		fields = append(fields, app.FieldAllowedOrigins)
	}
	if m.webhook_url != nil {
		fields = append(fields, app.FieldWebhookURL)
	}
	if m.stripe_product_id != nil {
		fields = append(fields, app.FieldStripeProductID)
	}
	if m.is_active != nil {
		fields = append(fields, app.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldName:
		return m.Name()
	case app.FieldSlug:
		return m.Slug()
	case app.FieldAPIKey:
		return m.APIKey()
	case app.FieldAPISecret:
		return m.APISecret()
	case app.FieldAllowedOrigins:
		return m.AllowedOrigins()
	case app.FieldWebhookURL:
		return m.WebhookURL()
	case app.FieldStripeProductID:
		return m.StripeProductID()
	case app.FieldIsActive:
		return m.IsActive()
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldSlug:
		return m.OldSlug(ctx)
	case app.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case app.FieldAPISecret:
		return m.OldAPISecret(ctx)
	case app.FieldAllowedOrigins:
		return m.OldAllowedOrigins(ctx)
	case app.FieldWebhookURL:
		return m.OldWebhookURL(ctx)
	case app.FieldStripeProductID:
		return m.OldStripeProductID(ctx)
	case app.FieldIsActive:
		return m.OldIsActive(ctx)
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case app.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case app.FieldAPISecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPISecret(v)
		return nil
	case app.FieldAllowedOrigins:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedOrigins(v)
		return nil
	case app.FieldWebhookURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebhookURL(v)
		return nil
	case app.FieldStripeProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeProductID(v)
		return nil
	case app.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldAPISecret) {
		fields = append(fields, app.FieldAPISecret)
	}
	if m.FieldCleared(app.FieldAllowedOrigins) {
		fields = append(fields, app.FieldAllowedOrigins)
	}
	if m.FieldCleared(app.FieldWebhookURL) {
		fields = append(fields, app.FieldWebhookURL)
	}
	if m.FieldCleared(app.FieldStripeProductID) {
		fields = append(fields, app.FieldStripeProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldAPISecret:
		m.ClearAPISecret()
		return nil
	case app.FieldAllowedOrigins:
		m.ClearAllowedOrigins()
		return nil
	case app.FieldWebhookURL:
		m.ClearWebhookURL()
		return nil
	case app.FieldStripeProductID:
		m.ClearStripeProductID()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldSlug:
		m.ResetSlug()
		return nil
	case app.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case app.FieldAPISecret:
		m.ResetAPISecret()
		return nil
	case app.FieldAllowedOrigins:
		m.ResetAllowedOrigins()
		return nil
	case app.FieldWebhookURL:
		m.ResetWebhookURL()
		return nil
	case app.FieldStripeProductID:
		m.ResetStripeProductID()
		return nil
	case app.FieldIsActive:
		m.ResetIsActive()
		return nil
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.user_apps != nil {
		edges = append(edges, app.EdgeUserApps)
	}
	if m.organizations != nil {
		edges = append(edges, app.EdgeOrganizations)
	}
	if m.plans != nil {
		edges = append(edges, app.EdgePlans)
	}
	if m.subscriptions != nil {
		edges = append(edges, app.EdgeSubscriptions)
	}
	if m.email_templates != nil {
		edges = append(edges, app.EdgeEmailTemplates)
	}
	if m.shenbi_profiles != nil {
		edges = append(edges, app.EdgeShenbiProfiles)
	}
	if m.classrooms != nil {
		edges = append(edges, app.EdgeClassrooms)
	}
	if m.user_progress != nil {
		edges = append(edges, app.EdgeUserProgress)
	}
	if m.achievements != nil {
		edges = append(edges, app.EdgeAchievements)
	}
	if m.battle_rooms != nil {
		edges = append(edges, app.EdgeBattleRooms)
	}
	if m.battle_sessions != nil {
		edges = append(edges, app.EdgeBattleSessions)
	}
	if m.live_sessions != nil {
		edges = append(edges, app.EdgeLiveSessions)
	}
	if m.classroom_sessions != nil {
		edges = append(edges, app.EdgeClassroomSessions)
	}
	if m.shenbi_settings != nil {
		edges = append(edges, app.EdgeShenbiSettings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeUserApps:
		ids := make([]ent.Value, 0, len(m.user_apps))
		for id := range m.user_apps {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePlans:
		ids := make([]ent.Value, 0, len(m.plans))
		for id := range m.plans {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeEmailTemplates:
		ids := make([]ent.Value, 0, len(m.email_templates))
		for id := range m.email_templates {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeShenbiProfiles:
		ids := make([]ent.Value, 0, len(m.shenbi_profiles))
		for id := range m.shenbi_profiles {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeClassrooms:
		ids := make([]ent.Value, 0, len(m.classrooms))
		for id := range m.classrooms {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeUserProgress:
		ids := make([]ent.Value, 0, len(m.user_progress))
		for id := range m.user_progress {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAchievements:
		ids := make([]ent.Value, 0, len(m.achievements))
		for id := range m.achievements {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBattleRooms:
		ids := make([]ent.Value, 0, len(m.battle_rooms))
		for id := range m.battle_rooms {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBattleSessions:
		ids := make([]ent.Value, 0, len(m.battle_sessions))
		for id := range m.battle_sessions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeLiveSessions:
		ids := make([]ent.Value, 0, len(m.live_sessions))
		for id := range m.live_sessions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeClassroomSessions:
		ids := make([]ent.Value, 0, len(m.classroom_sessions))
		for id := range m.classroom_sessions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeShenbiSettings:
		ids := make([]ent.Value, 0, len(m.shenbi_settings))
		for id := range m.shenbi_settings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removeduser_apps != nil {
		edges = append(edges, app.EdgeUserApps)
	}
	if m.removedorganizations != nil {
		edges = append(edges, app.EdgeOrganizations)
	}
	if m.removedplans != nil {
		edges = append(edges, app.EdgePlans)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, app.EdgeSubscriptions)
	}
	if m.removedemail_templates != nil {
		edges = append(edges, app.EdgeEmailTemplates)
	}
	if m.removedshenbi_profiles != nil {
		edges = append(edges, app.EdgeShenbiProfiles)
	}
	if m.removedclassrooms != nil {
		edges = append(edges, app.EdgeClassrooms)
	}
	if m.removeduser_progress != nil {
		edges = append(edges, app.EdgeUserProgress)
	}
	if m.removedachievements != nil {
		edges = append(edges, app.EdgeAchievements)
	}
	if m.removedbattle_rooms != nil {
		edges = append(edges, app.EdgeBattleRooms)
	}
	if m.removedbattle_sessions != nil {
		edges = append(edges, app.EdgeBattleSessions)
	}
	if m.removedlive_sessions != nil {
		edges = append(edges, app.EdgeLiveSessions)
	}
	if m.removedclassroom_sessions != nil {
		edges = append(edges, app.EdgeClassroomSessions)
	}
	if m.removedshenbi_settings != nil {
		edges = append(edges, app.EdgeShenbiSettings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeUserApps:
		ids := make([]ent.Value, 0, len(m.removeduser_apps))
		for id := range m.removeduser_apps {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removedplans))
		for id := range m.removedplans {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeEmailTemplates:
		ids := make([]ent.Value, 0, len(m.removedemail_templates))
		for id := range m.removedemail_templates {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeShenbiProfiles:
		ids := make([]ent.Value, 0, len(m.removedshenbi_profiles))
		for id := range m.removedshenbi_profiles {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeClassrooms:
		ids := make([]ent.Value, 0, len(m.removedclassrooms))
		for id := range m.removedclassrooms {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeUserProgress:
		ids := make([]ent.Value, 0, len(m.removeduser_progress))
		for id := range m.removeduser_progress {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAchievements:
		ids := make([]ent.Value, 0, len(m.removedachievements))
		for id := range m.removedachievements {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBattleRooms:
		ids := make([]ent.Value, 0, len(m.removedbattle_rooms))
		for id := range m.removedbattle_rooms {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBattleSessions:
		ids := make([]ent.Value, 0, len(m.removedbattle_sessions))
		for id := range m.removedbattle_sessions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeLiveSessions:
		ids := make([]ent.Value, 0, len(m.removedlive_sessions))
		for id := range m.removedlive_sessions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeClassroomSessions:
		ids := make([]ent.Value, 0, len(m.removedclassroom_sessions))
		for id := range m.removedclassroom_sessions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeShenbiSettings:
		ids := make([]ent.Value, 0, len(m.removedshenbi_settings))
		for id := range m.removedshenbi_settings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.cleareduser_apps {
		edges = append(edges, app.EdgeUserApps)
	}
	if m.clearedorganizations {
		edges = append(edges, app.EdgeOrganizations)
	}
	if m.clearedplans {
		edges = append(edges, app.EdgePlans)
	}
	if m.clearedsubscriptions {
		edges = append(edges, app.EdgeSubscriptions)
	}
	if m.clearedemail_templates {
		edges = append(edges, app.EdgeEmailTemplates)
	}
	if m.clearedshenbi_profiles {
		edges = append(edges, app.EdgeShenbiProfiles)
	}
	if m.clearedclassrooms {
		edges = append(edges, app.EdgeClassrooms)
	}
	if m.cleareduser_progress {
		edges = append(edges, app.EdgeUserProgress)
	}
	if m.clearedachievements {
		edges = append(edges, app.EdgeAchievements)
	}
	if m.clearedbattle_rooms {
		edges = append(edges, app.EdgeBattleRooms)
	}
	if m.clearedbattle_sessions {
		edges = append(edges, app.EdgeBattleSessions)
	}
	if m.clearedlive_sessions {
		edges = append(edges, app.EdgeLiveSessions)
	}
	if m.clearedclassroom_sessions {
		edges = append(edges, app.EdgeClassroomSessions)
	}
	if m.clearedshenbi_settings {
		edges = append(edges, app.EdgeShenbiSettings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeUserApps:
		return m.cleareduser_apps
	case app.EdgeOrganizations:
		return m.clearedorganizations
	case app.EdgePlans:
		return m.clearedplans
	case app.EdgeSubscriptions:
		return m.clearedsubscriptions
	case app.EdgeEmailTemplates:
		return m.clearedemail_templates
	case app.EdgeShenbiProfiles:
		return m.clearedshenbi_profiles
	case app.EdgeClassrooms:
		return m.clearedclassrooms
	case app.EdgeUserProgress:
		return m.cleareduser_progress
	case app.EdgeAchievements:
		return m.clearedachievements
	case app.EdgeBattleRooms:
		return m.clearedbattle_rooms
	case app.EdgeBattleSessions:
		return m.clearedbattle_sessions
	case app.EdgeLiveSessions:
		return m.clearedlive_sessions
	case app.EdgeClassroomSessions:
		return m.clearedclassroom_sessions
	case app.EdgeShenbiSettings:
		return m.clearedshenbi_settings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeUserApps:
		m.ResetUserApps()
		return nil
	case app.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	case app.EdgePlans:
		m.ResetPlans()
		return nil
	case app.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case app.EdgeEmailTemplates:
		m.ResetEmailTemplates()
		return nil
	case app.EdgeShenbiProfiles:
		m.ResetShenbiProfiles()
		return nil
	case app.EdgeClassrooms:
		m.ResetClassrooms()
		return nil
	case app.EdgeUserProgress:
		m.ResetUserProgress()
		return nil
	case app.EdgeAchievements:
		m.ResetAchievements()
		return nil
	case app.EdgeBattleRooms:
		m.ResetBattleRooms()
		return nil
	case app.EdgeBattleSessions:
		m.ResetBattleSessions()
		return nil
	case app.EdgeLiveSessions:
		m.ResetLiveSessions()
		return nil
	case app.EdgeClassroomSessions:
		m.ResetClassroomSessions()
		return nil
	case app.EdgeShenbiSettings:
		m.ResetShenbiSettings()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AssignmentMutation represents an operation that mutates the Assignment nodes in the graph.
type AssignmentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	title              *string
	description        *string
	level_ids          *[]string
	appendlevel_ids    []string
	max_points         *int
	addmax_points      *int
	due_date           *time.Time
	status             *assignment.Status
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	classroom          *int
	clearedclassroom   bool
	submissions        map[int]struct{}
	removedsubmissions map[int]struct{}
	clearedsubmissions bool
	done               bool
	oldValue           func(context.Context) (*Assignment, error)
	predicates         []predicate.Assignment
}

var _ ent.Mutation = (*AssignmentMutation)(nil)

// assignmentOption allows management of the mutation configuration using functional options.
type assignmentOption func(*AssignmentMutation)

// newAssignmentMutation creates new mutation for the Assignment entity.
func newAssignmentMutation(c config, op Op, opts ...assignmentOption) *AssignmentMutation {
	m := &AssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssignmentID sets the ID field of the mutation.
func withAssignmentID(id int) assignmentOption {
	return func(m *AssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Assignment
		)
		m.oldValue = func(ctx context.Context) (*Assignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Assignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssignment sets the old Assignment of the mutation.
func withAssignment(node *Assignment) assignmentOption {
	return func(m *AssignmentMutation) {
		m.oldValue = func(context.Context) (*Assignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssignmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Assignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *AssignmentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AssignmentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AssignmentMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *AssignmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AssignmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AssignmentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[assignment.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AssignmentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[assignment.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AssignmentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, assignment.FieldDescription)
}

// SetLevelIds sets the "level_ids" field.
func (m *AssignmentMutation) SetLevelIds(s []string) {
	m.level_ids = &s
	m.appendlevel_ids = nil
}

// LevelIds returns the value of the "level_ids" field in the mutation.
func (m *AssignmentMutation) LevelIds() (r []string, exists bool) {
	v := m.level_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelIds returns the old "level_ids" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldLevelIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelIds: %w", err)
	}
	return oldValue.LevelIds, nil
}

// AppendLevelIds adds s to the "level_ids" field.
func (m *AssignmentMutation) AppendLevelIds(s []string) {
	m.appendlevel_ids = append(m.appendlevel_ids, s...)
}

// AppendedLevelIds returns the list of values that were appended to the "level_ids" field in this mutation.
func (m *AssignmentMutation) AppendedLevelIds() ([]string, bool) {
	if len(m.appendlevel_ids) == 0 {
		return nil, false
	}
	return m.appendlevel_ids, true
}

// ClearLevelIds clears the value of the "level_ids" field.
func (m *AssignmentMutation) ClearLevelIds() {
	m.level_ids = nil
	m.appendlevel_ids = nil
	m.clearedFields[assignment.FieldLevelIds] = struct{}{}
}

// LevelIdsCleared returns if the "level_ids" field was cleared in this mutation.
func (m *AssignmentMutation) LevelIdsCleared() bool {
	_, ok := m.clearedFields[assignment.FieldLevelIds]
	return ok
}

// ResetLevelIds resets all changes to the "level_ids" field.
func (m *AssignmentMutation) ResetLevelIds() {
	m.level_ids = nil
	m.appendlevel_ids = nil
	delete(m.clearedFields, assignment.FieldLevelIds)
}

// SetMaxPoints sets the "max_points" field.
func (m *AssignmentMutation) SetMaxPoints(i int) {
	m.max_points = &i
	m.addmax_points = nil
}

// MaxPoints returns the value of the "max_points" field in the mutation.
func (m *AssignmentMutation) MaxPoints() (r int, exists bool) {
	v := m.max_points
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxPoints returns the old "max_points" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldMaxPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxPoints: %w", err)
	}
	return oldValue.MaxPoints, nil
}

// AddMaxPoints adds i to the "max_points" field.
func (m *AssignmentMutation) AddMaxPoints(i int) {
	if m.addmax_points != nil {
		*m.addmax_points += i
	} else {
		m.addmax_points = &i
	}
}

// AddedMaxPoints returns the value that was added to the "max_points" field in this mutation.
func (m *AssignmentMutation) AddedMaxPoints() (r int, exists bool) {
	v := m.addmax_points
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxPoints resets all changes to the "max_points" field.
func (m *AssignmentMutation) ResetMaxPoints() {
	m.max_points = nil
	m.addmax_points = nil
}

// SetDueDate sets the "due_date" field.
func (m *AssignmentMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *AssignmentMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldDueDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *AssignmentMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[assignment.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *AssignmentMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[assignment.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *AssignmentMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, assignment.FieldDueDate)
}

// SetStatus sets the "status" field.
func (m *AssignmentMutation) SetStatus(a assignment.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AssignmentMutation) Status() (r assignment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldStatus(ctx context.Context) (v assignment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AssignmentMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AssignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClassroomID sets the "classroom" edge to the Classroom entity by id.
func (m *AssignmentMutation) SetClassroomID(id int) {
	m.classroom = &id
}

// ClearClassroom clears the "classroom" edge to the Classroom entity.
func (m *AssignmentMutation) ClearClassroom() {
	m.clearedclassroom = true
}

// ClassroomCleared reports if the "classroom" edge to the Classroom entity was cleared.
func (m *AssignmentMutation) ClassroomCleared() bool {
	return m.clearedclassroom
}

// ClassroomID returns the "classroom" edge ID in the mutation.
func (m *AssignmentMutation) ClassroomID() (id int, exists bool) {
	if m.classroom != nil {
		return *m.classroom, true
	}
	return
}

// ClassroomIDs returns the "classroom" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassroomID instead. It exists only for internal usage by the builders.
func (m *AssignmentMutation) ClassroomIDs() (ids []int) {
	if id := m.classroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassroom resets all changes to the "classroom" edge.
func (m *AssignmentMutation) ResetClassroom() {
	m.classroom = nil
	m.clearedclassroom = false
}

// AddSubmissionIDs adds the "submissions" edge to the AssignmentSubmission entity by ids.
func (m *AssignmentMutation) AddSubmissionIDs(ids ...int) {
	if m.submissions == nil {
		m.submissions = make(map[int]struct{})
	}
	for i := range ids {
		m.submissions[ids[i]] = struct{}{}
	}
}

// ClearSubmissions clears the "submissions" edge to the AssignmentSubmission entity.
func (m *AssignmentMutation) ClearSubmissions() {
	m.clearedsubmissions = true
}

// SubmissionsCleared reports if the "submissions" edge to the AssignmentSubmission entity was cleared.
func (m *AssignmentMutation) SubmissionsCleared() bool {
	return m.clearedsubmissions
}

// RemoveSubmissionIDs removes the "submissions" edge to the AssignmentSubmission entity by IDs.
func (m *AssignmentMutation) RemoveSubmissionIDs(ids ...int) {
	if m.removedsubmissions == nil {
		m.removedsubmissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.submissions, ids[i])
		m.removedsubmissions[ids[i]] = struct{}{}
	}
}

// RemovedSubmissions returns the removed IDs of the "submissions" edge to the AssignmentSubmission entity.
func (m *AssignmentMutation) RemovedSubmissionsIDs() (ids []int) {
	for id := range m.removedsubmissions {
		ids = append(ids, id)
	}
	return
}

// SubmissionsIDs returns the "submissions" edge IDs in the mutation.
func (m *AssignmentMutation) SubmissionsIDs() (ids []int) {
	for id := range m.submissions {
		ids = append(ids, id)
	}
	return
}

// ResetSubmissions resets all changes to the "submissions" edge.
func (m *AssignmentMutation) ResetSubmissions() {
	m.submissions = nil
	m.clearedsubmissions = false
	m.removedsubmissions = nil
}

// Where appends a list predicates to the AssignmentMutation builder.
func (m *AssignmentMutation) Where(ps ...predicate.Assignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Assignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Assignment).
func (m *AssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssignmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.title != nil {
		fields = append(fields, assignment.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, assignment.FieldDescription)
	}
	if m.level_ids != nil {
		fields = append(fields, assignment.FieldLevelIds)
	}
	if m.max_points != nil {
		fields = append(fields, assignment.FieldMaxPoints)
	}
	if m.due_date != nil {
		fields = append(fields, assignment.FieldDueDate)
	}
	if m.status != nil {
		fields = append(fields, assignment.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, assignment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assignment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assignment.FieldTitle:
		return m.Title()
	case assignment.FieldDescription:
		return m.Description()
	case assignment.FieldLevelIds:
		return m.LevelIds()
	case assignment.FieldMaxPoints:
		return m.MaxPoints()
	case assignment.FieldDueDate:
		return m.DueDate()
	case assignment.FieldStatus:
		return m.Status()
	case assignment.FieldCreatedAt:
		return m.CreatedAt()
	case assignment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assignment.FieldTitle:
		return m.OldTitle(ctx)
	case assignment.FieldDescription:
		return m.OldDescription(ctx)
	case assignment.FieldLevelIds:
		return m.OldLevelIds(ctx)
	case assignment.FieldMaxPoints:
		return m.OldMaxPoints(ctx)
	case assignment.FieldDueDate:
		return m.OldDueDate(ctx)
	case assignment.FieldStatus:
		return m.OldStatus(ctx)
	case assignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Assignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assignment.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case assignment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case assignment.FieldLevelIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelIds(v)
		return nil
	case assignment.FieldMaxPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxPoints(v)
		return nil
	case assignment.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case assignment.FieldStatus:
		v, ok := value.(assignment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case assignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Assignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssignmentMutation) AddedFields() []string {
	var fields []string
	if m.addmax_points != nil {
		fields = append(fields, assignment.FieldMaxPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case assignment.FieldMaxPoints:
		return m.AddedMaxPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case assignment.FieldMaxPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Assignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assignment.FieldDescription) {
		fields = append(fields, assignment.FieldDescription)
	}
	if m.FieldCleared(assignment.FieldLevelIds) {
		fields = append(fields, assignment.FieldLevelIds)
	}
	if m.FieldCleared(assignment.FieldDueDate) {
		fields = append(fields, assignment.FieldDueDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssignmentMutation) ClearField(name string) error {
	switch name {
	case assignment.FieldDescription:
		m.ClearDescription()
		return nil
	case assignment.FieldLevelIds:
		m.ClearLevelIds()
		return nil
	case assignment.FieldDueDate:
		m.ClearDueDate()
		return nil
	}
	return fmt.Errorf("unknown Assignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssignmentMutation) ResetField(name string) error {
	switch name {
	case assignment.FieldTitle:
		m.ResetTitle()
		return nil
	case assignment.FieldDescription:
		m.ResetDescription()
		return nil
	case assignment.FieldLevelIds:
		m.ResetLevelIds()
		return nil
	case assignment.FieldMaxPoints:
		m.ResetMaxPoints()
		return nil
	case assignment.FieldDueDate:
		m.ResetDueDate()
		return nil
	case assignment.FieldStatus:
		m.ResetStatus()
		return nil
	case assignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Assignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.classroom != nil {
		edges = append(edges, assignment.EdgeClassroom)
	}
	if m.submissions != nil {
		edges = append(edges, assignment.EdgeSubmissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assignment.EdgeClassroom:
		if id := m.classroom; id != nil {
			return []ent.Value{*id}
		}
	case assignment.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.submissions))
		for id := range m.submissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsubmissions != nil {
		edges = append(edges, assignment.EdgeSubmissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssignmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case assignment.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.removedsubmissions))
		for id := range m.removedsubmissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclassroom {
		edges = append(edges, assignment.EdgeClassroom)
	}
	if m.clearedsubmissions {
		edges = append(edges, assignment.EdgeSubmissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case assignment.EdgeClassroom:
		return m.clearedclassroom
	case assignment.EdgeSubmissions:
		return m.clearedsubmissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssignmentMutation) ClearEdge(name string) error {
	switch name {
	case assignment.EdgeClassroom:
		m.ClearClassroom()
		return nil
	}
	return fmt.Errorf("unknown Assignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssignmentMutation) ResetEdge(name string) error {
	switch name {
	case assignment.EdgeClassroom:
		m.ResetClassroom()
		return nil
	case assignment.EdgeSubmissions:
		m.ResetSubmissions()
		return nil
	}
	return fmt.Errorf("unknown Assignment edge %s", name)
}

// AssignmentSubmissionMutation represents an operation that mutates the AssignmentSubmission nodes in the graph.
type AssignmentSubmissionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	levels_completed    *int
	addlevels_completed *int
	total_levels        *int
	addtotal_levels     *int
	total_stars         *int
	addtotal_stars      *int
	grade_percentage    *float64
	addgrade_percentage *float64
	manual_grade        *float64
	addmanual_grade     *float64
	teacher_notes       *string
	submitted_at        *time.Time
	graded_at           *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	assignment          *int
	clearedassignment   bool
	student             *int
	clearedstudent      bool
	done                bool
	oldValue            func(context.Context) (*AssignmentSubmission, error)
	predicates          []predicate.AssignmentSubmission
}

var _ ent.Mutation = (*AssignmentSubmissionMutation)(nil)

// assignmentsubmissionOption allows management of the mutation configuration using functional options.
type assignmentsubmissionOption func(*AssignmentSubmissionMutation)

// newAssignmentSubmissionMutation creates new mutation for the AssignmentSubmission entity.
func newAssignmentSubmissionMutation(c config, op Op, opts ...assignmentsubmissionOption) *AssignmentSubmissionMutation {
	m := &AssignmentSubmissionMutation{
		config:        c,
		op:            op,
		typ:           TypeAssignmentSubmission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssignmentSubmissionID sets the ID field of the mutation.
func withAssignmentSubmissionID(id int) assignmentsubmissionOption {
	return func(m *AssignmentSubmissionMutation) {
		var (
			err   error
			once  sync.Once
			value *AssignmentSubmission
		)
		m.oldValue = func(ctx context.Context) (*AssignmentSubmission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssignmentSubmission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssignmentSubmission sets the old AssignmentSubmission of the mutation.
func withAssignmentSubmission(node *AssignmentSubmission) assignmentsubmissionOption {
	return func(m *AssignmentSubmissionMutation) {
		m.oldValue = func(context.Context) (*AssignmentSubmission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssignmentSubmissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssignmentSubmissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssignmentSubmissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssignmentSubmissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssignmentSubmission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLevelsCompleted sets the "levels_completed" field.
func (m *AssignmentSubmissionMutation) SetLevelsCompleted(i int) {
	m.levels_completed = &i
	m.addlevels_completed = nil
}

// LevelsCompleted returns the value of the "levels_completed" field in the mutation.
func (m *AssignmentSubmissionMutation) LevelsCompleted() (r int, exists bool) {
	v := m.levels_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelsCompleted returns the old "levels_completed" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldLevelsCompleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelsCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelsCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelsCompleted: %w", err)
	}
	return oldValue.LevelsCompleted, nil
}

// AddLevelsCompleted adds i to the "levels_completed" field.
func (m *AssignmentSubmissionMutation) AddLevelsCompleted(i int) {
	if m.addlevels_completed != nil {
		*m.addlevels_completed += i
	} else {
		m.addlevels_completed = &i
	}
}

// AddedLevelsCompleted returns the value that was added to the "levels_completed" field in this mutation.
func (m *AssignmentSubmissionMutation) AddedLevelsCompleted() (r int, exists bool) {
	v := m.addlevels_completed
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevelsCompleted resets all changes to the "levels_completed" field.
func (m *AssignmentSubmissionMutation) ResetLevelsCompleted() {
	m.levels_completed = nil
	m.addlevels_completed = nil
}

// SetTotalLevels sets the "total_levels" field.
func (m *AssignmentSubmissionMutation) SetTotalLevels(i int) {
	m.total_levels = &i
	m.addtotal_levels = nil
}

// TotalLevels returns the value of the "total_levels" field in the mutation.
func (m *AssignmentSubmissionMutation) TotalLevels() (r int, exists bool) {
	v := m.total_levels
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalLevels returns the old "total_levels" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldTotalLevels(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalLevels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalLevels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalLevels: %w", err)
	}
	return oldValue.TotalLevels, nil
}

// AddTotalLevels adds i to the "total_levels" field.
func (m *AssignmentSubmissionMutation) AddTotalLevels(i int) {
	if m.addtotal_levels != nil {
		*m.addtotal_levels += i
	} else {
		m.addtotal_levels = &i
	}
}

// AddedTotalLevels returns the value that was added to the "total_levels" field in this mutation.
func (m *AssignmentSubmissionMutation) AddedTotalLevels() (r int, exists bool) {
	v := m.addtotal_levels
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalLevels resets all changes to the "total_levels" field.
func (m *AssignmentSubmissionMutation) ResetTotalLevels() {
	m.total_levels = nil
	m.addtotal_levels = nil
}

// SetTotalStars sets the "total_stars" field.
func (m *AssignmentSubmissionMutation) SetTotalStars(i int) {
	m.total_stars = &i
	m.addtotal_stars = nil
}

// TotalStars returns the value of the "total_stars" field in the mutation.
func (m *AssignmentSubmissionMutation) TotalStars() (r int, exists bool) {
	v := m.total_stars
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalStars returns the old "total_stars" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldTotalStars(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalStars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalStars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalStars: %w", err)
	}
	return oldValue.TotalStars, nil
}

// AddTotalStars adds i to the "total_stars" field.
func (m *AssignmentSubmissionMutation) AddTotalStars(i int) {
	if m.addtotal_stars != nil {
		*m.addtotal_stars += i
	} else {
		m.addtotal_stars = &i
	}
}

// AddedTotalStars returns the value that was added to the "total_stars" field in this mutation.
func (m *AssignmentSubmissionMutation) AddedTotalStars() (r int, exists bool) {
	v := m.addtotal_stars
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalStars resets all changes to the "total_stars" field.
func (m *AssignmentSubmissionMutation) ResetTotalStars() {
	m.total_stars = nil
	m.addtotal_stars = nil
}

// SetGradePercentage sets the "grade_percentage" field.
func (m *AssignmentSubmissionMutation) SetGradePercentage(f float64) {
	m.grade_percentage = &f
	m.addgrade_percentage = nil
}

// GradePercentage returns the value of the "grade_percentage" field in the mutation.
func (m *AssignmentSubmissionMutation) GradePercentage() (r float64, exists bool) {
	v := m.grade_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGradePercentage returns the old "grade_percentage" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldGradePercentage(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGradePercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGradePercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGradePercentage: %w", err)
	}
	return oldValue.GradePercentage, nil
}

// AddGradePercentage adds f to the "grade_percentage" field.
func (m *AssignmentSubmissionMutation) AddGradePercentage(f float64) {
	if m.addgrade_percentage != nil {
		*m.addgrade_percentage += f
	} else {
		m.addgrade_percentage = &f
	}
}

// AddedGradePercentage returns the value that was added to the "grade_percentage" field in this mutation.
func (m *AssignmentSubmissionMutation) AddedGradePercentage() (r float64, exists bool) {
	v := m.addgrade_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ClearGradePercentage clears the value of the "grade_percentage" field.
func (m *AssignmentSubmissionMutation) ClearGradePercentage() {
	m.grade_percentage = nil
	m.addgrade_percentage = nil
	m.clearedFields[assignmentsubmission.FieldGradePercentage] = struct{}{}
}

// GradePercentageCleared returns if the "grade_percentage" field was cleared in this mutation.
func (m *AssignmentSubmissionMutation) GradePercentageCleared() bool {
	_, ok := m.clearedFields[assignmentsubmission.FieldGradePercentage]
	return ok
}

// ResetGradePercentage resets all changes to the "grade_percentage" field.
func (m *AssignmentSubmissionMutation) ResetGradePercentage() {
	m.grade_percentage = nil
	m.addgrade_percentage = nil
	delete(m.clearedFields, assignmentsubmission.FieldGradePercentage)
}

// SetManualGrade sets the "manual_grade" field.
func (m *AssignmentSubmissionMutation) SetManualGrade(f float64) {
	m.manual_grade = &f
	m.addmanual_grade = nil
}

// ManualGrade returns the value of the "manual_grade" field in the mutation.
func (m *AssignmentSubmissionMutation) ManualGrade() (r float64, exists bool) {
	v := m.manual_grade
	if v == nil {
		return
	}
	return *v, true
}

// OldManualGrade returns the old "manual_grade" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldManualGrade(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManualGrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManualGrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManualGrade: %w", err)
	}
	return oldValue.ManualGrade, nil
}

// AddManualGrade adds f to the "manual_grade" field.
func (m *AssignmentSubmissionMutation) AddManualGrade(f float64) {
	if m.addmanual_grade != nil {
		*m.addmanual_grade += f
	} else {
		m.addmanual_grade = &f
	}
}

// AddedManualGrade returns the value that was added to the "manual_grade" field in this mutation.
func (m *AssignmentSubmissionMutation) AddedManualGrade() (r float64, exists bool) {
	v := m.addmanual_grade
	if v == nil {
		return
	}
	return *v, true
}

// ClearManualGrade clears the value of the "manual_grade" field.
func (m *AssignmentSubmissionMutation) ClearManualGrade() {
	m.manual_grade = nil
	m.addmanual_grade = nil
	m.clearedFields[assignmentsubmission.FieldManualGrade] = struct{}{}
}

// ManualGradeCleared returns if the "manual_grade" field was cleared in this mutation.
func (m *AssignmentSubmissionMutation) ManualGradeCleared() bool {
	_, ok := m.clearedFields[assignmentsubmission.FieldManualGrade]
	return ok
}

// ResetManualGrade resets all changes to the "manual_grade" field.
func (m *AssignmentSubmissionMutation) ResetManualGrade() {
	m.manual_grade = nil
	m.addmanual_grade = nil
	delete(m.clearedFields, assignmentsubmission.FieldManualGrade)
}

// SetTeacherNotes sets the "teacher_notes" field.
func (m *AssignmentSubmissionMutation) SetTeacherNotes(s string) {
	m.teacher_notes = &s
}

// TeacherNotes returns the value of the "teacher_notes" field in the mutation.
func (m *AssignmentSubmissionMutation) TeacherNotes() (r string, exists bool) {
	v := m.teacher_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherNotes returns the old "teacher_notes" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldTeacherNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeacherNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeacherNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherNotes: %w", err)
	}
	return oldValue.TeacherNotes, nil
}

// ClearTeacherNotes clears the value of the "teacher_notes" field.
func (m *AssignmentSubmissionMutation) ClearTeacherNotes() {
	m.teacher_notes = nil
	m.clearedFields[assignmentsubmission.FieldTeacherNotes] = struct{}{}
}

// TeacherNotesCleared returns if the "teacher_notes" field was cleared in this mutation.
func (m *AssignmentSubmissionMutation) TeacherNotesCleared() bool {
	_, ok := m.clearedFields[assignmentsubmission.FieldTeacherNotes]
	return ok
}

// ResetTeacherNotes resets all changes to the "teacher_notes" field.
func (m *AssignmentSubmissionMutation) ResetTeacherNotes() {
	m.teacher_notes = nil
	delete(m.clearedFields, assignmentsubmission.FieldTeacherNotes)
}

// SetSubmittedAt sets the "submitted_at" field.
func (m *AssignmentSubmissionMutation) SetSubmittedAt(t time.Time) {
	m.submitted_at = &t
}

// SubmittedAt returns the value of the "submitted_at" field in the mutation.
func (m *AssignmentSubmissionMutation) SubmittedAt() (r time.Time, exists bool) {
	v := m.submitted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmittedAt returns the old "submitted_at" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldSubmittedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmittedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmittedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmittedAt: %w", err)
	}
	return oldValue.SubmittedAt, nil
}

// ClearSubmittedAt clears the value of the "submitted_at" field.
func (m *AssignmentSubmissionMutation) ClearSubmittedAt() {
	m.submitted_at = nil
	m.clearedFields[assignmentsubmission.FieldSubmittedAt] = struct{}{}
}

// SubmittedAtCleared returns if the "submitted_at" field was cleared in this mutation.
func (m *AssignmentSubmissionMutation) SubmittedAtCleared() bool {
	_, ok := m.clearedFields[assignmentsubmission.FieldSubmittedAt]
	return ok
}

// ResetSubmittedAt resets all changes to the "submitted_at" field.
func (m *AssignmentSubmissionMutation) ResetSubmittedAt() {
	m.submitted_at = nil
	delete(m.clearedFields, assignmentsubmission.FieldSubmittedAt)
}

// SetGradedAt sets the "graded_at" field.
func (m *AssignmentSubmissionMutation) SetGradedAt(t time.Time) {
	m.graded_at = &t
}

// GradedAt returns the value of the "graded_at" field in the mutation.
func (m *AssignmentSubmissionMutation) GradedAt() (r time.Time, exists bool) {
	v := m.graded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGradedAt returns the old "graded_at" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldGradedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGradedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGradedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGradedAt: %w", err)
	}
	return oldValue.GradedAt, nil
}

// ClearGradedAt clears the value of the "graded_at" field.
func (m *AssignmentSubmissionMutation) ClearGradedAt() {
	m.graded_at = nil
	m.clearedFields[assignmentsubmission.FieldGradedAt] = struct{}{}
}

// GradedAtCleared returns if the "graded_at" field was cleared in this mutation.
func (m *AssignmentSubmissionMutation) GradedAtCleared() bool {
	_, ok := m.clearedFields[assignmentsubmission.FieldGradedAt]
	return ok
}

// ResetGradedAt resets all changes to the "graded_at" field.
func (m *AssignmentSubmissionMutation) ResetGradedAt() {
	m.graded_at = nil
	delete(m.clearedFields, assignmentsubmission.FieldGradedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AssignmentSubmissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssignmentSubmissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssignmentSubmissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssignmentSubmissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssignmentSubmissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssignmentSubmissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAssignmentID sets the "assignment" edge to the Assignment entity by id.
func (m *AssignmentSubmissionMutation) SetAssignmentID(id int) {
	m.assignment = &id
}

// ClearAssignment clears the "assignment" edge to the Assignment entity.
func (m *AssignmentSubmissionMutation) ClearAssignment() {
	m.clearedassignment = true
}

// AssignmentCleared reports if the "assignment" edge to the Assignment entity was cleared.
func (m *AssignmentSubmissionMutation) AssignmentCleared() bool {
	return m.clearedassignment
}

// AssignmentID returns the "assignment" edge ID in the mutation.
func (m *AssignmentSubmissionMutation) AssignmentID() (id int, exists bool) {
	if m.assignment != nil {
		return *m.assignment, true
	}
	return
}

// AssignmentIDs returns the "assignment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignmentID instead. It exists only for internal usage by the builders.
func (m *AssignmentSubmissionMutation) AssignmentIDs() (ids []int) {
	if id := m.assignment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignment resets all changes to the "assignment" edge.
func (m *AssignmentSubmissionMutation) ResetAssignment() {
	m.assignment = nil
	m.clearedassignment = false
}

// SetStudentID sets the "student" edge to the User entity by id.
func (m *AssignmentSubmissionMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the User entity.
func (m *AssignmentSubmissionMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the User entity was cleared.
func (m *AssignmentSubmissionMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *AssignmentSubmissionMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *AssignmentSubmissionMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *AssignmentSubmissionMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the AssignmentSubmissionMutation builder.
func (m *AssignmentSubmissionMutation) Where(ps ...predicate.AssignmentSubmission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssignmentSubmissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssignmentSubmissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssignmentSubmission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssignmentSubmissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssignmentSubmissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssignmentSubmission).
func (m *AssignmentSubmissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssignmentSubmissionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.levels_completed != nil {
		fields = append(fields, assignmentsubmission.FieldLevelsCompleted)
	}
	if m.total_levels != nil {
		fields = append(fields, assignmentsubmission.FieldTotalLevels)
	}
	if m.total_stars != nil {
		fields = append(fields, assignmentsubmission.FieldTotalStars)
	}
	if m.grade_percentage != nil {
		fields = append(fields, assignmentsubmission.FieldGradePercentage)
	}
	if m.manual_grade != nil {
		fields = append(fields, assignmentsubmission.FieldManualGrade)
	}
	if m.teacher_notes != nil {
		fields = append(fields, assignmentsubmission.FieldTeacherNotes)
	}
	if m.submitted_at != nil {
		fields = append(fields, assignmentsubmission.FieldSubmittedAt)
	}
	if m.graded_at != nil {
		fields = append(fields, assignmentsubmission.FieldGradedAt)
	}
	if m.created_at != nil {
		fields = append(fields, assignmentsubmission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assignmentsubmission.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssignmentSubmissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assignmentsubmission.FieldLevelsCompleted:
		return m.LevelsCompleted()
	case assignmentsubmission.FieldTotalLevels:
		return m.TotalLevels()
	case assignmentsubmission.FieldTotalStars:
		return m.TotalStars()
	case assignmentsubmission.FieldGradePercentage:
		return m.GradePercentage()
	case assignmentsubmission.FieldManualGrade:
		return m.ManualGrade()
	case assignmentsubmission.FieldTeacherNotes:
		return m.TeacherNotes()
	case assignmentsubmission.FieldSubmittedAt:
		return m.SubmittedAt()
	case assignmentsubmission.FieldGradedAt:
		return m.GradedAt()
	case assignmentsubmission.FieldCreatedAt:
		return m.CreatedAt()
	case assignmentsubmission.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssignmentSubmissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assignmentsubmission.FieldLevelsCompleted:
		return m.OldLevelsCompleted(ctx)
	case assignmentsubmission.FieldTotalLevels:
		return m.OldTotalLevels(ctx)
	case assignmentsubmission.FieldTotalStars:
		return m.OldTotalStars(ctx)
	case assignmentsubmission.FieldGradePercentage:
		return m.OldGradePercentage(ctx)
	case assignmentsubmission.FieldManualGrade:
		return m.OldManualGrade(ctx)
	case assignmentsubmission.FieldTeacherNotes:
		return m.OldTeacherNotes(ctx)
	case assignmentsubmission.FieldSubmittedAt:
		return m.OldSubmittedAt(ctx)
	case assignmentsubmission.FieldGradedAt:
		return m.OldGradedAt(ctx)
	case assignmentsubmission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assignmentsubmission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AssignmentSubmission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentSubmissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assignmentsubmission.FieldLevelsCompleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelsCompleted(v)
		return nil
	case assignmentsubmission.FieldTotalLevels:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalLevels(v)
		return nil
	case assignmentsubmission.FieldTotalStars:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalStars(v)
		return nil
	case assignmentsubmission.FieldGradePercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGradePercentage(v)
		return nil
	case assignmentsubmission.FieldManualGrade:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManualGrade(v)
		return nil
	case assignmentsubmission.FieldTeacherNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherNotes(v)
		return nil
	case assignmentsubmission.FieldSubmittedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmittedAt(v)
		return nil
	case assignmentsubmission.FieldGradedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGradedAt(v)
		return nil
	case assignmentsubmission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assignmentsubmission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AssignmentSubmission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssignmentSubmissionMutation) AddedFields() []string {
	var fields []string
	if m.addlevels_completed != nil {
		fields = append(fields, assignmentsubmission.FieldLevelsCompleted)
	}
	if m.addtotal_levels != nil {
		fields = append(fields, assignmentsubmission.FieldTotalLevels)
	}
	if m.addtotal_stars != nil {
		fields = append(fields, assignmentsubmission.FieldTotalStars)
	}
	if m.addgrade_percentage != nil {
		fields = append(fields, assignmentsubmission.FieldGradePercentage)
	}
	if m.addmanual_grade != nil {
		fields = append(fields, assignmentsubmission.FieldManualGrade)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssignmentSubmissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case assignmentsubmission.FieldLevelsCompleted:
		return m.AddedLevelsCompleted()
	case assignmentsubmission.FieldTotalLevels:
		return m.AddedTotalLevels()
	case assignmentsubmission.FieldTotalStars:
		return m.AddedTotalStars()
	case assignmentsubmission.FieldGradePercentage:
		return m.AddedGradePercentage()
	case assignmentsubmission.FieldManualGrade:
		return m.AddedManualGrade()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentSubmissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case assignmentsubmission.FieldLevelsCompleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevelsCompleted(v)
		return nil
	case assignmentsubmission.FieldTotalLevels:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalLevels(v)
		return nil
	case assignmentsubmission.FieldTotalStars:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalStars(v)
		return nil
	case assignmentsubmission.FieldGradePercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGradePercentage(v)
		return nil
	case assignmentsubmission.FieldManualGrade:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddManualGrade(v)
		return nil
	}
	return fmt.Errorf("unknown AssignmentSubmission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssignmentSubmissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assignmentsubmission.FieldGradePercentage) {
		fields = append(fields, assignmentsubmission.FieldGradePercentage)
	}
	if m.FieldCleared(assignmentsubmission.FieldManualGrade) {
		fields = append(fields, assignmentsubmission.FieldManualGrade)
	}
	if m.FieldCleared(assignmentsubmission.FieldTeacherNotes) {
		fields = append(fields, assignmentsubmission.FieldTeacherNotes)
	}
	if m.FieldCleared(assignmentsubmission.FieldSubmittedAt) {
		fields = append(fields, assignmentsubmission.FieldSubmittedAt)
	}
	if m.FieldCleared(assignmentsubmission.FieldGradedAt) {
		fields = append(fields, assignmentsubmission.FieldGradedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssignmentSubmissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssignmentSubmissionMutation) ClearField(name string) error {
	switch name {
	case assignmentsubmission.FieldGradePercentage:
		m.ClearGradePercentage()
		return nil
	case assignmentsubmission.FieldManualGrade:
		m.ClearManualGrade()
		return nil
	case assignmentsubmission.FieldTeacherNotes:
		m.ClearTeacherNotes()
		return nil
	case assignmentsubmission.FieldSubmittedAt:
		m.ClearSubmittedAt()
		return nil
	case assignmentsubmission.FieldGradedAt:
		m.ClearGradedAt()
		return nil
	}
	return fmt.Errorf("unknown AssignmentSubmission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssignmentSubmissionMutation) ResetField(name string) error {
	switch name {
	case assignmentsubmission.FieldLevelsCompleted:
		m.ResetLevelsCompleted()
		return nil
	case assignmentsubmission.FieldTotalLevels:
		m.ResetTotalLevels()
		return nil
	case assignmentsubmission.FieldTotalStars:
		m.ResetTotalStars()
		return nil
	case assignmentsubmission.FieldGradePercentage:
		m.ResetGradePercentage()
		return nil
	case assignmentsubmission.FieldManualGrade:
		m.ResetManualGrade()
		return nil
	case assignmentsubmission.FieldTeacherNotes:
		m.ResetTeacherNotes()
		return nil
	case assignmentsubmission.FieldSubmittedAt:
		m.ResetSubmittedAt()
		return nil
	case assignmentsubmission.FieldGradedAt:
		m.ResetGradedAt()
		return nil
	case assignmentsubmission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assignmentsubmission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AssignmentSubmission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssignmentSubmissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.assignment != nil {
		edges = append(edges, assignmentsubmission.EdgeAssignment)
	}
	if m.student != nil {
		edges = append(edges, assignmentsubmission.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssignmentSubmissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assignmentsubmission.EdgeAssignment:
		if id := m.assignment; id != nil {
			return []ent.Value{*id}
		}
	case assignmentsubmission.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssignmentSubmissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssignmentSubmissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssignmentSubmissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedassignment {
		edges = append(edges, assignmentsubmission.EdgeAssignment)
	}
	if m.clearedstudent {
		edges = append(edges, assignmentsubmission.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssignmentSubmissionMutation) EdgeCleared(name string) bool {
	switch name {
	case assignmentsubmission.EdgeAssignment:
		return m.clearedassignment
	case assignmentsubmission.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssignmentSubmissionMutation) ClearEdge(name string) error {
	switch name {
	case assignmentsubmission.EdgeAssignment:
		m.ClearAssignment()
		return nil
	case assignmentsubmission.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown AssignmentSubmission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssignmentSubmissionMutation) ResetEdge(name string) error {
	switch name {
	case assignmentsubmission.EdgeAssignment:
		m.ResetAssignment()
		return nil
	case assignmentsubmission.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown AssignmentSubmission edge %s", name)
}

// BattleRoomMutation represents an operation that mutates the BattleRoom nodes in the graph.
type BattleRoomMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	room_code          *string
	host_name          *string
	guest_id           *int
	addguest_id        *int
	guest_name         *string
	status             *battleroom.Status
	level              *map[string]interface{}
	host_completed     *bool
	host_completed_at  *time.Time
	host_code          *string
	guest_completed    *bool
	guest_completed_at *time.Time
	guest_code         *string
	winner_id          *int
	addwinner_id       *int
	started_at         *time.Time
	expires_at         *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	app                *int
	clearedapp         bool
	host               *int
	clearedhost        bool
	done               bool
	oldValue           func(context.Context) (*BattleRoom, error)
	predicates         []predicate.BattleRoom
}

var _ ent.Mutation = (*BattleRoomMutation)(nil)

// battleroomOption allows management of the mutation configuration using functional options.
type battleroomOption func(*BattleRoomMutation)

// newBattleRoomMutation creates new mutation for the BattleRoom entity.
func newBattleRoomMutation(c config, op Op, opts ...battleroomOption) *BattleRoomMutation {
	m := &BattleRoomMutation{
		config:        c,
		op:            op,
		typ:           TypeBattleRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBattleRoomID sets the ID field of the mutation.
func withBattleRoomID(id int) battleroomOption {
	return func(m *BattleRoomMutation) {
		var (
			err   error
			once  sync.Once
			value *BattleRoom
		)
		m.oldValue = func(ctx context.Context) (*BattleRoom, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BattleRoom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBattleRoom sets the old BattleRoom of the mutation.
func withBattleRoom(node *BattleRoom) battleroomOption {
	return func(m *BattleRoomMutation) {
		m.oldValue = func(context.Context) (*BattleRoom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BattleRoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BattleRoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BattleRoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BattleRoomMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BattleRoom.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoomCode sets the "room_code" field.
func (m *BattleRoomMutation) SetRoomCode(s string) {
	m.room_code = &s
}

// RoomCode returns the value of the "room_code" field in the mutation.
func (m *BattleRoomMutation) RoomCode() (r string, exists bool) {
	v := m.room_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomCode returns the old "room_code" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldRoomCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomCode: %w", err)
	}
	return oldValue.RoomCode, nil
}

// ResetRoomCode resets all changes to the "room_code" field.
func (m *BattleRoomMutation) ResetRoomCode() {
	m.room_code = nil
}

// SetHostName sets the "host_name" field.
func (m *BattleRoomMutation) SetHostName(s string) {
	m.host_name = &s
}

// HostName returns the value of the "host_name" field in the mutation.
func (m *BattleRoomMutation) HostName() (r string, exists bool) {
	v := m.host_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHostName returns the old "host_name" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldHostName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostName: %w", err)
	}
	return oldValue.HostName, nil
}

// ClearHostName clears the value of the "host_name" field.
func (m *BattleRoomMutation) ClearHostName() {
	m.host_name = nil
	m.clearedFields[battleroom.FieldHostName] = struct{}{}
}

// HostNameCleared returns if the "host_name" field was cleared in this mutation.
func (m *BattleRoomMutation) HostNameCleared() bool {
	_, ok := m.clearedFields[battleroom.FieldHostName]
	return ok
}

// ResetHostName resets all changes to the "host_name" field.
func (m *BattleRoomMutation) ResetHostName() {
	m.host_name = nil
	delete(m.clearedFields, battleroom.FieldHostName)
}

// SetGuestID sets the "guest_id" field.
func (m *BattleRoomMutation) SetGuestID(i int) {
	m.guest_id = &i
	m.addguest_id = nil
}

// GuestID returns the value of the "guest_id" field in the mutation.
func (m *BattleRoomMutation) GuestID() (r int, exists bool) {
	v := m.guest_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGuestID returns the old "guest_id" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldGuestID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuestID: %w", err)
	}
	return oldValue.GuestID, nil
}

// AddGuestID adds i to the "guest_id" field.
func (m *BattleRoomMutation) AddGuestID(i int) {
	if m.addguest_id != nil {
		*m.addguest_id += i
	} else {
		m.addguest_id = &i
	}
}

// AddedGuestID returns the value that was added to the "guest_id" field in this mutation.
func (m *BattleRoomMutation) AddedGuestID() (r int, exists bool) {
	v := m.addguest_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearGuestID clears the value of the "guest_id" field.
func (m *BattleRoomMutation) ClearGuestID() {
	m.guest_id = nil
	m.addguest_id = nil
	m.clearedFields[battleroom.FieldGuestID] = struct{}{}
}

// GuestIDCleared returns if the "guest_id" field was cleared in this mutation.
func (m *BattleRoomMutation) GuestIDCleared() bool {
	_, ok := m.clearedFields[battleroom.FieldGuestID]
	return ok
}

// ResetGuestID resets all changes to the "guest_id" field.
func (m *BattleRoomMutation) ResetGuestID() {
	m.guest_id = nil
	m.addguest_id = nil
	delete(m.clearedFields, battleroom.FieldGuestID)
}

// SetGuestName sets the "guest_name" field.
func (m *BattleRoomMutation) SetGuestName(s string) {
	m.guest_name = &s
}

// GuestName returns the value of the "guest_name" field in the mutation.
func (m *BattleRoomMutation) GuestName() (r string, exists bool) {
	v := m.guest_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGuestName returns the old "guest_name" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldGuestName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuestName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuestName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuestName: %w", err)
	}
	return oldValue.GuestName, nil
}

// ClearGuestName clears the value of the "guest_name" field.
func (m *BattleRoomMutation) ClearGuestName() {
	m.guest_name = nil
	m.clearedFields[battleroom.FieldGuestName] = struct{}{}
}

// GuestNameCleared returns if the "guest_name" field was cleared in this mutation.
func (m *BattleRoomMutation) GuestNameCleared() bool {
	_, ok := m.clearedFields[battleroom.FieldGuestName]
	return ok
}

// ResetGuestName resets all changes to the "guest_name" field.
func (m *BattleRoomMutation) ResetGuestName() {
	m.guest_name = nil
	delete(m.clearedFields, battleroom.FieldGuestName)
}

// SetStatus sets the "status" field.
func (m *BattleRoomMutation) SetStatus(b battleroom.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BattleRoomMutation) Status() (r battleroom.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldStatus(ctx context.Context) (v battleroom.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BattleRoomMutation) ResetStatus() {
	m.status = nil
}

// SetLevel sets the "level" field.
func (m *BattleRoomMutation) SetLevel(value map[string]interface{}) {
	m.level = &value
}

// Level returns the value of the "level" field in the mutation.
func (m *BattleRoomMutation) Level() (r map[string]interface{}, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldLevel(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ClearLevel clears the value of the "level" field.
func (m *BattleRoomMutation) ClearLevel() {
	m.level = nil
	m.clearedFields[battleroom.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *BattleRoomMutation) LevelCleared() bool {
	_, ok := m.clearedFields[battleroom.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *BattleRoomMutation) ResetLevel() {
	m.level = nil
	delete(m.clearedFields, battleroom.FieldLevel)
}

// SetHostCompleted sets the "host_completed" field.
func (m *BattleRoomMutation) SetHostCompleted(b bool) {
	m.host_completed = &b
}

// HostCompleted returns the value of the "host_completed" field in the mutation.
func (m *BattleRoomMutation) HostCompleted() (r bool, exists bool) {
	v := m.host_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldHostCompleted returns the old "host_completed" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldHostCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostCompleted: %w", err)
	}
	return oldValue.HostCompleted, nil
}

// ResetHostCompleted resets all changes to the "host_completed" field.
func (m *BattleRoomMutation) ResetHostCompleted() {
	m.host_completed = nil
}

// SetHostCompletedAt sets the "host_completed_at" field.
func (m *BattleRoomMutation) SetHostCompletedAt(t time.Time) {
	m.host_completed_at = &t
}

// HostCompletedAt returns the value of the "host_completed_at" field in the mutation.
func (m *BattleRoomMutation) HostCompletedAt() (r time.Time, exists bool) {
	v := m.host_completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldHostCompletedAt returns the old "host_completed_at" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldHostCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostCompletedAt: %w", err)
	}
	return oldValue.HostCompletedAt, nil
}

// ClearHostCompletedAt clears the value of the "host_completed_at" field.
func (m *BattleRoomMutation) ClearHostCompletedAt() {
	m.host_completed_at = nil
	m.clearedFields[battleroom.FieldHostCompletedAt] = struct{}{}
}

// HostCompletedAtCleared returns if the "host_completed_at" field was cleared in this mutation.
func (m *BattleRoomMutation) HostCompletedAtCleared() bool {
	_, ok := m.clearedFields[battleroom.FieldHostCompletedAt]
	return ok
}

// ResetHostCompletedAt resets all changes to the "host_completed_at" field.
func (m *BattleRoomMutation) ResetHostCompletedAt() {
	m.host_completed_at = nil
	delete(m.clearedFields, battleroom.FieldHostCompletedAt)
}

// SetHostCode sets the "host_code" field.
func (m *BattleRoomMutation) SetHostCode(s string) {
	m.host_code = &s
}

// HostCode returns the value of the "host_code" field in the mutation.
func (m *BattleRoomMutation) HostCode() (r string, exists bool) {
	v := m.host_code
	if v == nil {
		return
	}
	return *v, true
}

// OldHostCode returns the old "host_code" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldHostCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostCode: %w", err)
	}
	return oldValue.HostCode, nil
}

// ClearHostCode clears the value of the "host_code" field.
func (m *BattleRoomMutation) ClearHostCode() {
	m.host_code = nil
	m.clearedFields[battleroom.FieldHostCode] = struct{}{}
}

// HostCodeCleared returns if the "host_code" field was cleared in this mutation.
func (m *BattleRoomMutation) HostCodeCleared() bool {
	_, ok := m.clearedFields[battleroom.FieldHostCode]
	return ok
}

// ResetHostCode resets all changes to the "host_code" field.
func (m *BattleRoomMutation) ResetHostCode() {
	m.host_code = nil
	delete(m.clearedFields, battleroom.FieldHostCode)
}

// SetGuestCompleted sets the "guest_completed" field.
func (m *BattleRoomMutation) SetGuestCompleted(b bool) {
	m.guest_completed = &b
}

// GuestCompleted returns the value of the "guest_completed" field in the mutation.
func (m *BattleRoomMutation) GuestCompleted() (r bool, exists bool) {
	v := m.guest_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldGuestCompleted returns the old "guest_completed" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldGuestCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuestCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuestCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuestCompleted: %w", err)
	}
	return oldValue.GuestCompleted, nil
}

// ResetGuestCompleted resets all changes to the "guest_completed" field.
func (m *BattleRoomMutation) ResetGuestCompleted() {
	m.guest_completed = nil
}

// SetGuestCompletedAt sets the "guest_completed_at" field.
func (m *BattleRoomMutation) SetGuestCompletedAt(t time.Time) {
	m.guest_completed_at = &t
}

// GuestCompletedAt returns the value of the "guest_completed_at" field in the mutation.
func (m *BattleRoomMutation) GuestCompletedAt() (r time.Time, exists bool) {
	v := m.guest_completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGuestCompletedAt returns the old "guest_completed_at" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldGuestCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuestCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuestCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuestCompletedAt: %w", err)
	}
	return oldValue.GuestCompletedAt, nil
}

// ClearGuestCompletedAt clears the value of the "guest_completed_at" field.
func (m *BattleRoomMutation) ClearGuestCompletedAt() {
	m.guest_completed_at = nil
	m.clearedFields[battleroom.FieldGuestCompletedAt] = struct{}{}
}

// GuestCompletedAtCleared returns if the "guest_completed_at" field was cleared in this mutation.
func (m *BattleRoomMutation) GuestCompletedAtCleared() bool {
	_, ok := m.clearedFields[battleroom.FieldGuestCompletedAt]
	return ok
}

// ResetGuestCompletedAt resets all changes to the "guest_completed_at" field.
func (m *BattleRoomMutation) ResetGuestCompletedAt() {
	m.guest_completed_at = nil
	delete(m.clearedFields, battleroom.FieldGuestCompletedAt)
}

// SetGuestCode sets the "guest_code" field.
func (m *BattleRoomMutation) SetGuestCode(s string) {
	m.guest_code = &s
}

// GuestCode returns the value of the "guest_code" field in the mutation.
func (m *BattleRoomMutation) GuestCode() (r string, exists bool) {
	v := m.guest_code
	if v == nil {
		return
	}
	return *v, true
}

// OldGuestCode returns the old "guest_code" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldGuestCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuestCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuestCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuestCode: %w", err)
	}
	return oldValue.GuestCode, nil
}

// ClearGuestCode clears the value of the "guest_code" field.
func (m *BattleRoomMutation) ClearGuestCode() {
	m.guest_code = nil
	m.clearedFields[battleroom.FieldGuestCode] = struct{}{}
}

// GuestCodeCleared returns if the "guest_code" field was cleared in this mutation.
func (m *BattleRoomMutation) GuestCodeCleared() bool {
	_, ok := m.clearedFields[battleroom.FieldGuestCode]
	return ok
}

// ResetGuestCode resets all changes to the "guest_code" field.
func (m *BattleRoomMutation) ResetGuestCode() {
	m.guest_code = nil
	delete(m.clearedFields, battleroom.FieldGuestCode)
}

// SetWinnerID sets the "winner_id" field.
func (m *BattleRoomMutation) SetWinnerID(i int) {
	m.winner_id = &i
	m.addwinner_id = nil
}

// WinnerID returns the value of the "winner_id" field in the mutation.
func (m *BattleRoomMutation) WinnerID() (r int, exists bool) {
	v := m.winner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWinnerID returns the old "winner_id" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldWinnerID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinnerID: %w", err)
	}
	return oldValue.WinnerID, nil
}

// AddWinnerID adds i to the "winner_id" field.
func (m *BattleRoomMutation) AddWinnerID(i int) {
	if m.addwinner_id != nil {
		*m.addwinner_id += i
	} else {
		m.addwinner_id = &i
	}
}

// AddedWinnerID returns the value that was added to the "winner_id" field in this mutation.
func (m *BattleRoomMutation) AddedWinnerID() (r int, exists bool) {
	v := m.addwinner_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearWinnerID clears the value of the "winner_id" field.
func (m *BattleRoomMutation) ClearWinnerID() {
	m.winner_id = nil
	m.addwinner_id = nil
	m.clearedFields[battleroom.FieldWinnerID] = struct{}{}
}

// WinnerIDCleared returns if the "winner_id" field was cleared in this mutation.
func (m *BattleRoomMutation) WinnerIDCleared() bool {
	_, ok := m.clearedFields[battleroom.FieldWinnerID]
	return ok
}

// ResetWinnerID resets all changes to the "winner_id" field.
func (m *BattleRoomMutation) ResetWinnerID() {
	m.winner_id = nil
	m.addwinner_id = nil
	delete(m.clearedFields, battleroom.FieldWinnerID)
}

// SetStartedAt sets the "started_at" field.
func (m *BattleRoomMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *BattleRoomMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *BattleRoomMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[battleroom.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *BattleRoomMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[battleroom.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *BattleRoomMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, battleroom.FieldStartedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *BattleRoomMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *BattleRoomMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *BattleRoomMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BattleRoomMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BattleRoomMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BattleRoomMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BattleRoomMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BattleRoomMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BattleRoom entity.
// If the BattleRoom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleRoomMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BattleRoomMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *BattleRoomMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *BattleRoomMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *BattleRoomMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *BattleRoomMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *BattleRoomMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *BattleRoomMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetHostID sets the "host" edge to the User entity by id.
func (m *BattleRoomMutation) SetHostID(id int) {
	m.host = &id
}

// ClearHost clears the "host" edge to the User entity.
func (m *BattleRoomMutation) ClearHost() {
	m.clearedhost = true
}

// HostCleared reports if the "host" edge to the User entity was cleared.
func (m *BattleRoomMutation) HostCleared() bool {
	return m.clearedhost
}

// HostID returns the "host" edge ID in the mutation.
func (m *BattleRoomMutation) HostID() (id int, exists bool) {
	if m.host != nil {
		return *m.host, true
	}
	return
}

// HostIDs returns the "host" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostID instead. It exists only for internal usage by the builders.
func (m *BattleRoomMutation) HostIDs() (ids []int) {
	if id := m.host; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHost resets all changes to the "host" edge.
func (m *BattleRoomMutation) ResetHost() {
	m.host = nil
	m.clearedhost = false
}

// Where appends a list predicates to the BattleRoomMutation builder.
func (m *BattleRoomMutation) Where(ps ...predicate.BattleRoom) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BattleRoomMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BattleRoomMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BattleRoom, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BattleRoomMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BattleRoomMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BattleRoom).
func (m *BattleRoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BattleRoomMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.room_code != nil {
		fields = append(fields, battleroom.FieldRoomCode)
	}
	if m.host_name != nil {
		fields = append(fields, battleroom.FieldHostName)
	}
	if m.guest_id != nil {
		fields = append(fields, battleroom.FieldGuestID)
	}
	if m.guest_name != nil {
		fields = append(fields, battleroom.FieldGuestName)
	}
	if m.status != nil {
		fields = append(fields, battleroom.FieldStatus)
	}
	if m.level != nil {
		fields = append(fields, battleroom.FieldLevel)
	}
	if m.host_completed != nil {
		fields = append(fields, battleroom.FieldHostCompleted)
	}
	if m.host_completed_at != nil {
		fields = append(fields, battleroom.FieldHostCompletedAt)
	}
	if m.host_code != nil {
		fields = append(fields, battleroom.FieldHostCode)
	}
	if m.guest_completed != nil {
		fields = append(fields, battleroom.FieldGuestCompleted)
	}
	if m.guest_completed_at != nil {
		fields = append(fields, battleroom.FieldGuestCompletedAt)
	}
	if m.guest_code != nil {
		fields = append(fields, battleroom.FieldGuestCode)
	}
	if m.winner_id != nil {
		fields = append(fields, battleroom.FieldWinnerID)
	}
	if m.started_at != nil {
		fields = append(fields, battleroom.FieldStartedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, battleroom.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, battleroom.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, battleroom.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BattleRoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case battleroom.FieldRoomCode:
		return m.RoomCode()
	case battleroom.FieldHostName:
		return m.HostName()
	case battleroom.FieldGuestID:
		return m.GuestID()
	case battleroom.FieldGuestName:
		return m.GuestName()
	case battleroom.FieldStatus:
		return m.Status()
	case battleroom.FieldLevel:
		return m.Level()
	case battleroom.FieldHostCompleted:
		return m.HostCompleted()
	case battleroom.FieldHostCompletedAt:
		return m.HostCompletedAt()
	case battleroom.FieldHostCode:
		return m.HostCode()
	case battleroom.FieldGuestCompleted:
		return m.GuestCompleted()
	case battleroom.FieldGuestCompletedAt:
		return m.GuestCompletedAt()
	case battleroom.FieldGuestCode:
		return m.GuestCode()
	case battleroom.FieldWinnerID:
		return m.WinnerID()
	case battleroom.FieldStartedAt:
		return m.StartedAt()
	case battleroom.FieldExpiresAt:
		return m.ExpiresAt()
	case battleroom.FieldCreatedAt:
		return m.CreatedAt()
	case battleroom.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BattleRoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case battleroom.FieldRoomCode:
		return m.OldRoomCode(ctx)
	case battleroom.FieldHostName:
		return m.OldHostName(ctx)
	case battleroom.FieldGuestID:
		return m.OldGuestID(ctx)
	case battleroom.FieldGuestName:
		return m.OldGuestName(ctx)
	case battleroom.FieldStatus:
		return m.OldStatus(ctx)
	case battleroom.FieldLevel:
		return m.OldLevel(ctx)
	case battleroom.FieldHostCompleted:
		return m.OldHostCompleted(ctx)
	case battleroom.FieldHostCompletedAt:
		return m.OldHostCompletedAt(ctx)
	case battleroom.FieldHostCode:
		return m.OldHostCode(ctx)
	case battleroom.FieldGuestCompleted:
		return m.OldGuestCompleted(ctx)
	case battleroom.FieldGuestCompletedAt:
		return m.OldGuestCompletedAt(ctx)
	case battleroom.FieldGuestCode:
		return m.OldGuestCode(ctx)
	case battleroom.FieldWinnerID:
		return m.OldWinnerID(ctx)
	case battleroom.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case battleroom.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case battleroom.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case battleroom.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BattleRoom field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BattleRoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case battleroom.FieldRoomCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomCode(v)
		return nil
	case battleroom.FieldHostName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostName(v)
		return nil
	case battleroom.FieldGuestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuestID(v)
		return nil
	case battleroom.FieldGuestName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuestName(v)
		return nil
	case battleroom.FieldStatus:
		v, ok := value.(battleroom.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case battleroom.FieldLevel:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case battleroom.FieldHostCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostCompleted(v)
		return nil
	case battleroom.FieldHostCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostCompletedAt(v)
		return nil
	case battleroom.FieldHostCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostCode(v)
		return nil
	case battleroom.FieldGuestCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuestCompleted(v)
		return nil
	case battleroom.FieldGuestCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuestCompletedAt(v)
		return nil
	case battleroom.FieldGuestCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuestCode(v)
		return nil
	case battleroom.FieldWinnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinnerID(v)
		return nil
	case battleroom.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case battleroom.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case battleroom.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case battleroom.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BattleRoom field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BattleRoomMutation) AddedFields() []string {
	var fields []string
	if m.addguest_id != nil {
		fields = append(fields, battleroom.FieldGuestID)
	}
	if m.addwinner_id != nil {
		fields = append(fields, battleroom.FieldWinnerID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BattleRoomMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case battleroom.FieldGuestID:
		return m.AddedGuestID()
	case battleroom.FieldWinnerID:
		return m.AddedWinnerID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BattleRoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	case battleroom.FieldGuestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGuestID(v)
		return nil
	case battleroom.FieldWinnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWinnerID(v)
		return nil
	}
	return fmt.Errorf("unknown BattleRoom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BattleRoomMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(battleroom.FieldHostName) {
		fields = append(fields, battleroom.FieldHostName)
	}
	if m.FieldCleared(battleroom.FieldGuestID) {
		fields = append(fields, battleroom.FieldGuestID)
	}
	if m.FieldCleared(battleroom.FieldGuestName) {
		fields = append(fields, battleroom.FieldGuestName)
	}
	if m.FieldCleared(battleroom.FieldLevel) {
		fields = append(fields, battleroom.FieldLevel)
	}
	if m.FieldCleared(battleroom.FieldHostCompletedAt) {
		fields = append(fields, battleroom.FieldHostCompletedAt)
	}
	if m.FieldCleared(battleroom.FieldHostCode) {
		fields = append(fields, battleroom.FieldHostCode)
	}
	if m.FieldCleared(battleroom.FieldGuestCompletedAt) {
		fields = append(fields, battleroom.FieldGuestCompletedAt)
	}
	if m.FieldCleared(battleroom.FieldGuestCode) {
		fields = append(fields, battleroom.FieldGuestCode)
	}
	if m.FieldCleared(battleroom.FieldWinnerID) {
		fields = append(fields, battleroom.FieldWinnerID)
	}
	if m.FieldCleared(battleroom.FieldStartedAt) {
		fields = append(fields, battleroom.FieldStartedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BattleRoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BattleRoomMutation) ClearField(name string) error {
	switch name {
	case battleroom.FieldHostName:
		m.ClearHostName()
		return nil
	case battleroom.FieldGuestID:
		m.ClearGuestID()
		return nil
	case battleroom.FieldGuestName:
		m.ClearGuestName()
		return nil
	case battleroom.FieldLevel:
		m.ClearLevel()
		return nil
	case battleroom.FieldHostCompletedAt:
		m.ClearHostCompletedAt()
		return nil
	case battleroom.FieldHostCode:
		m.ClearHostCode()
		return nil
	case battleroom.FieldGuestCompletedAt:
		m.ClearGuestCompletedAt()
		return nil
	case battleroom.FieldGuestCode:
		m.ClearGuestCode()
		return nil
	case battleroom.FieldWinnerID:
		m.ClearWinnerID()
		return nil
	case battleroom.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	}
	return fmt.Errorf("unknown BattleRoom nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BattleRoomMutation) ResetField(name string) error {
	switch name {
	case battleroom.FieldRoomCode:
		m.ResetRoomCode()
		return nil
	case battleroom.FieldHostName:
		m.ResetHostName()
		return nil
	case battleroom.FieldGuestID:
		m.ResetGuestID()
		return nil
	case battleroom.FieldGuestName:
		m.ResetGuestName()
		return nil
	case battleroom.FieldStatus:
		m.ResetStatus()
		return nil
	case battleroom.FieldLevel:
		m.ResetLevel()
		return nil
	case battleroom.FieldHostCompleted:
		m.ResetHostCompleted()
		return nil
	case battleroom.FieldHostCompletedAt:
		m.ResetHostCompletedAt()
		return nil
	case battleroom.FieldHostCode:
		m.ResetHostCode()
		return nil
	case battleroom.FieldGuestCompleted:
		m.ResetGuestCompleted()
		return nil
	case battleroom.FieldGuestCompletedAt:
		m.ResetGuestCompletedAt()
		return nil
	case battleroom.FieldGuestCode:
		m.ResetGuestCode()
		return nil
	case battleroom.FieldWinnerID:
		m.ResetWinnerID()
		return nil
	case battleroom.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case battleroom.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case battleroom.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case battleroom.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BattleRoom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BattleRoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, battleroom.EdgeApp)
	}
	if m.host != nil {
		edges = append(edges, battleroom.EdgeHost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BattleRoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case battleroom.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case battleroom.EdgeHost:
		if id := m.host; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BattleRoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BattleRoomMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BattleRoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, battleroom.EdgeApp)
	}
	if m.clearedhost {
		edges = append(edges, battleroom.EdgeHost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BattleRoomMutation) EdgeCleared(name string) bool {
	switch name {
	case battleroom.EdgeApp:
		return m.clearedapp
	case battleroom.EdgeHost:
		return m.clearedhost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BattleRoomMutation) ClearEdge(name string) error {
	switch name {
	case battleroom.EdgeApp:
		m.ClearApp()
		return nil
	case battleroom.EdgeHost:
		m.ClearHost()
		return nil
	}
	return fmt.Errorf("unknown BattleRoom unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BattleRoomMutation) ResetEdge(name string) error {
	switch name {
	case battleroom.EdgeApp:
		m.ResetApp()
		return nil
	case battleroom.EdgeHost:
		m.ResetHost()
		return nil
	}
	return fmt.Errorf("unknown BattleRoom edge %s", name)
}

// BattleSessionMutation represents an operation that mutates the BattleSession nodes in the graph.
type BattleSessionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	room_code     *string
	is_host       *bool
	player_name   *string
	status        *battlesession.Status
	expires_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	app           *int
	clearedapp    bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*BattleSession, error)
	predicates    []predicate.BattleSession
}

var _ ent.Mutation = (*BattleSessionMutation)(nil)

// battlesessionOption allows management of the mutation configuration using functional options.
type battlesessionOption func(*BattleSessionMutation)

// newBattleSessionMutation creates new mutation for the BattleSession entity.
func newBattleSessionMutation(c config, op Op, opts ...battlesessionOption) *BattleSessionMutation {
	m := &BattleSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeBattleSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBattleSessionID sets the ID field of the mutation.
func withBattleSessionID(id int) battlesessionOption {
	return func(m *BattleSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *BattleSession
		)
		m.oldValue = func(ctx context.Context) (*BattleSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BattleSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBattleSession sets the old BattleSession of the mutation.
func withBattleSession(node *BattleSession) battlesessionOption {
	return func(m *BattleSessionMutation) {
		m.oldValue = func(context.Context) (*BattleSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BattleSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BattleSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BattleSessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BattleSessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BattleSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoomCode sets the "room_code" field.
func (m *BattleSessionMutation) SetRoomCode(s string) {
	m.room_code = &s
}

// RoomCode returns the value of the "room_code" field in the mutation.
func (m *BattleSessionMutation) RoomCode() (r string, exists bool) {
	v := m.room_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomCode returns the old "room_code" field's value of the BattleSession entity.
// If the BattleSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleSessionMutation) OldRoomCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomCode: %w", err)
	}
	return oldValue.RoomCode, nil
}

// ResetRoomCode resets all changes to the "room_code" field.
func (m *BattleSessionMutation) ResetRoomCode() {
	m.room_code = nil
}

// SetIsHost sets the "is_host" field.
func (m *BattleSessionMutation) SetIsHost(b bool) {
	m.is_host = &b
}

// IsHost returns the value of the "is_host" field in the mutation.
func (m *BattleSessionMutation) IsHost() (r bool, exists bool) {
	v := m.is_host
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHost returns the old "is_host" field's value of the BattleSession entity.
// If the BattleSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleSessionMutation) OldIsHost(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHost: %w", err)
	}
	return oldValue.IsHost, nil
}

// ResetIsHost resets all changes to the "is_host" field.
func (m *BattleSessionMutation) ResetIsHost() {
	m.is_host = nil
}

// SetPlayerName sets the "player_name" field.
func (m *BattleSessionMutation) SetPlayerName(s string) {
	m.player_name = &s
}

// PlayerName returns the value of the "player_name" field in the mutation.
func (m *BattleSessionMutation) PlayerName() (r string, exists bool) {
	v := m.player_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayerName returns the old "player_name" field's value of the BattleSession entity.
// If the BattleSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleSessionMutation) OldPlayerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayerName: %w", err)
	}
	return oldValue.PlayerName, nil
}

// ClearPlayerName clears the value of the "player_name" field.
func (m *BattleSessionMutation) ClearPlayerName() {
	m.player_name = nil
	m.clearedFields[battlesession.FieldPlayerName] = struct{}{}
}

// PlayerNameCleared returns if the "player_name" field was cleared in this mutation.
func (m *BattleSessionMutation) PlayerNameCleared() bool {
	_, ok := m.clearedFields[battlesession.FieldPlayerName]
	return ok
}

// ResetPlayerName resets all changes to the "player_name" field.
func (m *BattleSessionMutation) ResetPlayerName() {
	m.player_name = nil
	delete(m.clearedFields, battlesession.FieldPlayerName)
}

// SetStatus sets the "status" field.
func (m *BattleSessionMutation) SetStatus(b battlesession.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BattleSessionMutation) Status() (r battlesession.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BattleSession entity.
// If the BattleSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleSessionMutation) OldStatus(ctx context.Context) (v battlesession.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BattleSessionMutation) ResetStatus() {
	m.status = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *BattleSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *BattleSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the BattleSession entity.
// If the BattleSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *BattleSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BattleSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BattleSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BattleSession entity.
// If the BattleSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BattleSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BattleSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BattleSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BattleSession entity.
// If the BattleSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BattleSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BattleSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *BattleSessionMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *BattleSessionMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *BattleSessionMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *BattleSessionMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *BattleSessionMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *BattleSessionMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *BattleSessionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *BattleSessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BattleSessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *BattleSessionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BattleSessionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BattleSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the BattleSessionMutation builder.
func (m *BattleSessionMutation) Where(ps ...predicate.BattleSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BattleSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BattleSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BattleSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BattleSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BattleSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BattleSession).
func (m *BattleSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BattleSessionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.room_code != nil {
		fields = append(fields, battlesession.FieldRoomCode)
	}
	if m.is_host != nil {
		fields = append(fields, battlesession.FieldIsHost)
	}
	if m.player_name != nil {
		fields = append(fields, battlesession.FieldPlayerName)
	}
	if m.status != nil {
		fields = append(fields, battlesession.FieldStatus)
	}
	if m.expires_at != nil {
		fields = append(fields, battlesession.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, battlesession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, battlesession.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BattleSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case battlesession.FieldRoomCode:
		return m.RoomCode()
	case battlesession.FieldIsHost:
		return m.IsHost()
	case battlesession.FieldPlayerName:
		return m.PlayerName()
	case battlesession.FieldStatus:
		return m.Status()
	case battlesession.FieldExpiresAt:
		return m.ExpiresAt()
	case battlesession.FieldCreatedAt:
		return m.CreatedAt()
	case battlesession.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BattleSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case battlesession.FieldRoomCode:
		return m.OldRoomCode(ctx)
	case battlesession.FieldIsHost:
		return m.OldIsHost(ctx)
	case battlesession.FieldPlayerName:
		return m.OldPlayerName(ctx)
	case battlesession.FieldStatus:
		return m.OldStatus(ctx)
	case battlesession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case battlesession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case battlesession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BattleSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BattleSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case battlesession.FieldRoomCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomCode(v)
		return nil
	case battlesession.FieldIsHost:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHost(v)
		return nil
	case battlesession.FieldPlayerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayerName(v)
		return nil
	case battlesession.FieldStatus:
		v, ok := value.(battlesession.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case battlesession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case battlesession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case battlesession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BattleSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BattleSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BattleSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BattleSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BattleSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BattleSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(battlesession.FieldPlayerName) {
		fields = append(fields, battlesession.FieldPlayerName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BattleSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BattleSessionMutation) ClearField(name string) error {
	switch name {
	case battlesession.FieldPlayerName:
		m.ClearPlayerName()
		return nil
	}
	return fmt.Errorf("unknown BattleSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BattleSessionMutation) ResetField(name string) error {
	switch name {
	case battlesession.FieldRoomCode:
		m.ResetRoomCode()
		return nil
	case battlesession.FieldIsHost:
		m.ResetIsHost()
		return nil
	case battlesession.FieldPlayerName:
		m.ResetPlayerName()
		return nil
	case battlesession.FieldStatus:
		m.ResetStatus()
		return nil
	case battlesession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case battlesession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case battlesession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BattleSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BattleSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, battlesession.EdgeApp)
	}
	if m.user != nil {
		edges = append(edges, battlesession.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BattleSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case battlesession.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case battlesession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BattleSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BattleSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BattleSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, battlesession.EdgeApp)
	}
	if m.cleareduser {
		edges = append(edges, battlesession.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BattleSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case battlesession.EdgeApp:
		return m.clearedapp
	case battlesession.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BattleSessionMutation) ClearEdge(name string) error {
	switch name {
	case battlesession.EdgeApp:
		m.ClearApp()
		return nil
	case battlesession.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown BattleSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BattleSessionMutation) ResetEdge(name string) error {
	switch name {
	case battlesession.EdgeApp:
		m.ResetApp()
		return nil
	case battlesession.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown BattleSession edge %s", name)
}

// ClassroomMutation represents an operation that mutates the Classroom nodes in the graph.
type ClassroomMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	description               *string
	join_code                 *string
	is_active                 *bool
	allow_join                *bool
	active_room_code          *string
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	app                       *int
	clearedapp                bool
	teacher                   *int
	clearedteacher            bool
	memberships               map[int]struct{}
	removedmemberships        map[int]struct{}
	clearedmemberships        bool
	assignments               map[int]struct{}
	removedassignments        map[int]struct{}
	clearedassignments        bool
	live_sessions             map[int]struct{}
	removedlive_sessions      map[int]struct{}
	clearedlive_sessions      bool
	classroom_sessions        map[int]struct{}
	removedclassroom_sessions map[int]struct{}
	clearedclassroom_sessions bool
	done                      bool
	oldValue                  func(context.Context) (*Classroom, error)
	predicates                []predicate.Classroom
}

var _ ent.Mutation = (*ClassroomMutation)(nil)

// classroomOption allows management of the mutation configuration using functional options.
type classroomOption func(*ClassroomMutation)

// newClassroomMutation creates new mutation for the Classroom entity.
func newClassroomMutation(c config, op Op, opts ...classroomOption) *ClassroomMutation {
	m := &ClassroomMutation{
		config:        c,
		op:            op,
		typ:           TypeClassroom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassroomID sets the ID field of the mutation.
func withClassroomID(id int) classroomOption {
	return func(m *ClassroomMutation) {
		var (
			err   error
			once  sync.Once
			value *Classroom
		)
		m.oldValue = func(ctx context.Context) (*Classroom, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Classroom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClassroom sets the old Classroom of the mutation.
func withClassroom(node *Classroom) classroomOption {
	return func(m *ClassroomMutation) {
		m.oldValue = func(context.Context) (*Classroom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassroomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassroomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassroomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassroomMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Classroom.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ClassroomMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClassroomMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Classroom entity.
// If the Classroom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClassroomMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ClassroomMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ClassroomMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Classroom entity.
// If the Classroom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ClassroomMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[classroom.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ClassroomMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[classroom.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ClassroomMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, classroom.FieldDescription)
}

// SetJoinCode sets the "join_code" field.
func (m *ClassroomMutation) SetJoinCode(s string) {
	m.join_code = &s
}

// JoinCode returns the value of the "join_code" field in the mutation.
func (m *ClassroomMutation) JoinCode() (r string, exists bool) {
	v := m.join_code
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinCode returns the old "join_code" field's value of the Classroom entity.
// If the Classroom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomMutation) OldJoinCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinCode: %w", err)
	}
	return oldValue.JoinCode, nil
}

// ResetJoinCode resets all changes to the "join_code" field.
func (m *ClassroomMutation) ResetJoinCode() {
	m.join_code = nil
}

// SetIsActive sets the "is_active" field.
func (m *ClassroomMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ClassroomMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Classroom entity.
// If the Classroom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ClassroomMutation) ResetIsActive() {
	m.is_active = nil
}

// SetAllowJoin sets the "allow_join" field.
func (m *ClassroomMutation) SetAllowJoin(b bool) {
	m.allow_join = &b
}

// AllowJoin returns the value of the "allow_join" field in the mutation.
func (m *ClassroomMutation) AllowJoin() (r bool, exists bool) {
	v := m.allow_join
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowJoin returns the old "allow_join" field's value of the Classroom entity.
// If the Classroom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomMutation) OldAllowJoin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowJoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowJoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowJoin: %w", err)
	}
	return oldValue.AllowJoin, nil
}

// ResetAllowJoin resets all changes to the "allow_join" field.
func (m *ClassroomMutation) ResetAllowJoin() {
	m.allow_join = nil
}

// SetActiveRoomCode sets the "active_room_code" field.
func (m *ClassroomMutation) SetActiveRoomCode(s string) {
	m.active_room_code = &s
}

// ActiveRoomCode returns the value of the "active_room_code" field in the mutation.
func (m *ClassroomMutation) ActiveRoomCode() (r string, exists bool) {
	v := m.active_room_code
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveRoomCode returns the old "active_room_code" field's value of the Classroom entity.
// If the Classroom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomMutation) OldActiveRoomCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveRoomCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveRoomCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveRoomCode: %w", err)
	}
	return oldValue.ActiveRoomCode, nil
}

// ClearActiveRoomCode clears the value of the "active_room_code" field.
func (m *ClassroomMutation) ClearActiveRoomCode() {
	m.active_room_code = nil
	m.clearedFields[classroom.FieldActiveRoomCode] = struct{}{}
}

// ActiveRoomCodeCleared returns if the "active_room_code" field was cleared in this mutation.
func (m *ClassroomMutation) ActiveRoomCodeCleared() bool {
	_, ok := m.clearedFields[classroom.FieldActiveRoomCode]
	return ok
}

// ResetActiveRoomCode resets all changes to the "active_room_code" field.
func (m *ClassroomMutation) ResetActiveRoomCode() {
	m.active_room_code = nil
	delete(m.clearedFields, classroom.FieldActiveRoomCode)
}

// SetCreatedAt sets the "created_at" field.
func (m *ClassroomMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClassroomMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Classroom entity.
// If the Classroom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClassroomMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClassroomMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClassroomMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Classroom entity.
// If the Classroom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClassroomMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *ClassroomMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *ClassroomMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *ClassroomMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *ClassroomMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *ClassroomMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *ClassroomMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetTeacherID sets the "teacher" edge to the User entity by id.
func (m *ClassroomMutation) SetTeacherID(id int) {
	m.teacher = &id
}

// ClearTeacher clears the "teacher" edge to the User entity.
func (m *ClassroomMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared reports if the "teacher" edge to the User entity was cleared.
func (m *ClassroomMutation) TeacherCleared() bool {
	return m.clearedteacher
}

// TeacherID returns the "teacher" edge ID in the mutation.
func (m *ClassroomMutation) TeacherID() (id int, exists bool) {
	if m.teacher != nil {
		return *m.teacher, true
	}
	return
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *ClassroomMutation) TeacherIDs() (ids []int) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *ClassroomMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// AddMembershipIDs adds the "memberships" edge to the ClassroomMembership entity by ids.
func (m *ClassroomMutation) AddMembershipIDs(ids ...int) {
	if m.memberships == nil {
		m.memberships = make(map[int]struct{})
	}
	for i := range ids {
		m.memberships[ids[i]] = struct{}{}
	}
}

// ClearMemberships clears the "memberships" edge to the ClassroomMembership entity.
func (m *ClassroomMutation) ClearMemberships() {
	m.clearedmemberships = true
}

// MembershipsCleared reports if the "memberships" edge to the ClassroomMembership entity was cleared.
func (m *ClassroomMutation) MembershipsCleared() bool {
	return m.clearedmemberships
}

// RemoveMembershipIDs removes the "memberships" edge to the ClassroomMembership entity by IDs.
func (m *ClassroomMutation) RemoveMembershipIDs(ids ...int) {
	if m.removedmemberships == nil {
		m.removedmemberships = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.memberships, ids[i])
		m.removedmemberships[ids[i]] = struct{}{}
	}
}

// RemovedMemberships returns the removed IDs of the "memberships" edge to the ClassroomMembership entity.
func (m *ClassroomMutation) RemovedMembershipsIDs() (ids []int) {
	for id := range m.removedmemberships {
		ids = append(ids, id)
	}
	return
}

// MembershipsIDs returns the "memberships" edge IDs in the mutation.
func (m *ClassroomMutation) MembershipsIDs() (ids []int) {
	for id := range m.memberships {
		ids = append(ids, id)
	}
	return
}

// ResetMemberships resets all changes to the "memberships" edge.
func (m *ClassroomMutation) ResetMemberships() {
	m.memberships = nil
	m.clearedmemberships = false
	m.removedmemberships = nil
}

// AddAssignmentIDs adds the "assignments" edge to the Assignment entity by ids.
func (m *ClassroomMutation) AddAssignmentIDs(ids ...int) {
	if m.assignments == nil {
		m.assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignments clears the "assignments" edge to the Assignment entity.
func (m *ClassroomMutation) ClearAssignments() {
	m.clearedassignments = true
}

// AssignmentsCleared reports if the "assignments" edge to the Assignment entity was cleared.
func (m *ClassroomMutation) AssignmentsCleared() bool {
	return m.clearedassignments
}

// RemoveAssignmentIDs removes the "assignments" edge to the Assignment entity by IDs.
func (m *ClassroomMutation) RemoveAssignmentIDs(ids ...int) {
	if m.removedassignments == nil {
		m.removedassignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignments, ids[i])
		m.removedassignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignments returns the removed IDs of the "assignments" edge to the Assignment entity.
func (m *ClassroomMutation) RemovedAssignmentsIDs() (ids []int) {
	for id := range m.removedassignments {
		ids = append(ids, id)
	}
	return
}

// AssignmentsIDs returns the "assignments" edge IDs in the mutation.
func (m *ClassroomMutation) AssignmentsIDs() (ids []int) {
	for id := range m.assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignments resets all changes to the "assignments" edge.
func (m *ClassroomMutation) ResetAssignments() {
	m.assignments = nil
	m.clearedassignments = false
	m.removedassignments = nil
}

// AddLiveSessionIDs adds the "live_sessions" edge to the LiveSession entity by ids.
func (m *ClassroomMutation) AddLiveSessionIDs(ids ...int) {
	if m.live_sessions == nil {
		m.live_sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.live_sessions[ids[i]] = struct{}{}
	}
}

// ClearLiveSessions clears the "live_sessions" edge to the LiveSession entity.
func (m *ClassroomMutation) ClearLiveSessions() {
	m.clearedlive_sessions = true
}

// LiveSessionsCleared reports if the "live_sessions" edge to the LiveSession entity was cleared.
func (m *ClassroomMutation) LiveSessionsCleared() bool {
	return m.clearedlive_sessions
}

// RemoveLiveSessionIDs removes the "live_sessions" edge to the LiveSession entity by IDs.
func (m *ClassroomMutation) RemoveLiveSessionIDs(ids ...int) {
	if m.removedlive_sessions == nil {
		m.removedlive_sessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.live_sessions, ids[i])
		m.removedlive_sessions[ids[i]] = struct{}{}
	}
}

// RemovedLiveSessions returns the removed IDs of the "live_sessions" edge to the LiveSession entity.
func (m *ClassroomMutation) RemovedLiveSessionsIDs() (ids []int) {
	for id := range m.removedlive_sessions {
		ids = append(ids, id)
	}
	return
}

// LiveSessionsIDs returns the "live_sessions" edge IDs in the mutation.
func (m *ClassroomMutation) LiveSessionsIDs() (ids []int) {
	for id := range m.live_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetLiveSessions resets all changes to the "live_sessions" edge.
func (m *ClassroomMutation) ResetLiveSessions() {
	m.live_sessions = nil
	m.clearedlive_sessions = false
	m.removedlive_sessions = nil
}

// AddClassroomSessionIDs adds the "classroom_sessions" edge to the ClassroomSession entity by ids.
func (m *ClassroomMutation) AddClassroomSessionIDs(ids ...int) {
	if m.classroom_sessions == nil {
		m.classroom_sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.classroom_sessions[ids[i]] = struct{}{}
	}
}

// ClearClassroomSessions clears the "classroom_sessions" edge to the ClassroomSession entity.
func (m *ClassroomMutation) ClearClassroomSessions() {
	m.clearedclassroom_sessions = true
}

// ClassroomSessionsCleared reports if the "classroom_sessions" edge to the ClassroomSession entity was cleared.
func (m *ClassroomMutation) ClassroomSessionsCleared() bool {
	return m.clearedclassroom_sessions
}

// RemoveClassroomSessionIDs removes the "classroom_sessions" edge to the ClassroomSession entity by IDs.
func (m *ClassroomMutation) RemoveClassroomSessionIDs(ids ...int) {
	if m.removedclassroom_sessions == nil {
		m.removedclassroom_sessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.classroom_sessions, ids[i])
		m.removedclassroom_sessions[ids[i]] = struct{}{}
	}
}

// RemovedClassroomSessions returns the removed IDs of the "classroom_sessions" edge to the ClassroomSession entity.
func (m *ClassroomMutation) RemovedClassroomSessionsIDs() (ids []int) {
	for id := range m.removedclassroom_sessions {
		ids = append(ids, id)
	}
	return
}

// ClassroomSessionsIDs returns the "classroom_sessions" edge IDs in the mutation.
func (m *ClassroomMutation) ClassroomSessionsIDs() (ids []int) {
	for id := range m.classroom_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetClassroomSessions resets all changes to the "classroom_sessions" edge.
func (m *ClassroomMutation) ResetClassroomSessions() {
	m.classroom_sessions = nil
	m.clearedclassroom_sessions = false
	m.removedclassroom_sessions = nil
}

// Where appends a list predicates to the ClassroomMutation builder.
func (m *ClassroomMutation) Where(ps ...predicate.Classroom) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassroomMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassroomMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Classroom, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassroomMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassroomMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Classroom).
func (m *ClassroomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassroomMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, classroom.FieldName)
	}
	if m.description != nil {
		fields = append(fields, classroom.FieldDescription)
	}
	if m.join_code != nil {
		fields = append(fields, classroom.FieldJoinCode)
	}
	if m.is_active != nil {
		fields = append(fields, classroom.FieldIsActive)
	}
	if m.allow_join != nil {
		fields = append(fields, classroom.FieldAllowJoin)
	}
	if m.active_room_code != nil {
		fields = append(fields, classroom.FieldActiveRoomCode)
	}
	if m.created_at != nil {
		fields = append(fields, classroom.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, classroom.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassroomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case classroom.FieldName:
		return m.Name()
	case classroom.FieldDescription:
		return m.Description()
	case classroom.FieldJoinCode:
		return m.JoinCode()
	case classroom.FieldIsActive:
		return m.IsActive()
	case classroom.FieldAllowJoin:
		return m.AllowJoin()
	case classroom.FieldActiveRoomCode:
		return m.ActiveRoomCode()
	case classroom.FieldCreatedAt:
		return m.CreatedAt()
	case classroom.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassroomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case classroom.FieldName:
		return m.OldName(ctx)
	case classroom.FieldDescription:
		return m.OldDescription(ctx)
	case classroom.FieldJoinCode:
		return m.OldJoinCode(ctx)
	case classroom.FieldIsActive:
		return m.OldIsActive(ctx)
	case classroom.FieldAllowJoin:
		return m.OldAllowJoin(ctx)
	case classroom.FieldActiveRoomCode:
		return m.OldActiveRoomCode(ctx)
	case classroom.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case classroom.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Classroom field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassroomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case classroom.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case classroom.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case classroom.FieldJoinCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinCode(v)
		return nil
	case classroom.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case classroom.FieldAllowJoin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowJoin(v)
		return nil
	case classroom.FieldActiveRoomCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveRoomCode(v)
		return nil
	case classroom.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case classroom.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Classroom field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassroomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassroomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassroomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Classroom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassroomMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(classroom.FieldDescription) {
		fields = append(fields, classroom.FieldDescription)
	}
	if m.FieldCleared(classroom.FieldActiveRoomCode) {
		fields = append(fields, classroom.FieldActiveRoomCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassroomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassroomMutation) ClearField(name string) error {
	switch name {
	case classroom.FieldDescription:
		m.ClearDescription()
		return nil
	case classroom.FieldActiveRoomCode:
		m.ClearActiveRoomCode()
		return nil
	}
	return fmt.Errorf("unknown Classroom nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassroomMutation) ResetField(name string) error {
	switch name {
	case classroom.FieldName:
		m.ResetName()
		return nil
	case classroom.FieldDescription:
		m.ResetDescription()
		return nil
	case classroom.FieldJoinCode:
		m.ResetJoinCode()
		return nil
	case classroom.FieldIsActive:
		m.ResetIsActive()
		return nil
	case classroom.FieldAllowJoin:
		m.ResetAllowJoin()
		return nil
	case classroom.FieldActiveRoomCode:
		m.ResetActiveRoomCode()
		return nil
	case classroom.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case classroom.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Classroom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassroomMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.app != nil {
		edges = append(edges, classroom.EdgeApp)
	}
	if m.teacher != nil {
		edges = append(edges, classroom.EdgeTeacher)
	}
	if m.memberships != nil {
		edges = append(edges, classroom.EdgeMemberships)
	}
	if m.assignments != nil {
		edges = append(edges, classroom.EdgeAssignments)
	}
	if m.live_sessions != nil {
		edges = append(edges, classroom.EdgeLiveSessions)
	}
	if m.classroom_sessions != nil {
		edges = append(edges, classroom.EdgeClassroomSessions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassroomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case classroom.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case classroom.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	case classroom.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.memberships))
		for id := range m.memberships {
			ids = append(ids, id)
		}
		return ids
	case classroom.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.assignments))
		for id := range m.assignments {
			ids = append(ids, id)
		}
		return ids
	case classroom.EdgeLiveSessions:
		ids := make([]ent.Value, 0, len(m.live_sessions))
		for id := range m.live_sessions {
			ids = append(ids, id)
		}
		return ids
	case classroom.EdgeClassroomSessions:
		ids := make([]ent.Value, 0, len(m.classroom_sessions))
		for id := range m.classroom_sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassroomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedmemberships != nil {
		edges = append(edges, classroom.EdgeMemberships)
	}
	if m.removedassignments != nil {
		edges = append(edges, classroom.EdgeAssignments)
	}
	if m.removedlive_sessions != nil {
		edges = append(edges, classroom.EdgeLiveSessions)
	}
	if m.removedclassroom_sessions != nil {
		edges = append(edges, classroom.EdgeClassroomSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassroomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case classroom.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.removedmemberships))
		for id := range m.removedmemberships {
			ids = append(ids, id)
		}
		return ids
	case classroom.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.removedassignments))
		for id := range m.removedassignments {
			ids = append(ids, id)
		}
		return ids
	case classroom.EdgeLiveSessions:
		ids := make([]ent.Value, 0, len(m.removedlive_sessions))
		for id := range m.removedlive_sessions {
			ids = append(ids, id)
		}
		return ids
	case classroom.EdgeClassroomSessions:
		ids := make([]ent.Value, 0, len(m.removedclassroom_sessions))
		for id := range m.removedclassroom_sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassroomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedapp {
		edges = append(edges, classroom.EdgeApp)
	}
	if m.clearedteacher {
		edges = append(edges, classroom.EdgeTeacher)
	}
	if m.clearedmemberships {
		edges = append(edges, classroom.EdgeMemberships)
	}
	if m.clearedassignments {
		edges = append(edges, classroom.EdgeAssignments)
	}
	if m.clearedlive_sessions {
		edges = append(edges, classroom.EdgeLiveSessions)
	}
	if m.clearedclassroom_sessions {
		edges = append(edges, classroom.EdgeClassroomSessions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassroomMutation) EdgeCleared(name string) bool {
	switch name {
	case classroom.EdgeApp:
		return m.clearedapp
	case classroom.EdgeTeacher:
		return m.clearedteacher
	case classroom.EdgeMemberships:
		return m.clearedmemberships
	case classroom.EdgeAssignments:
		return m.clearedassignments
	case classroom.EdgeLiveSessions:
		return m.clearedlive_sessions
	case classroom.EdgeClassroomSessions:
		return m.clearedclassroom_sessions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassroomMutation) ClearEdge(name string) error {
	switch name {
	case classroom.EdgeApp:
		m.ClearApp()
		return nil
	case classroom.EdgeTeacher:
		m.ClearTeacher()
		return nil
	}
	return fmt.Errorf("unknown Classroom unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassroomMutation) ResetEdge(name string) error {
	switch name {
	case classroom.EdgeApp:
		m.ResetApp()
		return nil
	case classroom.EdgeTeacher:
		m.ResetTeacher()
		return nil
	case classroom.EdgeMemberships:
		m.ResetMemberships()
		return nil
	case classroom.EdgeAssignments:
		m.ResetAssignments()
		return nil
	case classroom.EdgeLiveSessions:
		m.ResetLiveSessions()
		return nil
	case classroom.EdgeClassroomSessions:
		m.ResetClassroomSessions()
		return nil
	}
	return fmt.Errorf("unknown Classroom edge %s", name)
}

// ClassroomMembershipMutation represents an operation that mutates the ClassroomMembership nodes in the graph.
type ClassroomMembershipMutation struct {
	config
	op               Op
	typ              string
	id               *int
	status           *classroommembership.Status
	joined_at        *time.Time
	left_at          *time.Time
	clearedFields    map[string]struct{}
	classroom        *int
	clearedclassroom bool
	student          *int
	clearedstudent   bool
	done             bool
	oldValue         func(context.Context) (*ClassroomMembership, error)
	predicates       []predicate.ClassroomMembership
}

var _ ent.Mutation = (*ClassroomMembershipMutation)(nil)

// classroommembershipOption allows management of the mutation configuration using functional options.
type classroommembershipOption func(*ClassroomMembershipMutation)

// newClassroomMembershipMutation creates new mutation for the ClassroomMembership entity.
func newClassroomMembershipMutation(c config, op Op, opts ...classroommembershipOption) *ClassroomMembershipMutation {
	m := &ClassroomMembershipMutation{
		config:        c,
		op:            op,
		typ:           TypeClassroomMembership,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassroomMembershipID sets the ID field of the mutation.
func withClassroomMembershipID(id int) classroommembershipOption {
	return func(m *ClassroomMembershipMutation) {
		var (
			err   error
			once  sync.Once
			value *ClassroomMembership
		)
		m.oldValue = func(ctx context.Context) (*ClassroomMembership, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClassroomMembership.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClassroomMembership sets the old ClassroomMembership of the mutation.
func withClassroomMembership(node *ClassroomMembership) classroommembershipOption {
	return func(m *ClassroomMembershipMutation) {
		m.oldValue = func(context.Context) (*ClassroomMembership, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassroomMembershipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassroomMembershipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassroomMembershipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassroomMembershipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClassroomMembership.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *ClassroomMembershipMutation) SetStatus(c classroommembership.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ClassroomMembershipMutation) Status() (r classroommembership.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ClassroomMembership entity.
// If the ClassroomMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomMembershipMutation) OldStatus(ctx context.Context) (v classroommembership.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ClassroomMembershipMutation) ResetStatus() {
	m.status = nil
}

// SetJoinedAt sets the "joined_at" field.
func (m *ClassroomMembershipMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *ClassroomMembershipMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the ClassroomMembership entity.
// If the ClassroomMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomMembershipMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *ClassroomMembershipMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// SetLeftAt sets the "left_at" field.
func (m *ClassroomMembershipMutation) SetLeftAt(t time.Time) {
	m.left_at = &t
}

// LeftAt returns the value of the "left_at" field in the mutation.
func (m *ClassroomMembershipMutation) LeftAt() (r time.Time, exists bool) {
	v := m.left_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLeftAt returns the old "left_at" field's value of the ClassroomMembership entity.
// If the ClassroomMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomMembershipMutation) OldLeftAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeftAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeftAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeftAt: %w", err)
	}
	return oldValue.LeftAt, nil
}

// ClearLeftAt clears the value of the "left_at" field.
func (m *ClassroomMembershipMutation) ClearLeftAt() {
	m.left_at = nil
	m.clearedFields[classroommembership.FieldLeftAt] = struct{}{}
}

// LeftAtCleared returns if the "left_at" field was cleared in this mutation.
func (m *ClassroomMembershipMutation) LeftAtCleared() bool {
	_, ok := m.clearedFields[classroommembership.FieldLeftAt]
	return ok
}

// ResetLeftAt resets all changes to the "left_at" field.
func (m *ClassroomMembershipMutation) ResetLeftAt() {
	m.left_at = nil
	delete(m.clearedFields, classroommembership.FieldLeftAt)
}

// SetClassroomID sets the "classroom" edge to the Classroom entity by id.
func (m *ClassroomMembershipMutation) SetClassroomID(id int) {
	m.classroom = &id
}

// ClearClassroom clears the "classroom" edge to the Classroom entity.
func (m *ClassroomMembershipMutation) ClearClassroom() {
	m.clearedclassroom = true
}

// ClassroomCleared reports if the "classroom" edge to the Classroom entity was cleared.
func (m *ClassroomMembershipMutation) ClassroomCleared() bool {
	return m.clearedclassroom
}

// ClassroomID returns the "classroom" edge ID in the mutation.
func (m *ClassroomMembershipMutation) ClassroomID() (id int, exists bool) {
	if m.classroom != nil {
		return *m.classroom, true
	}
	return
}

// ClassroomIDs returns the "classroom" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassroomID instead. It exists only for internal usage by the builders.
func (m *ClassroomMembershipMutation) ClassroomIDs() (ids []int) {
	if id := m.classroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassroom resets all changes to the "classroom" edge.
func (m *ClassroomMembershipMutation) ResetClassroom() {
	m.classroom = nil
	m.clearedclassroom = false
}

// SetStudentID sets the "student" edge to the User entity by id.
func (m *ClassroomMembershipMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the User entity.
func (m *ClassroomMembershipMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the User entity was cleared.
func (m *ClassroomMembershipMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *ClassroomMembershipMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *ClassroomMembershipMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *ClassroomMembershipMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the ClassroomMembershipMutation builder.
func (m *ClassroomMembershipMutation) Where(ps ...predicate.ClassroomMembership) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassroomMembershipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassroomMembershipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ClassroomMembership, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassroomMembershipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassroomMembershipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ClassroomMembership).
func (m *ClassroomMembershipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassroomMembershipMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, classroommembership.FieldStatus)
	}
	if m.joined_at != nil {
		fields = append(fields, classroommembership.FieldJoinedAt)
	}
	if m.left_at != nil {
		fields = append(fields, classroommembership.FieldLeftAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassroomMembershipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case classroommembership.FieldStatus:
		return m.Status()
	case classroommembership.FieldJoinedAt:
		return m.JoinedAt()
	case classroommembership.FieldLeftAt:
		return m.LeftAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassroomMembershipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case classroommembership.FieldStatus:
		return m.OldStatus(ctx)
	case classroommembership.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case classroommembership.FieldLeftAt:
		return m.OldLeftAt(ctx)
	}
	return nil, fmt.Errorf("unknown ClassroomMembership field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassroomMembershipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case classroommembership.FieldStatus:
		v, ok := value.(classroommembership.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case classroommembership.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case classroommembership.FieldLeftAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeftAt(v)
		return nil
	}
	return fmt.Errorf("unknown ClassroomMembership field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassroomMembershipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassroomMembershipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassroomMembershipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClassroomMembership numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassroomMembershipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(classroommembership.FieldLeftAt) {
		fields = append(fields, classroommembership.FieldLeftAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassroomMembershipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassroomMembershipMutation) ClearField(name string) error {
	switch name {
	case classroommembership.FieldLeftAt:
		m.ClearLeftAt()
		return nil
	}
	return fmt.Errorf("unknown ClassroomMembership nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassroomMembershipMutation) ResetField(name string) error {
	switch name {
	case classroommembership.FieldStatus:
		m.ResetStatus()
		return nil
	case classroommembership.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case classroommembership.FieldLeftAt:
		m.ResetLeftAt()
		return nil
	}
	return fmt.Errorf("unknown ClassroomMembership field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassroomMembershipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.classroom != nil {
		edges = append(edges, classroommembership.EdgeClassroom)
	}
	if m.student != nil {
		edges = append(edges, classroommembership.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassroomMembershipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case classroommembership.EdgeClassroom:
		if id := m.classroom; id != nil {
			return []ent.Value{*id}
		}
	case classroommembership.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassroomMembershipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassroomMembershipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassroomMembershipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclassroom {
		edges = append(edges, classroommembership.EdgeClassroom)
	}
	if m.clearedstudent {
		edges = append(edges, classroommembership.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassroomMembershipMutation) EdgeCleared(name string) bool {
	switch name {
	case classroommembership.EdgeClassroom:
		return m.clearedclassroom
	case classroommembership.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassroomMembershipMutation) ClearEdge(name string) error {
	switch name {
	case classroommembership.EdgeClassroom:
		m.ClearClassroom()
		return nil
	case classroommembership.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown ClassroomMembership unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassroomMembershipMutation) ResetEdge(name string) error {
	switch name {
	case classroommembership.EdgeClassroom:
		m.ResetClassroom()
		return nil
	case classroommembership.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown ClassroomMembership edge %s", name)
}

// ClassroomSessionMutation represents an operation that mutates the ClassroomSession nodes in the graph.
type ClassroomSessionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	room_code        *string
	role             *classroomsession.Role
	status           *classroomsession.Status
	expires_at       *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	app              *int
	clearedapp       bool
	user             *int
	cleareduser      bool
	classroom        *int
	clearedclassroom bool
	done             bool
	oldValue         func(context.Context) (*ClassroomSession, error)
	predicates       []predicate.ClassroomSession
}

var _ ent.Mutation = (*ClassroomSessionMutation)(nil)

// classroomsessionOption allows management of the mutation configuration using functional options.
type classroomsessionOption func(*ClassroomSessionMutation)

// newClassroomSessionMutation creates new mutation for the ClassroomSession entity.
func newClassroomSessionMutation(c config, op Op, opts ...classroomsessionOption) *ClassroomSessionMutation {
	m := &ClassroomSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeClassroomSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassroomSessionID sets the ID field of the mutation.
func withClassroomSessionID(id int) classroomsessionOption {
	return func(m *ClassroomSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *ClassroomSession
		)
		m.oldValue = func(ctx context.Context) (*ClassroomSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClassroomSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClassroomSession sets the old ClassroomSession of the mutation.
func withClassroomSession(node *ClassroomSession) classroomsessionOption {
	return func(m *ClassroomSessionMutation) {
		m.oldValue = func(context.Context) (*ClassroomSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassroomSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassroomSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassroomSessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassroomSessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClassroomSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoomCode sets the "room_code" field.
func (m *ClassroomSessionMutation) SetRoomCode(s string) {
	m.room_code = &s
}

// RoomCode returns the value of the "room_code" field in the mutation.
func (m *ClassroomSessionMutation) RoomCode() (r string, exists bool) {
	v := m.room_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomCode returns the old "room_code" field's value of the ClassroomSession entity.
// If the ClassroomSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomSessionMutation) OldRoomCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomCode: %w", err)
	}
	return oldValue.RoomCode, nil
}

// ResetRoomCode resets all changes to the "room_code" field.
func (m *ClassroomSessionMutation) ResetRoomCode() {
	m.room_code = nil
}

// SetRole sets the "role" field.
func (m *ClassroomSessionMutation) SetRole(c classroomsession.Role) {
	m.role = &c
}

// Role returns the value of the "role" field in the mutation.
func (m *ClassroomSessionMutation) Role() (r classroomsession.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the ClassroomSession entity.
// If the ClassroomSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomSessionMutation) OldRole(ctx context.Context) (v classroomsession.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *ClassroomSessionMutation) ResetRole() {
	m.role = nil
}

// SetStatus sets the "status" field.
func (m *ClassroomSessionMutation) SetStatus(c classroomsession.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ClassroomSessionMutation) Status() (r classroomsession.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ClassroomSession entity.
// If the ClassroomSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomSessionMutation) OldStatus(ctx context.Context) (v classroomsession.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ClassroomSessionMutation) ResetStatus() {
	m.status = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *ClassroomSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ClassroomSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ClassroomSession entity.
// If the ClassroomSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ClassroomSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ClassroomSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClassroomSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ClassroomSession entity.
// If the ClassroomSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClassroomSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClassroomSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClassroomSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ClassroomSession entity.
// If the ClassroomSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassroomSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClassroomSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *ClassroomSessionMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *ClassroomSessionMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *ClassroomSessionMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *ClassroomSessionMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *ClassroomSessionMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *ClassroomSessionMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ClassroomSessionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ClassroomSessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ClassroomSessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ClassroomSessionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ClassroomSessionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ClassroomSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetClassroomID sets the "classroom" edge to the Classroom entity by id.
func (m *ClassroomSessionMutation) SetClassroomID(id int) {
	m.classroom = &id
}

// ClearClassroom clears the "classroom" edge to the Classroom entity.
func (m *ClassroomSessionMutation) ClearClassroom() {
	m.clearedclassroom = true
}

// ClassroomCleared reports if the "classroom" edge to the Classroom entity was cleared.
func (m *ClassroomSessionMutation) ClassroomCleared() bool {
	return m.clearedclassroom
}

// ClassroomID returns the "classroom" edge ID in the mutation.
func (m *ClassroomSessionMutation) ClassroomID() (id int, exists bool) {
	if m.classroom != nil {
		return *m.classroom, true
	}
	return
}

// ClassroomIDs returns the "classroom" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassroomID instead. It exists only for internal usage by the builders.
func (m *ClassroomSessionMutation) ClassroomIDs() (ids []int) {
	if id := m.classroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassroom resets all changes to the "classroom" edge.
func (m *ClassroomSessionMutation) ResetClassroom() {
	m.classroom = nil
	m.clearedclassroom = false
}

// Where appends a list predicates to the ClassroomSessionMutation builder.
func (m *ClassroomSessionMutation) Where(ps ...predicate.ClassroomSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassroomSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassroomSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ClassroomSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassroomSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassroomSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ClassroomSession).
func (m *ClassroomSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassroomSessionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.room_code != nil {
		fields = append(fields, classroomsession.FieldRoomCode)
	}
	if m.role != nil {
		fields = append(fields, classroomsession.FieldRole)
	}
	if m.status != nil {
		fields = append(fields, classroomsession.FieldStatus)
	}
	if m.expires_at != nil {
		fields = append(fields, classroomsession.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, classroomsession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, classroomsession.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassroomSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case classroomsession.FieldRoomCode:
		return m.RoomCode()
	case classroomsession.FieldRole:
		return m.Role()
	case classroomsession.FieldStatus:
		return m.Status()
	case classroomsession.FieldExpiresAt:
		return m.ExpiresAt()
	case classroomsession.FieldCreatedAt:
		return m.CreatedAt()
	case classroomsession.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassroomSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case classroomsession.FieldRoomCode:
		return m.OldRoomCode(ctx)
	case classroomsession.FieldRole:
		return m.OldRole(ctx)
	case classroomsession.FieldStatus:
		return m.OldStatus(ctx)
	case classroomsession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case classroomsession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case classroomsession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ClassroomSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassroomSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case classroomsession.FieldRoomCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomCode(v)
		return nil
	case classroomsession.FieldRole:
		v, ok := value.(classroomsession.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case classroomsession.FieldStatus:
		v, ok := value.(classroomsession.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case classroomsession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case classroomsession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case classroomsession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ClassroomSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassroomSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassroomSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassroomSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClassroomSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassroomSessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassroomSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassroomSessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClassroomSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassroomSessionMutation) ResetField(name string) error {
	switch name {
	case classroomsession.FieldRoomCode:
		m.ResetRoomCode()
		return nil
	case classroomsession.FieldRole:
		m.ResetRole()
		return nil
	case classroomsession.FieldStatus:
		m.ResetStatus()
		return nil
	case classroomsession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case classroomsession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case classroomsession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ClassroomSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassroomSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.app != nil {
		edges = append(edges, classroomsession.EdgeApp)
	}
	if m.user != nil {
		edges = append(edges, classroomsession.EdgeUser)
	}
	if m.classroom != nil {
		edges = append(edges, classroomsession.EdgeClassroom)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassroomSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case classroomsession.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case classroomsession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case classroomsession.EdgeClassroom:
		if id := m.classroom; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassroomSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassroomSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassroomSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapp {
		edges = append(edges, classroomsession.EdgeApp)
	}
	if m.cleareduser {
		edges = append(edges, classroomsession.EdgeUser)
	}
	if m.clearedclassroom {
		edges = append(edges, classroomsession.EdgeClassroom)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassroomSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case classroomsession.EdgeApp:
		return m.clearedapp
	case classroomsession.EdgeUser:
		return m.cleareduser
	case classroomsession.EdgeClassroom:
		return m.clearedclassroom
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassroomSessionMutation) ClearEdge(name string) error {
	switch name {
	case classroomsession.EdgeApp:
		m.ClearApp()
		return nil
	case classroomsession.EdgeUser:
		m.ClearUser()
		return nil
	case classroomsession.EdgeClassroom:
		m.ClearClassroom()
		return nil
	}
	return fmt.Errorf("unknown ClassroomSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassroomSessionMutation) ResetEdge(name string) error {
	switch name {
	case classroomsession.EdgeApp:
		m.ResetApp()
		return nil
	case classroomsession.EdgeUser:
		m.ResetUser()
		return nil
	case classroomsession.EdgeClassroom:
		m.ResetClassroom()
		return nil
	}
	return fmt.Errorf("unknown ClassroomSession edge %s", name)
}

// EmailTemplateMutation represents an operation that mutates the EmailTemplate nodes in the graph.
type EmailTemplateMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	description     *string
	subject         *string
	body_html       *string
	body_text       *string
	variables       *[]string
	appendvariables []string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	app             *int
	clearedapp      bool
	done            bool
	oldValue        func(context.Context) (*EmailTemplate, error)
	predicates      []predicate.EmailTemplate
}

var _ ent.Mutation = (*EmailTemplateMutation)(nil)

// emailtemplateOption allows management of the mutation configuration using functional options.
type emailtemplateOption func(*EmailTemplateMutation)

// newEmailTemplateMutation creates new mutation for the EmailTemplate entity.
func newEmailTemplateMutation(c config, op Op, opts ...emailtemplateOption) *EmailTemplateMutation {
	m := &EmailTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailTemplateID sets the ID field of the mutation.
func withEmailTemplateID(id int) emailtemplateOption {
	return func(m *EmailTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailTemplate
		)
		m.oldValue = func(ctx context.Context) (*EmailTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailTemplate sets the old EmailTemplate of the mutation.
func withEmailTemplate(node *EmailTemplate) emailtemplateOption {
	return func(m *EmailTemplateMutation) {
		m.oldValue = func(context.Context) (*EmailTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailTemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailTemplateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EmailTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmailTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmailTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EmailTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EmailTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EmailTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[emailtemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EmailTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EmailTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, emailtemplate.FieldDescription)
}

// SetSubject sets the "subject" field.
func (m *EmailTemplateMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *EmailTemplateMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *EmailTemplateMutation) ResetSubject() {
	m.subject = nil
}

// SetBodyHTML sets the "body_html" field.
func (m *EmailTemplateMutation) SetBodyHTML(s string) {
	m.body_html = &s
}

// BodyHTML returns the value of the "body_html" field in the mutation.
func (m *EmailTemplateMutation) BodyHTML() (r string, exists bool) {
	v := m.body_html
	if v == nil {
		return
	}
	return *v, true
}

// OldBodyHTML returns the old "body_html" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldBodyHTML(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBodyHTML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBodyHTML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBodyHTML: %w", err)
	}
	return oldValue.BodyHTML, nil
}

// ClearBodyHTML clears the value of the "body_html" field.
func (m *EmailTemplateMutation) ClearBodyHTML() {
	m.body_html = nil
	m.clearedFields[emailtemplate.FieldBodyHTML] = struct{}{}
}

// BodyHTMLCleared returns if the "body_html" field was cleared in this mutation.
func (m *EmailTemplateMutation) BodyHTMLCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldBodyHTML]
	return ok
}

// ResetBodyHTML resets all changes to the "body_html" field.
func (m *EmailTemplateMutation) ResetBodyHTML() {
	m.body_html = nil
	delete(m.clearedFields, emailtemplate.FieldBodyHTML)
}

// SetBodyText sets the "body_text" field.
func (m *EmailTemplateMutation) SetBodyText(s string) {
	m.body_text = &s
}

// BodyText returns the value of the "body_text" field in the mutation.
func (m *EmailTemplateMutation) BodyText() (r string, exists bool) {
	v := m.body_text
	if v == nil {
		return
	}
	return *v, true
}

// OldBodyText returns the old "body_text" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldBodyText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBodyText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBodyText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBodyText: %w", err)
	}
	return oldValue.BodyText, nil
}

// ClearBodyText clears the value of the "body_text" field.
func (m *EmailTemplateMutation) ClearBodyText() {
	m.body_text = nil
	m.clearedFields[emailtemplate.FieldBodyText] = struct{}{}
}

// BodyTextCleared returns if the "body_text" field was cleared in this mutation.
func (m *EmailTemplateMutation) BodyTextCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldBodyText]
	return ok
}

// ResetBodyText resets all changes to the "body_text" field.
func (m *EmailTemplateMutation) ResetBodyText() {
	m.body_text = nil
	delete(m.clearedFields, emailtemplate.FieldBodyText)
}

// SetVariables sets the "variables" field.
func (m *EmailTemplateMutation) SetVariables(s []string) {
	m.variables = &s
	m.appendvariables = nil
}

// Variables returns the value of the "variables" field in the mutation.
func (m *EmailTemplateMutation) Variables() (r []string, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldVariables(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// AppendVariables adds s to the "variables" field.
func (m *EmailTemplateMutation) AppendVariables(s []string) {
	m.appendvariables = append(m.appendvariables, s...)
}

// AppendedVariables returns the list of values that were appended to the "variables" field in this mutation.
func (m *EmailTemplateMutation) AppendedVariables() ([]string, bool) {
	if len(m.appendvariables) == 0 {
		return nil, false
	}
	return m.appendvariables, true
}

// ClearVariables clears the value of the "variables" field.
func (m *EmailTemplateMutation) ClearVariables() {
	m.variables = nil
	m.appendvariables = nil
	m.clearedFields[emailtemplate.FieldVariables] = struct{}{}
}

// VariablesCleared returns if the "variables" field was cleared in this mutation.
func (m *EmailTemplateMutation) VariablesCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldVariables]
	return ok
}

// ResetVariables resets all changes to the "variables" field.
func (m *EmailTemplateMutation) ResetVariables() {
	m.variables = nil
	m.appendvariables = nil
	delete(m.clearedFields, emailtemplate.FieldVariables)
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *EmailTemplateMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *EmailTemplateMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *EmailTemplateMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *EmailTemplateMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *EmailTemplateMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *EmailTemplateMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the EmailTemplateMutation builder.
func (m *EmailTemplateMutation) Where(ps ...predicate.EmailTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailTemplate).
func (m *EmailTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailTemplateMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, emailtemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, emailtemplate.FieldDescription)
	}
	if m.subject != nil {
		fields = append(fields, emailtemplate.FieldSubject)
	}
	if m.body_html != nil {
		fields = append(fields, emailtemplate.FieldBodyHTML)
	}
	if m.body_text != nil {
		fields = append(fields, emailtemplate.FieldBodyText)
	}
	if m.variables != nil {
		fields = append(fields, emailtemplate.FieldVariables)
	}
	if m.created_at != nil {
		fields = append(fields, emailtemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailtemplate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailtemplate.FieldName:
		return m.Name()
	case emailtemplate.FieldDescription:
		return m.Description()
	case emailtemplate.FieldSubject:
		return m.Subject()
	case emailtemplate.FieldBodyHTML:
		return m.BodyHTML()
	case emailtemplate.FieldBodyText:
		return m.BodyText()
	case emailtemplate.FieldVariables:
		return m.Variables()
	case emailtemplate.FieldCreatedAt:
		return m.CreatedAt()
	case emailtemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailtemplate.FieldName:
		return m.OldName(ctx)
	case emailtemplate.FieldDescription:
		return m.OldDescription(ctx)
	case emailtemplate.FieldSubject:
		return m.OldSubject(ctx)
	case emailtemplate.FieldBodyHTML:
		return m.OldBodyHTML(ctx)
	case emailtemplate.FieldBodyText:
		return m.OldBodyText(ctx)
	case emailtemplate.FieldVariables:
		return m.OldVariables(ctx)
	case emailtemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailtemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailtemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case emailtemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case emailtemplate.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case emailtemplate.FieldBodyHTML:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBodyHTML(v)
		return nil
	case emailtemplate.FieldBodyText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBodyText(v)
		return nil
	case emailtemplate.FieldVariables:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case emailtemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailtemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailtemplate.FieldDescription) {
		fields = append(fields, emailtemplate.FieldDescription)
	}
	if m.FieldCleared(emailtemplate.FieldBodyHTML) {
		fields = append(fields, emailtemplate.FieldBodyHTML)
	}
	if m.FieldCleared(emailtemplate.FieldBodyText) {
		fields = append(fields, emailtemplate.FieldBodyText)
	}
	if m.FieldCleared(emailtemplate.FieldVariables) {
		fields = append(fields, emailtemplate.FieldVariables)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailTemplateMutation) ClearField(name string) error {
	switch name {
	case emailtemplate.FieldDescription:
		m.ClearDescription()
		return nil
	case emailtemplate.FieldBodyHTML:
		m.ClearBodyHTML()
		return nil
	case emailtemplate.FieldBodyText:
		m.ClearBodyText()
		return nil
	case emailtemplate.FieldVariables:
		m.ClearVariables()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailTemplateMutation) ResetField(name string) error {
	switch name {
	case emailtemplate.FieldName:
		m.ResetName()
		return nil
	case emailtemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case emailtemplate.FieldSubject:
		m.ResetSubject()
		return nil
	case emailtemplate.FieldBodyHTML:
		m.ResetBodyHTML()
		return nil
	case emailtemplate.FieldBodyText:
		m.ResetBodyText()
		return nil
	case emailtemplate.FieldVariables:
		m.ResetVariables()
		return nil
	case emailtemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailtemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.app != nil {
		edges = append(edges, emailtemplate.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailtemplate.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapp {
		edges = append(edges, emailtemplate.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case emailtemplate.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailTemplateMutation) ClearEdge(name string) error {
	switch name {
	case emailtemplate.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailTemplateMutation) ResetEdge(name string) error {
	switch name {
	case emailtemplate.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate edge %s", name)
}

// LiveSessionMutation represents an operation that mutates the LiveSession nodes in the graph.
type LiveSessionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	room_code        *string
	status           *livesession.Status
	level            *map[string]interface{}
	started_at       *time.Time
	ended_at         *time.Time
	expires_at       *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	app              *int
	clearedapp       bool
	classroom        *int
	clearedclassroom bool
	teacher          *int
	clearedteacher   bool
	students         map[int]struct{}
	removedstudents  map[int]struct{}
	clearedstudents  bool
	done             bool
	oldValue         func(context.Context) (*LiveSession, error)
	predicates       []predicate.LiveSession
}

var _ ent.Mutation = (*LiveSessionMutation)(nil)

// livesessionOption allows management of the mutation configuration using functional options.
type livesessionOption func(*LiveSessionMutation)

// newLiveSessionMutation creates new mutation for the LiveSession entity.
func newLiveSessionMutation(c config, op Op, opts ...livesessionOption) *LiveSessionMutation {
	m := &LiveSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeLiveSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLiveSessionID sets the ID field of the mutation.
func withLiveSessionID(id int) livesessionOption {
	return func(m *LiveSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *LiveSession
		)
		m.oldValue = func(ctx context.Context) (*LiveSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LiveSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLiveSession sets the old LiveSession of the mutation.
func withLiveSession(node *LiveSession) livesessionOption {
	return func(m *LiveSessionMutation) {
		m.oldValue = func(context.Context) (*LiveSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LiveSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LiveSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LiveSessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LiveSessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LiveSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoomCode sets the "room_code" field.
func (m *LiveSessionMutation) SetRoomCode(s string) {
	m.room_code = &s
}

// RoomCode returns the value of the "room_code" field in the mutation.
func (m *LiveSessionMutation) RoomCode() (r string, exists bool) {
	v := m.room_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomCode returns the old "room_code" field's value of the LiveSession entity.
// If the LiveSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionMutation) OldRoomCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomCode: %w", err)
	}
	return oldValue.RoomCode, nil
}

// ResetRoomCode resets all changes to the "room_code" field.
func (m *LiveSessionMutation) ResetRoomCode() {
	m.room_code = nil
}

// SetStatus sets the "status" field.
func (m *LiveSessionMutation) SetStatus(l livesession.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LiveSessionMutation) Status() (r livesession.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the LiveSession entity.
// If the LiveSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionMutation) OldStatus(ctx context.Context) (v livesession.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LiveSessionMutation) ResetStatus() {
	m.status = nil
}

// SetLevel sets the "level" field.
func (m *LiveSessionMutation) SetLevel(value map[string]interface{}) {
	m.level = &value
}

// Level returns the value of the "level" field in the mutation.
func (m *LiveSessionMutation) Level() (r map[string]interface{}, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the LiveSession entity.
// If the LiveSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionMutation) OldLevel(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ClearLevel clears the value of the "level" field.
func (m *LiveSessionMutation) ClearLevel() {
	m.level = nil
	m.clearedFields[livesession.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *LiveSessionMutation) LevelCleared() bool {
	_, ok := m.clearedFields[livesession.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *LiveSessionMutation) ResetLevel() {
	m.level = nil
	delete(m.clearedFields, livesession.FieldLevel)
}

// SetStartedAt sets the "started_at" field.
func (m *LiveSessionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *LiveSessionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the LiveSession entity.
// If the LiveSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *LiveSessionMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[livesession.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *LiveSessionMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[livesession.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *LiveSessionMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, livesession.FieldStartedAt)
}

// SetEndedAt sets the "ended_at" field.
func (m *LiveSessionMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *LiveSessionMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the LiveSession entity.
// If the LiveSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionMutation) OldEndedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *LiveSessionMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[livesession.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *LiveSessionMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[livesession.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *LiveSessionMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, livesession.FieldEndedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *LiveSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *LiveSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the LiveSession entity.
// If the LiveSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *LiveSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LiveSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LiveSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LiveSession entity.
// If the LiveSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LiveSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LiveSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LiveSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LiveSession entity.
// If the LiveSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LiveSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *LiveSessionMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *LiveSessionMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *LiveSessionMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *LiveSessionMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *LiveSessionMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *LiveSessionMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetClassroomID sets the "classroom" edge to the Classroom entity by id.
func (m *LiveSessionMutation) SetClassroomID(id int) {
	m.classroom = &id
}

// ClearClassroom clears the "classroom" edge to the Classroom entity.
func (m *LiveSessionMutation) ClearClassroom() {
	m.clearedclassroom = true
}

// ClassroomCleared reports if the "classroom" edge to the Classroom entity was cleared.
func (m *LiveSessionMutation) ClassroomCleared() bool {
	return m.clearedclassroom
}

// ClassroomID returns the "classroom" edge ID in the mutation.
func (m *LiveSessionMutation) ClassroomID() (id int, exists bool) {
	if m.classroom != nil {
		return *m.classroom, true
	}
	return
}

// ClassroomIDs returns the "classroom" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassroomID instead. It exists only for internal usage by the builders.
func (m *LiveSessionMutation) ClassroomIDs() (ids []int) {
	if id := m.classroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassroom resets all changes to the "classroom" edge.
func (m *LiveSessionMutation) ResetClassroom() {
	m.classroom = nil
	m.clearedclassroom = false
}

// SetTeacherID sets the "teacher" edge to the User entity by id.
func (m *LiveSessionMutation) SetTeacherID(id int) {
	m.teacher = &id
}

// ClearTeacher clears the "teacher" edge to the User entity.
func (m *LiveSessionMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared reports if the "teacher" edge to the User entity was cleared.
func (m *LiveSessionMutation) TeacherCleared() bool {
	return m.clearedteacher
}

// TeacherID returns the "teacher" edge ID in the mutation.
func (m *LiveSessionMutation) TeacherID() (id int, exists bool) {
	if m.teacher != nil {
		return *m.teacher, true
	}
	return
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *LiveSessionMutation) TeacherIDs() (ids []int) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *LiveSessionMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// AddStudentIDs adds the "students" edge to the LiveSessionStudent entity by ids.
func (m *LiveSessionMutation) AddStudentIDs(ids ...int) {
	if m.students == nil {
		m.students = make(map[int]struct{})
	}
	for i := range ids {
		m.students[ids[i]] = struct{}{}
	}
}

// ClearStudents clears the "students" edge to the LiveSessionStudent entity.
func (m *LiveSessionMutation) ClearStudents() {
	m.clearedstudents = true
}

// StudentsCleared reports if the "students" edge to the LiveSessionStudent entity was cleared.
func (m *LiveSessionMutation) StudentsCleared() bool {
	return m.clearedstudents
}

// RemoveStudentIDs removes the "students" edge to the LiveSessionStudent entity by IDs.
func (m *LiveSessionMutation) RemoveStudentIDs(ids ...int) {
	if m.removedstudents == nil {
		m.removedstudents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.students, ids[i])
		m.removedstudents[ids[i]] = struct{}{}
	}
}

// RemovedStudents returns the removed IDs of the "students" edge to the LiveSessionStudent entity.
func (m *LiveSessionMutation) RemovedStudentsIDs() (ids []int) {
	for id := range m.removedstudents {
		ids = append(ids, id)
	}
	return
}

// StudentsIDs returns the "students" edge IDs in the mutation.
func (m *LiveSessionMutation) StudentsIDs() (ids []int) {
	for id := range m.students {
		ids = append(ids, id)
	}
	return
}

// ResetStudents resets all changes to the "students" edge.
func (m *LiveSessionMutation) ResetStudents() {
	m.students = nil
	m.clearedstudents = false
	m.removedstudents = nil
}

// Where appends a list predicates to the LiveSessionMutation builder.
func (m *LiveSessionMutation) Where(ps ...predicate.LiveSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LiveSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LiveSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LiveSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LiveSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LiveSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LiveSession).
func (m *LiveSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LiveSessionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.room_code != nil {
		fields = append(fields, livesession.FieldRoomCode)
	}
	if m.status != nil {
		fields = append(fields, livesession.FieldStatus)
	}
	if m.level != nil {
		fields = append(fields, livesession.FieldLevel)
	}
	if m.started_at != nil {
		fields = append(fields, livesession.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, livesession.FieldEndedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, livesession.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, livesession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, livesession.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LiveSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case livesession.FieldRoomCode:
		return m.RoomCode()
	case livesession.FieldStatus:
		return m.Status()
	case livesession.FieldLevel:
		return m.Level()
	case livesession.FieldStartedAt:
		return m.StartedAt()
	case livesession.FieldEndedAt:
		return m.EndedAt()
	case livesession.FieldExpiresAt:
		return m.ExpiresAt()
	case livesession.FieldCreatedAt:
		return m.CreatedAt()
	case livesession.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LiveSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case livesession.FieldRoomCode:
		return m.OldRoomCode(ctx)
	case livesession.FieldStatus:
		return m.OldStatus(ctx)
	case livesession.FieldLevel:
		return m.OldLevel(ctx)
	case livesession.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case livesession.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case livesession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case livesession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case livesession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LiveSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LiveSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case livesession.FieldRoomCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomCode(v)
		return nil
	case livesession.FieldStatus:
		v, ok := value.(livesession.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case livesession.FieldLevel:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case livesession.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case livesession.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case livesession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case livesession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case livesession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LiveSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LiveSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LiveSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LiveSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LiveSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LiveSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(livesession.FieldLevel) {
		fields = append(fields, livesession.FieldLevel)
	}
	if m.FieldCleared(livesession.FieldStartedAt) {
		fields = append(fields, livesession.FieldStartedAt)
	}
	if m.FieldCleared(livesession.FieldEndedAt) {
		fields = append(fields, livesession.FieldEndedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LiveSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LiveSessionMutation) ClearField(name string) error {
	switch name {
	case livesession.FieldLevel:
		m.ClearLevel()
		return nil
	case livesession.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case livesession.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	}
	return fmt.Errorf("unknown LiveSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LiveSessionMutation) ResetField(name string) error {
	switch name {
	case livesession.FieldRoomCode:
		m.ResetRoomCode()
		return nil
	case livesession.FieldStatus:
		m.ResetStatus()
		return nil
	case livesession.FieldLevel:
		m.ResetLevel()
		return nil
	case livesession.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case livesession.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case livesession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case livesession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case livesession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown LiveSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LiveSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.app != nil {
		edges = append(edges, livesession.EdgeApp)
	}
	if m.classroom != nil {
		edges = append(edges, livesession.EdgeClassroom)
	}
	if m.teacher != nil {
		edges = append(edges, livesession.EdgeTeacher)
	}
	if m.students != nil {
		edges = append(edges, livesession.EdgeStudents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LiveSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case livesession.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case livesession.EdgeClassroom:
		if id := m.classroom; id != nil {
			return []ent.Value{*id}
		}
	case livesession.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	case livesession.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.students))
		for id := range m.students {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LiveSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedstudents != nil {
		edges = append(edges, livesession.EdgeStudents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LiveSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case livesession.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.removedstudents))
		for id := range m.removedstudents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LiveSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedapp {
		edges = append(edges, livesession.EdgeApp)
	}
	if m.clearedclassroom {
		edges = append(edges, livesession.EdgeClassroom)
	}
	if m.clearedteacher {
		edges = append(edges, livesession.EdgeTeacher)
	}
	if m.clearedstudents {
		edges = append(edges, livesession.EdgeStudents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LiveSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case livesession.EdgeApp:
		return m.clearedapp
	case livesession.EdgeClassroom:
		return m.clearedclassroom
	case livesession.EdgeTeacher:
		return m.clearedteacher
	case livesession.EdgeStudents:
		return m.clearedstudents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LiveSessionMutation) ClearEdge(name string) error {
	switch name {
	case livesession.EdgeApp:
		m.ClearApp()
		return nil
	case livesession.EdgeClassroom:
		m.ClearClassroom()
		return nil
	case livesession.EdgeTeacher:
		m.ClearTeacher()
		return nil
	}
	return fmt.Errorf("unknown LiveSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LiveSessionMutation) ResetEdge(name string) error {
	switch name {
	case livesession.EdgeApp:
		m.ResetApp()
		return nil
	case livesession.EdgeClassroom:
		m.ResetClassroom()
		return nil
	case livesession.EdgeTeacher:
		m.ResetTeacher()
		return nil
	case livesession.EdgeStudents:
		m.ResetStudents()
		return nil
	}
	return fmt.Errorf("unknown LiveSession edge %s", name)
}

// LiveSessionStudentMutation represents an operation that mutates the LiveSessionStudent nodes in the graph.
type LiveSessionStudentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	student_name       *string
	stars_collected    *int
	addstars_collected *int
	completed          *bool
	completed_at       *time.Time
	code               *string
	joined_at          *time.Time
	left_at            *time.Time
	last_updated_at    *time.Time
	clearedFields      map[string]struct{}
	session            *int
	clearedsession     bool
	student            *int
	clearedstudent     bool
	done               bool
	oldValue           func(context.Context) (*LiveSessionStudent, error)
	predicates         []predicate.LiveSessionStudent
}

var _ ent.Mutation = (*LiveSessionStudentMutation)(nil)

// livesessionstudentOption allows management of the mutation configuration using functional options.
type livesessionstudentOption func(*LiveSessionStudentMutation)

// newLiveSessionStudentMutation creates new mutation for the LiveSessionStudent entity.
func newLiveSessionStudentMutation(c config, op Op, opts ...livesessionstudentOption) *LiveSessionStudentMutation {
	m := &LiveSessionStudentMutation{
		config:        c,
		op:            op,
		typ:           TypeLiveSessionStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLiveSessionStudentID sets the ID field of the mutation.
func withLiveSessionStudentID(id int) livesessionstudentOption {
	return func(m *LiveSessionStudentMutation) {
		var (
			err   error
			once  sync.Once
			value *LiveSessionStudent
		)
		m.oldValue = func(ctx context.Context) (*LiveSessionStudent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LiveSessionStudent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLiveSessionStudent sets the old LiveSessionStudent of the mutation.
func withLiveSessionStudent(node *LiveSessionStudent) livesessionstudentOption {
	return func(m *LiveSessionStudentMutation) {
		m.oldValue = func(context.Context) (*LiveSessionStudent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LiveSessionStudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LiveSessionStudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LiveSessionStudentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LiveSessionStudentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LiveSessionStudent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStudentName sets the "student_name" field.
func (m *LiveSessionStudentMutation) SetStudentName(s string) {
	m.student_name = &s
}

// StudentName returns the value of the "student_name" field in the mutation.
func (m *LiveSessionStudentMutation) StudentName() (r string, exists bool) {
	v := m.student_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStudentName returns the old "student_name" field's value of the LiveSessionStudent entity.
// If the LiveSessionStudent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionStudentMutation) OldStudentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStudentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStudentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudentName: %w", err)
	}
	return oldValue.StudentName, nil
}

// ClearStudentName clears the value of the "student_name" field.
func (m *LiveSessionStudentMutation) ClearStudentName() {
	m.student_name = nil
	m.clearedFields[livesessionstudent.FieldStudentName] = struct{}{}
}

// StudentNameCleared returns if the "student_name" field was cleared in this mutation.
func (m *LiveSessionStudentMutation) StudentNameCleared() bool {
	_, ok := m.clearedFields[livesessionstudent.FieldStudentName]
	return ok
}

// ResetStudentName resets all changes to the "student_name" field.
func (m *LiveSessionStudentMutation) ResetStudentName() {
	m.student_name = nil
	delete(m.clearedFields, livesessionstudent.FieldStudentName)
}

// SetStarsCollected sets the "stars_collected" field.
func (m *LiveSessionStudentMutation) SetStarsCollected(i int) {
	m.stars_collected = &i
	m.addstars_collected = nil
}

// StarsCollected returns the value of the "stars_collected" field in the mutation.
func (m *LiveSessionStudentMutation) StarsCollected() (r int, exists bool) {
	v := m.stars_collected
	if v == nil {
		return
	}
	return *v, true
}

// OldStarsCollected returns the old "stars_collected" field's value of the LiveSessionStudent entity.
// If the LiveSessionStudent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionStudentMutation) OldStarsCollected(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarsCollected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarsCollected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarsCollected: %w", err)
	}
	return oldValue.StarsCollected, nil
}

// AddStarsCollected adds i to the "stars_collected" field.
func (m *LiveSessionStudentMutation) AddStarsCollected(i int) {
	if m.addstars_collected != nil {
		*m.addstars_collected += i
	} else {
		m.addstars_collected = &i
	}
}

// AddedStarsCollected returns the value that was added to the "stars_collected" field in this mutation.
func (m *LiveSessionStudentMutation) AddedStarsCollected() (r int, exists bool) {
	v := m.addstars_collected
	if v == nil {
		return
	}
	return *v, true
}

// ResetStarsCollected resets all changes to the "stars_collected" field.
func (m *LiveSessionStudentMutation) ResetStarsCollected() {
	m.stars_collected = nil
	m.addstars_collected = nil
}

// SetCompleted sets the "completed" field.
func (m *LiveSessionStudentMutation) SetCompleted(b bool) {
	m.completed = &b
}

// Completed returns the value of the "completed" field in the mutation.
func (m *LiveSessionStudentMutation) Completed() (r bool, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the LiveSessionStudent entity.
// If the LiveSessionStudent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionStudentMutation) OldCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ResetCompleted resets all changes to the "completed" field.
func (m *LiveSessionStudentMutation) ResetCompleted() {
	m.completed = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *LiveSessionStudentMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *LiveSessionStudentMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the LiveSessionStudent entity.
// If the LiveSessionStudent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionStudentMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *LiveSessionStudentMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[livesessionstudent.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *LiveSessionStudentMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[livesessionstudent.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *LiveSessionStudentMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, livesessionstudent.FieldCompletedAt)
}

// SetCode sets the "code" field.
func (m *LiveSessionStudentMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *LiveSessionStudentMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the LiveSessionStudent entity.
// If the LiveSessionStudent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionStudentMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *LiveSessionStudentMutation) ClearCode() {
	m.code = nil
	m.clearedFields[livesessionstudent.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *LiveSessionStudentMutation) CodeCleared() bool {
	_, ok := m.clearedFields[livesessionstudent.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *LiveSessionStudentMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, livesessionstudent.FieldCode)
}

// SetJoinedAt sets the "joined_at" field.
func (m *LiveSessionStudentMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *LiveSessionStudentMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the LiveSessionStudent entity.
// If the LiveSessionStudent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionStudentMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *LiveSessionStudentMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// SetLeftAt sets the "left_at" field.
func (m *LiveSessionStudentMutation) SetLeftAt(t time.Time) {
	m.left_at = &t
}

// LeftAt returns the value of the "left_at" field in the mutation.
func (m *LiveSessionStudentMutation) LeftAt() (r time.Time, exists bool) {
	v := m.left_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLeftAt returns the old "left_at" field's value of the LiveSessionStudent entity.
// If the LiveSessionStudent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionStudentMutation) OldLeftAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeftAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeftAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeftAt: %w", err)
	}
	return oldValue.LeftAt, nil
}

// ClearLeftAt clears the value of the "left_at" field.
func (m *LiveSessionStudentMutation) ClearLeftAt() {
	m.left_at = nil
	m.clearedFields[livesessionstudent.FieldLeftAt] = struct{}{}
}

// LeftAtCleared returns if the "left_at" field was cleared in this mutation.
func (m *LiveSessionStudentMutation) LeftAtCleared() bool {
	_, ok := m.clearedFields[livesessionstudent.FieldLeftAt]
	return ok
}

// ResetLeftAt resets all changes to the "left_at" field.
func (m *LiveSessionStudentMutation) ResetLeftAt() {
	m.left_at = nil
	delete(m.clearedFields, livesessionstudent.FieldLeftAt)
}

// SetLastUpdatedAt sets the "last_updated_at" field.
func (m *LiveSessionStudentMutation) SetLastUpdatedAt(t time.Time) {
	m.last_updated_at = &t
}

// LastUpdatedAt returns the value of the "last_updated_at" field in the mutation.
func (m *LiveSessionStudentMutation) LastUpdatedAt() (r time.Time, exists bool) {
	v := m.last_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdatedAt returns the old "last_updated_at" field's value of the LiveSessionStudent entity.
// If the LiveSessionStudent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LiveSessionStudentMutation) OldLastUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdatedAt: %w", err)
	}
	return oldValue.LastUpdatedAt, nil
}

// ResetLastUpdatedAt resets all changes to the "last_updated_at" field.
func (m *LiveSessionStudentMutation) ResetLastUpdatedAt() {
	m.last_updated_at = nil
}

// SetSessionID sets the "session" edge to the LiveSession entity by id.
func (m *LiveSessionStudentMutation) SetSessionID(id int) {
	m.session = &id
}

// ClearSession clears the "session" edge to the LiveSession entity.
func (m *LiveSessionStudentMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the LiveSession entity was cleared.
func (m *LiveSessionStudentMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *LiveSessionStudentMutation) SessionID() (id int, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *LiveSessionStudentMutation) SessionIDs() (ids []int) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *LiveSessionStudentMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// SetStudentID sets the "student" edge to the User entity by id.
func (m *LiveSessionStudentMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the User entity.
func (m *LiveSessionStudentMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the User entity was cleared.
func (m *LiveSessionStudentMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *LiveSessionStudentMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *LiveSessionStudentMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *LiveSessionStudentMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the LiveSessionStudentMutation builder.
func (m *LiveSessionStudentMutation) Where(ps ...predicate.LiveSessionStudent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LiveSessionStudentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LiveSessionStudentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LiveSessionStudent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LiveSessionStudentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LiveSessionStudentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LiveSessionStudent).
func (m *LiveSessionStudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LiveSessionStudentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.student_name != nil {
		fields = append(fields, livesessionstudent.FieldStudentName)
	}
	if m.stars_collected != nil {
		fields = append(fields, livesessionstudent.FieldStarsCollected)
	}
	if m.completed != nil {
		fields = append(fields, livesessionstudent.FieldCompleted)
	}
	if m.completed_at != nil {
		fields = append(fields, livesessionstudent.FieldCompletedAt)
	}
	if m.code != nil {
		fields = append(fields, livesessionstudent.FieldCode)
	}
	if m.joined_at != nil {
		fields = append(fields, livesessionstudent.FieldJoinedAt)
	}
	if m.left_at != nil {
		fields = append(fields, livesessionstudent.FieldLeftAt)
	}
	if m.last_updated_at != nil {
		fields = append(fields, livesessionstudent.FieldLastUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LiveSessionStudentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case livesessionstudent.FieldStudentName:
		return m.StudentName()
	case livesessionstudent.FieldStarsCollected:
		return m.StarsCollected()
	case livesessionstudent.FieldCompleted:
		return m.Completed()
	case livesessionstudent.FieldCompletedAt:
		return m.CompletedAt()
	case livesessionstudent.FieldCode:
		return m.Code()
	case livesessionstudent.FieldJoinedAt:
		return m.JoinedAt()
	case livesessionstudent.FieldLeftAt:
		return m.LeftAt()
	case livesessionstudent.FieldLastUpdatedAt:
		return m.LastUpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LiveSessionStudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case livesessionstudent.FieldStudentName:
		return m.OldStudentName(ctx)
	case livesessionstudent.FieldStarsCollected:
		return m.OldStarsCollected(ctx)
	case livesessionstudent.FieldCompleted:
		return m.OldCompleted(ctx)
	case livesessionstudent.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case livesessionstudent.FieldCode:
		return m.OldCode(ctx)
	case livesessionstudent.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case livesessionstudent.FieldLeftAt:
		return m.OldLeftAt(ctx)
	case livesessionstudent.FieldLastUpdatedAt:
		return m.OldLastUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LiveSessionStudent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LiveSessionStudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case livesessionstudent.FieldStudentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudentName(v)
		return nil
	case livesessionstudent.FieldStarsCollected:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarsCollected(v)
		return nil
	case livesessionstudent.FieldCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	case livesessionstudent.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case livesessionstudent.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case livesessionstudent.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case livesessionstudent.FieldLeftAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeftAt(v)
		return nil
	case livesessionstudent.FieldLastUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LiveSessionStudent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LiveSessionStudentMutation) AddedFields() []string {
	var fields []string
	if m.addstars_collected != nil {
		fields = append(fields, livesessionstudent.FieldStarsCollected)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LiveSessionStudentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case livesessionstudent.FieldStarsCollected:
		return m.AddedStarsCollected()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LiveSessionStudentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case livesessionstudent.FieldStarsCollected:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStarsCollected(v)
		return nil
	}
	return fmt.Errorf("unknown LiveSessionStudent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LiveSessionStudentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(livesessionstudent.FieldStudentName) {
		fields = append(fields, livesessionstudent.FieldStudentName)
	}
	if m.FieldCleared(livesessionstudent.FieldCompletedAt) {
		fields = append(fields, livesessionstudent.FieldCompletedAt)
	}
	if m.FieldCleared(livesessionstudent.FieldCode) {
		fields = append(fields, livesessionstudent.FieldCode)
	}
	if m.FieldCleared(livesessionstudent.FieldLeftAt) {
		fields = append(fields, livesessionstudent.FieldLeftAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LiveSessionStudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LiveSessionStudentMutation) ClearField(name string) error {
	switch name {
	case livesessionstudent.FieldStudentName:
		m.ClearStudentName()
		return nil
	case livesessionstudent.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case livesessionstudent.FieldCode:
		m.ClearCode()
		return nil
	case livesessionstudent.FieldLeftAt:
		m.ClearLeftAt()
		return nil
	}
	return fmt.Errorf("unknown LiveSessionStudent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LiveSessionStudentMutation) ResetField(name string) error {
	switch name {
	case livesessionstudent.FieldStudentName:
		m.ResetStudentName()
		return nil
	case livesessionstudent.FieldStarsCollected:
		m.ResetStarsCollected()
		return nil
	case livesessionstudent.FieldCompleted:
		m.ResetCompleted()
		return nil
	case livesessionstudent.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case livesessionstudent.FieldCode:
		m.ResetCode()
		return nil
	case livesessionstudent.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case livesessionstudent.FieldLeftAt:
		m.ResetLeftAt()
		return nil
	case livesessionstudent.FieldLastUpdatedAt:
		m.ResetLastUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown LiveSessionStudent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LiveSessionStudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.session != nil {
		edges = append(edges, livesessionstudent.EdgeSession)
	}
	if m.student != nil {
		edges = append(edges, livesessionstudent.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LiveSessionStudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case livesessionstudent.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case livesessionstudent.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LiveSessionStudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LiveSessionStudentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LiveSessionStudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsession {
		edges = append(edges, livesessionstudent.EdgeSession)
	}
	if m.clearedstudent {
		edges = append(edges, livesessionstudent.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LiveSessionStudentMutation) EdgeCleared(name string) bool {
	switch name {
	case livesessionstudent.EdgeSession:
		return m.clearedsession
	case livesessionstudent.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LiveSessionStudentMutation) ClearEdge(name string) error {
	switch name {
	case livesessionstudent.EdgeSession:
		m.ClearSession()
		return nil
	case livesessionstudent.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown LiveSessionStudent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LiveSessionStudentMutation) ResetEdge(name string) error {
	switch name {
	case livesessionstudent.EdgeSession:
		m.ResetSession()
		return nil
	case livesessionstudent.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown LiveSessionStudent edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	slug                 *string
	description          *string
	logo_url             *string
	stripe_customer_id   *string
	settings             *map[string]interface{}
	is_active            *bool
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	app                  *int
	clearedapp           bool
	members              map[int]struct{}
	removedmembers       map[int]struct{}
	clearedmembers       bool
	invitations          map[int]struct{}
	removedinvitations   map[int]struct{}
	clearedinvitations   bool
	subscriptions        map[int]struct{}
	removedsubscriptions map[int]struct{}
	clearedsubscriptions bool
	done                 bool
	oldValue             func(context.Context) (*Organization, error)
	predicates           []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *OrganizationMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *OrganizationMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *OrganizationMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *OrganizationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrganizationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrganizationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[organization.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrganizationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[organization.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrganizationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, organization.FieldDescription)
}

// SetLogoURL sets the "logo_url" field.
func (m *OrganizationMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *OrganizationMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *OrganizationMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[organization.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *OrganizationMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[organization.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *OrganizationMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, organization.FieldLogoURL)
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *OrganizationMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *OrganizationMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldStripeCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (m *OrganizationMutation) ClearStripeCustomerID() {
	m.stripe_customer_id = nil
	m.clearedFields[organization.FieldStripeCustomerID] = struct{}{}
}

// StripeCustomerIDCleared returns if the "stripe_customer_id" field was cleared in this mutation.
func (m *OrganizationMutation) StripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldStripeCustomerID]
	return ok
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *OrganizationMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
	delete(m.clearedFields, organization.FieldStripeCustomerID)
}

// SetSettings sets the "settings" field.
func (m *OrganizationMutation) SetSettings(value map[string]interface{}) {
	m.settings = &value
}

// Settings returns the value of the "settings" field in the mutation.
func (m *OrganizationMutation) Settings() (r map[string]interface{}, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *OrganizationMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[organization.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *OrganizationMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[organization.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *OrganizationMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, organization.FieldSettings)
}

// SetIsActive sets the "is_active" field.
func (m *OrganizationMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *OrganizationMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *OrganizationMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *OrganizationMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *OrganizationMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *OrganizationMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *OrganizationMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *OrganizationMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddMemberIDs adds the "members" edge to the OrganizationMember entity by ids.
func (m *OrganizationMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the OrganizationMember entity.
func (m *OrganizationMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the OrganizationMember entity was cleared.
func (m *OrganizationMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the OrganizationMember entity by IDs.
func (m *OrganizationMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the OrganizationMember entity.
func (m *OrganizationMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *OrganizationMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *OrganizationMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddInvitationIDs adds the "invitations" edge to the OrganizationInvitation entity by ids.
func (m *OrganizationMutation) AddInvitationIDs(ids ...int) {
	if m.invitations == nil {
		m.invitations = make(map[int]struct{})
	}
	for i := range ids {
		m.invitations[ids[i]] = struct{}{}
	}
}

// ClearInvitations clears the "invitations" edge to the OrganizationInvitation entity.
func (m *OrganizationMutation) ClearInvitations() {
	m.clearedinvitations = true
}

// InvitationsCleared reports if the "invitations" edge to the OrganizationInvitation entity was cleared.
func (m *OrganizationMutation) InvitationsCleared() bool {
	return m.clearedinvitations
}

// RemoveInvitationIDs removes the "invitations" edge to the OrganizationInvitation entity by IDs.
func (m *OrganizationMutation) RemoveInvitationIDs(ids ...int) {
	if m.removedinvitations == nil {
		m.removedinvitations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.invitations, ids[i])
		m.removedinvitations[ids[i]] = struct{}{}
	}
}

// RemovedInvitations returns the removed IDs of the "invitations" edge to the OrganizationInvitation entity.
func (m *OrganizationMutation) RemovedInvitationsIDs() (ids []int) {
	for id := range m.removedinvitations {
		ids = append(ids, id)
	}
	return
}

// InvitationsIDs returns the "invitations" edge IDs in the mutation.
func (m *OrganizationMutation) InvitationsIDs() (ids []int) {
	for id := range m.invitations {
		ids = append(ids, id)
	}
	return
}

// ResetInvitations resets all changes to the "invitations" edge.
func (m *OrganizationMutation) ResetInvitations() {
	m.invitations = nil
	m.clearedinvitations = false
	m.removedinvitations = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *OrganizationMutation) AddSubscriptionIDs(ids ...int) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *OrganizationMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *OrganizationMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *OrganizationMutation) RemoveSubscriptionIDs(ids ...int) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *OrganizationMutation) RemovedSubscriptionsIDs() (ids []int) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *OrganizationMutation) SubscriptionsIDs() (ids []int) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *OrganizationMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, organization.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, organization.FieldDescription)
	}
	if m.logo_url != nil {
		fields = append(fields, organization.FieldLogoURL)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, organization.FieldStripeCustomerID)
	}
	if m.settings != nil {
		fields = append(fields, organization.FieldSettings)
	}
	if m.is_active != nil {
		fields = append(fields, organization.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldName:
		return m.Name()
	case organization.FieldSlug:
		return m.Slug()
	case organization.FieldDescription:
		return m.Description()
	case organization.FieldLogoURL:
		return m.LogoURL()
	case organization.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case organization.FieldSettings:
		return m.Settings()
	case organization.FieldIsActive:
		return m.IsActive()
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldSlug:
		return m.OldSlug(ctx)
	case organization.FieldDescription:
		return m.OldDescription(ctx)
	case organization.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case organization.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case organization.FieldSettings:
		return m.OldSettings(ctx)
	case organization.FieldIsActive:
		return m.OldIsActive(ctx)
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case organization.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case organization.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case organization.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case organization.FieldSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case organization.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldDescription) {
		fields = append(fields, organization.FieldDescription)
	}
	if m.FieldCleared(organization.FieldLogoURL) {
		fields = append(fields, organization.FieldLogoURL)
	}
	if m.FieldCleared(organization.FieldStripeCustomerID) {
		fields = append(fields, organization.FieldStripeCustomerID)
	}
	if m.FieldCleared(organization.FieldSettings) {
		fields = append(fields, organization.FieldSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldDescription:
		m.ClearDescription()
		return nil
	case organization.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	case organization.FieldStripeCustomerID:
		m.ClearStripeCustomerID()
		return nil
	case organization.FieldSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldSlug:
		m.ResetSlug()
		return nil
	case organization.FieldDescription:
		m.ResetDescription()
		return nil
	case organization.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case organization.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case organization.FieldSettings:
		m.ResetSettings()
		return nil
	case organization.FieldIsActive:
		m.ResetIsActive()
		return nil
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.app != nil {
		edges = append(edges, organization.EdgeApp)
	}
	if m.members != nil {
		edges = append(edges, organization.EdgeMembers)
	}
	if m.invitations != nil {
		edges = append(edges, organization.EdgeInvitations)
	}
	if m.subscriptions != nil {
		edges = append(edges, organization.EdgeSubscriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.invitations))
		for id := range m.invitations {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmembers != nil {
		edges = append(edges, organization.EdgeMembers)
	}
	if m.removedinvitations != nil {
		edges = append(edges, organization.EdgeInvitations)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, organization.EdgeSubscriptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.removedinvitations))
		for id := range m.removedinvitations {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedapp {
		edges = append(edges, organization.EdgeApp)
	}
	if m.clearedmembers {
		edges = append(edges, organization.EdgeMembers)
	}
	if m.clearedinvitations {
		edges = append(edges, organization.EdgeInvitations)
	}
	if m.clearedsubscriptions {
		edges = append(edges, organization.EdgeSubscriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeApp:
		return m.clearedapp
	case organization.EdgeMembers:
		return m.clearedmembers
	case organization.EdgeInvitations:
		return m.clearedinvitations
	case organization.EdgeSubscriptions:
		return m.clearedsubscriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeApp:
		m.ResetApp()
		return nil
	case organization.EdgeMembers:
		m.ResetMembers()
		return nil
	case organization.EdgeInvitations:
		m.ResetInvitations()
		return nil
	case organization.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationInvitationMutation represents an operation that mutates the OrganizationInvitation nodes in the graph.
type OrganizationInvitationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	email               *string
	role                *organizationinvitation.Role
	token               *string
	status              *organizationinvitation.Status
	created_at          *time.Time
	expires_at          *time.Time
	accepted_at         *time.Time
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	invited_by          *int
	clearedinvited_by   bool
	done                bool
	oldValue            func(context.Context) (*OrganizationInvitation, error)
	predicates          []predicate.OrganizationInvitation
}

var _ ent.Mutation = (*OrganizationInvitationMutation)(nil)

// organizationinvitationOption allows management of the mutation configuration using functional options.
type organizationinvitationOption func(*OrganizationInvitationMutation)

// newOrganizationInvitationMutation creates new mutation for the OrganizationInvitation entity.
func newOrganizationInvitationMutation(c config, op Op, opts ...organizationinvitationOption) *OrganizationInvitationMutation {
	m := &OrganizationInvitationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationInvitation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationInvitationID sets the ID field of the mutation.
func withOrganizationInvitationID(id int) organizationinvitationOption {
	return func(m *OrganizationInvitationMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationInvitation
		)
		m.oldValue = func(ctx context.Context) (*OrganizationInvitation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationInvitation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationInvitation sets the old OrganizationInvitation of the mutation.
func withOrganizationInvitation(node *OrganizationInvitation) organizationinvitationOption {
	return func(m *OrganizationInvitationMutation) {
		m.oldValue = func(context.Context) (*OrganizationInvitation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationInvitationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationInvitationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationInvitationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationInvitationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationInvitation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *OrganizationInvitationMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *OrganizationInvitationMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the OrganizationInvitation entity.
// If the OrganizationInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationInvitationMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *OrganizationInvitationMutation) ResetEmail() {
	m.email = nil
}

// SetRole sets the "role" field.
func (m *OrganizationInvitationMutation) SetRole(o organizationinvitation.Role) {
	m.role = &o
}

// Role returns the value of the "role" field in the mutation.
func (m *OrganizationInvitationMutation) Role() (r organizationinvitation.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the OrganizationInvitation entity.
// If the OrganizationInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationInvitationMutation) OldRole(ctx context.Context) (v organizationinvitation.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *OrganizationInvitationMutation) ResetRole() {
	m.role = nil
}

// SetToken sets the "token" field.
func (m *OrganizationInvitationMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *OrganizationInvitationMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the OrganizationInvitation entity.
// If the OrganizationInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationInvitationMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *OrganizationInvitationMutation) ResetToken() {
	m.token = nil
}

// SetStatus sets the "status" field.
func (m *OrganizationInvitationMutation) SetStatus(o organizationinvitation.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrganizationInvitationMutation) Status() (r organizationinvitation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrganizationInvitation entity.
// If the OrganizationInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationInvitationMutation) OldStatus(ctx context.Context) (v organizationinvitation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrganizationInvitationMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationInvitationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationInvitationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationInvitation entity.
// If the OrganizationInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationInvitationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationInvitationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *OrganizationInvitationMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OrganizationInvitationMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the OrganizationInvitation entity.
// If the OrganizationInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationInvitationMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *OrganizationInvitationMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[organizationinvitation.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *OrganizationInvitationMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[organizationinvitation.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OrganizationInvitationMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, organizationinvitation.FieldExpiresAt)
}

// SetAcceptedAt sets the "accepted_at" field.
func (m *OrganizationInvitationMutation) SetAcceptedAt(t time.Time) {
	m.accepted_at = &t
}

// AcceptedAt returns the value of the "accepted_at" field in the mutation.
func (m *OrganizationInvitationMutation) AcceptedAt() (r time.Time, exists bool) {
	v := m.accepted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedAt returns the old "accepted_at" field's value of the OrganizationInvitation entity.
// If the OrganizationInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationInvitationMutation) OldAcceptedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedAt: %w", err)
	}
	return oldValue.AcceptedAt, nil
}

// ClearAcceptedAt clears the value of the "accepted_at" field.
func (m *OrganizationInvitationMutation) ClearAcceptedAt() {
	m.accepted_at = nil
	m.clearedFields[organizationinvitation.FieldAcceptedAt] = struct{}{}
}

// AcceptedAtCleared returns if the "accepted_at" field was cleared in this mutation.
func (m *OrganizationInvitationMutation) AcceptedAtCleared() bool {
	_, ok := m.clearedFields[organizationinvitation.FieldAcceptedAt]
	return ok
}

// ResetAcceptedAt resets all changes to the "accepted_at" field.
func (m *OrganizationInvitationMutation) ResetAcceptedAt() {
	m.accepted_at = nil
	delete(m.clearedFields, organizationinvitation.FieldAcceptedAt)
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *OrganizationInvitationMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationInvitationMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationInvitationMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *OrganizationInvitationMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationInvitationMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationInvitationMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetInvitedByID sets the "invited_by" edge to the User entity by id.
func (m *OrganizationInvitationMutation) SetInvitedByID(id int) {
	m.invited_by = &id
}

// ClearInvitedBy clears the "invited_by" edge to the User entity.
func (m *OrganizationInvitationMutation) ClearInvitedBy() {
	m.clearedinvited_by = true
}

// InvitedByCleared reports if the "invited_by" edge to the User entity was cleared.
func (m *OrganizationInvitationMutation) InvitedByCleared() bool {
	return m.clearedinvited_by
}

// InvitedByID returns the "invited_by" edge ID in the mutation.
func (m *OrganizationInvitationMutation) InvitedByID() (id int, exists bool) {
	if m.invited_by != nil {
		return *m.invited_by, true
	}
	return
}

// InvitedByIDs returns the "invited_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvitedByID instead. It exists only for internal usage by the builders.
func (m *OrganizationInvitationMutation) InvitedByIDs() (ids []int) {
	if id := m.invited_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitedBy resets all changes to the "invited_by" edge.
func (m *OrganizationInvitationMutation) ResetInvitedBy() {
	m.invited_by = nil
	m.clearedinvited_by = false
}

// Where appends a list predicates to the OrganizationInvitationMutation builder.
func (m *OrganizationInvitationMutation) Where(ps ...predicate.OrganizationInvitation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationInvitationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationInvitationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationInvitation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationInvitationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationInvitationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationInvitation).
func (m *OrganizationInvitationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationInvitationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.email != nil {
		fields = append(fields, organizationinvitation.FieldEmail)
	}
	if m.role != nil {
		fields = append(fields, organizationinvitation.FieldRole)
	}
	if m.token != nil {
		fields = append(fields, organizationinvitation.FieldToken)
	}
	if m.status != nil {
		fields = append(fields, organizationinvitation.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, organizationinvitation.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, organizationinvitation.FieldExpiresAt)
	}
	if m.accepted_at != nil {
		fields = append(fields, organizationinvitation.FieldAcceptedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationInvitationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationinvitation.FieldEmail:
		return m.Email()
	case organizationinvitation.FieldRole:
		return m.Role()
	case organizationinvitation.FieldToken:
		return m.Token()
	case organizationinvitation.FieldStatus:
		return m.Status()
	case organizationinvitation.FieldCreatedAt:
		return m.CreatedAt()
	case organizationinvitation.FieldExpiresAt:
		return m.ExpiresAt()
	case organizationinvitation.FieldAcceptedAt:
		return m.AcceptedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationInvitationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationinvitation.FieldEmail:
		return m.OldEmail(ctx)
	case organizationinvitation.FieldRole:
		return m.OldRole(ctx)
	case organizationinvitation.FieldToken:
		return m.OldToken(ctx)
	case organizationinvitation.FieldStatus:
		return m.OldStatus(ctx)
	case organizationinvitation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationinvitation.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case organizationinvitation.FieldAcceptedAt:
		return m.OldAcceptedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationInvitation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationInvitationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationinvitation.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case organizationinvitation.FieldRole:
		v, ok := value.(organizationinvitation.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case organizationinvitation.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case organizationinvitation.FieldStatus:
		v, ok := value.(organizationinvitation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case organizationinvitation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationinvitation.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case organizationinvitation.FieldAcceptedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationInvitation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationInvitationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationInvitationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationInvitationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationInvitation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationInvitationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationinvitation.FieldExpiresAt) {
		fields = append(fields, organizationinvitation.FieldExpiresAt)
	}
	if m.FieldCleared(organizationinvitation.FieldAcceptedAt) {
		fields = append(fields, organizationinvitation.FieldAcceptedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationInvitationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationInvitationMutation) ClearField(name string) error {
	switch name {
	case organizationinvitation.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case organizationinvitation.FieldAcceptedAt:
		m.ClearAcceptedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationInvitation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationInvitationMutation) ResetField(name string) error {
	switch name {
	case organizationinvitation.FieldEmail:
		m.ResetEmail()
		return nil
	case organizationinvitation.FieldRole:
		m.ResetRole()
		return nil
	case organizationinvitation.FieldToken:
		m.ResetToken()
		return nil
	case organizationinvitation.FieldStatus:
		m.ResetStatus()
		return nil
	case organizationinvitation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationinvitation.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case organizationinvitation.FieldAcceptedAt:
		m.ResetAcceptedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationInvitation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationInvitationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, organizationinvitation.EdgeOrganization)
	}
	if m.invited_by != nil {
		edges = append(edges, organizationinvitation.EdgeInvitedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationInvitationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationinvitation.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case organizationinvitation.EdgeInvitedBy:
		if id := m.invited_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationInvitationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationInvitationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationInvitationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, organizationinvitation.EdgeOrganization)
	}
	if m.clearedinvited_by {
		edges = append(edges, organizationinvitation.EdgeInvitedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationInvitationMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationinvitation.EdgeOrganization:
		return m.clearedorganization
	case organizationinvitation.EdgeInvitedBy:
		return m.clearedinvited_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationInvitationMutation) ClearEdge(name string) error {
	switch name {
	case organizationinvitation.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case organizationinvitation.EdgeInvitedBy:
		m.ClearInvitedBy()
		return nil
	}
	return fmt.Errorf("unknown OrganizationInvitation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationInvitationMutation) ResetEdge(name string) error {
	switch name {
	case organizationinvitation.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case organizationinvitation.EdgeInvitedBy:
		m.ResetInvitedBy()
		return nil
	}
	return fmt.Errorf("unknown OrganizationInvitation edge %s", name)
}

// OrganizationMemberMutation represents an operation that mutates the OrganizationMember nodes in the graph.
type OrganizationMemberMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	role                *organizationmember.Role
	joined_at           *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	user                *int
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*OrganizationMember, error)
	predicates          []predicate.OrganizationMember
}

var _ ent.Mutation = (*OrganizationMemberMutation)(nil)

// organizationmemberOption allows management of the mutation configuration using functional options.
type organizationmemberOption func(*OrganizationMemberMutation)

// newOrganizationMemberMutation creates new mutation for the OrganizationMember entity.
func newOrganizationMemberMutation(c config, op Op, opts ...organizationmemberOption) *OrganizationMemberMutation {
	m := &OrganizationMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationMemberID sets the ID field of the mutation.
func withOrganizationMemberID(id int) organizationmemberOption {
	return func(m *OrganizationMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationMember
		)
		m.oldValue = func(ctx context.Context) (*OrganizationMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationMember sets the old OrganizationMember of the mutation.
func withOrganizationMember(node *OrganizationMember) organizationmemberOption {
	return func(m *OrganizationMemberMutation) {
		m.oldValue = func(context.Context) (*OrganizationMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *OrganizationMemberMutation) SetRole(o organizationmember.Role) {
	m.role = &o
}

// Role returns the value of the "role" field in the mutation.
func (m *OrganizationMemberMutation) Role() (r organizationmember.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldRole(ctx context.Context) (v organizationmember.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *OrganizationMemberMutation) ResetRole() {
	m.role = nil
}

// SetJoinedAt sets the "joined_at" field.
func (m *OrganizationMemberMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *OrganizationMemberMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *OrganizationMemberMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *OrganizationMemberMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationMemberMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationMemberMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *OrganizationMemberMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationMemberMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationMemberMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *OrganizationMemberMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrganizationMemberMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrganizationMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *OrganizationMemberMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrganizationMemberMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrganizationMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OrganizationMemberMutation builder.
func (m *OrganizationMemberMutation) Where(ps ...predicate.OrganizationMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationMember).
func (m *OrganizationMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMemberMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.role != nil {
		fields = append(fields, organizationmember.FieldRole)
	}
	if m.joined_at != nil {
		fields = append(fields, organizationmember.FieldJoinedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationmember.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationmember.FieldRole:
		return m.Role()
	case organizationmember.FieldJoinedAt:
		return m.JoinedAt()
	case organizationmember.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationmember.FieldRole:
		return m.OldRole(ctx)
	case organizationmember.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case organizationmember.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationmember.FieldRole:
		v, ok := value.(organizationmember.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case organizationmember.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case organizationmember.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrganizationMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMemberMutation) ResetField(name string) error {
	switch name {
	case organizationmember.FieldRole:
		m.ResetRole()
		return nil
	case organizationmember.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case organizationmember.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, organizationmember.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, organizationmember.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationmember.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case organizationmember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, organizationmember.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, organizationmember.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationmember.EdgeOrganization:
		return m.clearedorganization
	case organizationmember.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMemberMutation) ClearEdge(name string) error {
	switch name {
	case organizationmember.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case organizationmember.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMemberMutation) ResetEdge(name string) error {
	switch name {
	case organizationmember.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case organizationmember.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember edge %s", name)
}

// PlanMutation represents an operation that mutates the Plan nodes in the graph.
type PlanMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	slug                 *string
	description          *string
	price_cents          *int
	addprice_cents       *int
	currency             *string
	billing_interval     *plan.BillingInterval
	stripe_price_id      *string
	features             *map[string]interface{}
	is_active            *bool
	is_default           *bool
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	app                  *int
	clearedapp           bool
	subscriptions        map[int]struct{}
	removedsubscriptions map[int]struct{}
	clearedsubscriptions bool
	done                 bool
	oldValue             func(context.Context) (*Plan, error)
	predicates           []predicate.Plan
}

var _ ent.Mutation = (*PlanMutation)(nil)

// planOption allows management of the mutation configuration using functional options.
type planOption func(*PlanMutation)

// newPlanMutation creates new mutation for the Plan entity.
func newPlanMutation(c config, op Op, opts ...planOption) *PlanMutation {
	m := &PlanMutation{
		config:        c,
		op:            op,
		typ:           TypePlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanID sets the ID field of the mutation.
func withPlanID(id int) planOption {
	return func(m *PlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Plan
		)
		m.oldValue = func(ctx context.Context) (*Plan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlan sets the old Plan of the mutation.
func withPlan(node *Plan) planOption {
	return func(m *PlanMutation) {
		m.oldValue = func(context.Context) (*Plan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlanMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *PlanMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PlanMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *PlanMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *PlanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[plan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[plan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, plan.FieldDescription)
}

// SetPriceCents sets the "price_cents" field.
func (m *PlanMutation) SetPriceCents(i int) {
	m.price_cents = &i
	m.addprice_cents = nil
}

// PriceCents returns the value of the "price_cents" field in the mutation.
func (m *PlanMutation) PriceCents() (r int, exists bool) {
	v := m.price_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceCents returns the old "price_cents" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldPriceCents(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceCents: %w", err)
	}
	return oldValue.PriceCents, nil
}

// AddPriceCents adds i to the "price_cents" field.
func (m *PlanMutation) AddPriceCents(i int) {
	if m.addprice_cents != nil {
		*m.addprice_cents += i
	} else {
		m.addprice_cents = &i
	}
}

// AddedPriceCents returns the value that was added to the "price_cents" field in this mutation.
func (m *PlanMutation) AddedPriceCents() (r int, exists bool) {
	v := m.addprice_cents
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriceCents resets all changes to the "price_cents" field.
func (m *PlanMutation) ResetPriceCents() {
	m.price_cents = nil
	m.addprice_cents = nil
}

// SetCurrency sets the "currency" field.
func (m *PlanMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PlanMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PlanMutation) ResetCurrency() {
	m.currency = nil
}

// SetBillingInterval sets the "billing_interval" field.
func (m *PlanMutation) SetBillingInterval(pi plan.BillingInterval) {
	m.billing_interval = &pi
}

// BillingInterval returns the value of the "billing_interval" field in the mutation.
func (m *PlanMutation) BillingInterval() (r plan.BillingInterval, exists bool) {
	v := m.billing_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingInterval returns the old "billing_interval" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldBillingInterval(ctx context.Context) (v plan.BillingInterval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingInterval: %w", err)
	}
	return oldValue.BillingInterval, nil
}

// ResetBillingInterval resets all changes to the "billing_interval" field.
func (m *PlanMutation) ResetBillingInterval() {
	m.billing_interval = nil
}

// SetStripePriceID sets the "stripe_price_id" field.
func (m *PlanMutation) SetStripePriceID(s string) {
	m.stripe_price_id = &s
}

// StripePriceID returns the value of the "stripe_price_id" field in the mutation.
func (m *PlanMutation) StripePriceID() (r string, exists bool) {
	v := m.stripe_price_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripePriceID returns the old "stripe_price_id" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldStripePriceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripePriceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripePriceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripePriceID: %w", err)
	}
	return oldValue.StripePriceID, nil
}

// ClearStripePriceID clears the value of the "stripe_price_id" field.
func (m *PlanMutation) ClearStripePriceID() {
	m.stripe_price_id = nil
	m.clearedFields[plan.FieldStripePriceID] = struct{}{}
}

// StripePriceIDCleared returns if the "stripe_price_id" field was cleared in this mutation.
func (m *PlanMutation) StripePriceIDCleared() bool {
	_, ok := m.clearedFields[plan.FieldStripePriceID]
	return ok
}

// ResetStripePriceID resets all changes to the "stripe_price_id" field.
func (m *PlanMutation) ResetStripePriceID() {
	m.stripe_price_id = nil
	delete(m.clearedFields, plan.FieldStripePriceID)
}

// SetFeatures sets the "features" field.
func (m *PlanMutation) SetFeatures(value map[string]interface{}) {
	m.features = &value
}

// Features returns the value of the "features" field in the mutation.
func (m *PlanMutation) Features() (r map[string]interface{}, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatures returns the old "features" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldFeatures(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatures: %w", err)
	}
	return oldValue.Features, nil
}

// ClearFeatures clears the value of the "features" field.
func (m *PlanMutation) ClearFeatures() {
	m.features = nil
	m.clearedFields[plan.FieldFeatures] = struct{}{}
}

// FeaturesCleared returns if the "features" field was cleared in this mutation.
func (m *PlanMutation) FeaturesCleared() bool {
	_, ok := m.clearedFields[plan.FieldFeatures]
	return ok
}

// ResetFeatures resets all changes to the "features" field.
func (m *PlanMutation) ResetFeatures() {
	m.features = nil
	delete(m.clearedFields, plan.FieldFeatures)
}

// SetIsActive sets the "is_active" field.
func (m *PlanMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PlanMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PlanMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsDefault sets the "is_default" field.
func (m *PlanMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *PlanMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *PlanMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *PlanMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *PlanMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *PlanMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *PlanMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *PlanMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *PlanMutation) AddSubscriptionIDs(ids ...int) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *PlanMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *PlanMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *PlanMutation) RemoveSubscriptionIDs(ids ...int) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *PlanMutation) RemovedSubscriptionsIDs() (ids []int) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *PlanMutation) SubscriptionsIDs() (ids []int) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *PlanMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// Where appends a list predicates to the PlanMutation builder.
func (m *PlanMutation) Where(ps ...predicate.Plan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plan).
func (m *PlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, plan.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, plan.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, plan.FieldDescription)
	}
	if m.price_cents != nil {
		fields = append(fields, plan.FieldPriceCents)
	}
	if m.currency != nil {
		fields = append(fields, plan.FieldCurrency)
	}
	if m.billing_interval != nil {
		fields = append(fields, plan.FieldBillingInterval)
	}
	if m.stripe_price_id != nil {
		fields = append(fields, plan.FieldStripePriceID)
	}
	if m.features != nil {
		fields = append(fields, plan.FieldFeatures)
	}
	if m.is_active != nil {
		fields = append(fields, plan.FieldIsActive)
	}
	if m.is_default != nil {
		fields = append(fields, plan.FieldIsDefault)
	}
	if m.created_at != nil {
		fields = append(fields, plan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plan.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldName:
		return m.Name()
	case plan.FieldSlug:
		return m.Slug()
	case plan.FieldDescription:
		return m.Description()
	case plan.FieldPriceCents:
		return m.PriceCents()
	case plan.FieldCurrency:
		return m.Currency()
	case plan.FieldBillingInterval:
		return m.BillingInterval()
	case plan.FieldStripePriceID:
		return m.StripePriceID()
	case plan.FieldFeatures:
		return m.Features()
	case plan.FieldIsActive:
		return m.IsActive()
	case plan.FieldIsDefault:
		return m.IsDefault()
	case plan.FieldCreatedAt:
		return m.CreatedAt()
	case plan.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plan.FieldName:
		return m.OldName(ctx)
	case plan.FieldSlug:
		return m.OldSlug(ctx)
	case plan.FieldDescription:
		return m.OldDescription(ctx)
	case plan.FieldPriceCents:
		return m.OldPriceCents(ctx)
	case plan.FieldCurrency:
		return m.OldCurrency(ctx)
	case plan.FieldBillingInterval:
		return m.OldBillingInterval(ctx)
	case plan.FieldStripePriceID:
		return m.OldStripePriceID(ctx)
	case plan.FieldFeatures:
		return m.OldFeatures(ctx)
	case plan.FieldIsActive:
		return m.OldIsActive(ctx)
	case plan.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case plan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Plan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plan.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case plan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case plan.FieldPriceCents:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceCents(v)
		return nil
	case plan.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case plan.FieldBillingInterval:
		v, ok := value.(plan.BillingInterval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingInterval(v)
		return nil
	case plan.FieldStripePriceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripePriceID(v)
		return nil
	case plan.FieldFeatures:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatures(v)
		return nil
	case plan.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case plan.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case plan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanMutation) AddedFields() []string {
	var fields []string
	if m.addprice_cents != nil {
		fields = append(fields, plan.FieldPriceCents)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldPriceCents:
		return m.AddedPriceCents()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plan.FieldPriceCents:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceCents(v)
		return nil
	}
	return fmt.Errorf("unknown Plan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plan.FieldDescription) {
		fields = append(fields, plan.FieldDescription)
	}
	if m.FieldCleared(plan.FieldStripePriceID) {
		fields = append(fields, plan.FieldStripePriceID)
	}
	if m.FieldCleared(plan.FieldFeatures) {
		fields = append(fields, plan.FieldFeatures)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanMutation) ClearField(name string) error {
	switch name {
	case plan.FieldDescription:
		m.ClearDescription()
		return nil
	case plan.FieldStripePriceID:
		m.ClearStripePriceID()
		return nil
	case plan.FieldFeatures:
		m.ClearFeatures()
		return nil
	}
	return fmt.Errorf("unknown Plan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanMutation) ResetField(name string) error {
	switch name {
	case plan.FieldName:
		m.ResetName()
		return nil
	case plan.FieldSlug:
		m.ResetSlug()
		return nil
	case plan.FieldDescription:
		m.ResetDescription()
		return nil
	case plan.FieldPriceCents:
		m.ResetPriceCents()
		return nil
	case plan.FieldCurrency:
		m.ResetCurrency()
		return nil
	case plan.FieldBillingInterval:
		m.ResetBillingInterval()
		return nil
	case plan.FieldStripePriceID:
		m.ResetStripePriceID()
		return nil
	case plan.FieldFeatures:
		m.ResetFeatures()
		return nil
	case plan.FieldIsActive:
		m.ResetIsActive()
		return nil
	case plan.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case plan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, plan.EdgeApp)
	}
	if m.subscriptions != nil {
		edges = append(edges, plan.EdgeSubscriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsubscriptions != nil {
		edges = append(edges, plan.EdgeSubscriptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, plan.EdgeApp)
	}
	if m.clearedsubscriptions {
		edges = append(edges, plan.EdgeSubscriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanMutation) EdgeCleared(name string) bool {
	switch name {
	case plan.EdgeApp:
		return m.clearedapp
	case plan.EdgeSubscriptions:
		return m.clearedsubscriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanMutation) ClearEdge(name string) error {
	switch name {
	case plan.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown Plan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanMutation) ResetEdge(name string) error {
	switch name {
	case plan.EdgeApp:
		m.ResetApp()
		return nil
	case plan.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	}
	return fmt.Errorf("unknown Plan edge %s", name)
}

// ShenbiProfileMutation represents an operation that mutates the ShenbiProfile nodes in the graph.
type ShenbiProfileMutation struct {
	config
	op            Op
	typ           string
	id            *int
	role          *shenbiprofile.Role
	display_name  *string
	avatar_url    *string
	grade         *int
	addgrade      *int
	age           *int
	addage        *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	app           *int
	clearedapp    bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*ShenbiProfile, error)
	predicates    []predicate.ShenbiProfile
}

var _ ent.Mutation = (*ShenbiProfileMutation)(nil)

// shenbiprofileOption allows management of the mutation configuration using functional options.
type shenbiprofileOption func(*ShenbiProfileMutation)

// newShenbiProfileMutation creates new mutation for the ShenbiProfile entity.
func newShenbiProfileMutation(c config, op Op, opts ...shenbiprofileOption) *ShenbiProfileMutation {
	m := &ShenbiProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeShenbiProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShenbiProfileID sets the ID field of the mutation.
func withShenbiProfileID(id int) shenbiprofileOption {
	return func(m *ShenbiProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *ShenbiProfile
		)
		m.oldValue = func(ctx context.Context) (*ShenbiProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShenbiProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShenbiProfile sets the old ShenbiProfile of the mutation.
func withShenbiProfile(node *ShenbiProfile) shenbiprofileOption {
	return func(m *ShenbiProfileMutation) {
		m.oldValue = func(context.Context) (*ShenbiProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShenbiProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShenbiProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShenbiProfileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShenbiProfileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShenbiProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *ShenbiProfileMutation) SetRole(s shenbiprofile.Role) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *ShenbiProfileMutation) Role() (r shenbiprofile.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the ShenbiProfile entity.
// If the ShenbiProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShenbiProfileMutation) OldRole(ctx context.Context) (v shenbiprofile.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *ShenbiProfileMutation) ResetRole() {
	m.role = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ShenbiProfileMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ShenbiProfileMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the ShenbiProfile entity.
// If the ShenbiProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShenbiProfileMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ShenbiProfileMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[shenbiprofile.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ShenbiProfileMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[shenbiprofile.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ShenbiProfileMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, shenbiprofile.FieldDisplayName)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *ShenbiProfileMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *ShenbiProfileMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the ShenbiProfile entity.
// If the ShenbiProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShenbiProfileMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *ShenbiProfileMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[shenbiprofile.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *ShenbiProfileMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[shenbiprofile.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *ShenbiProfileMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, shenbiprofile.FieldAvatarURL)
}

// SetGrade sets the "grade" field.
func (m *ShenbiProfileMutation) SetGrade(i int) {
	m.grade = &i
	m.addgrade = nil
}

// Grade returns the value of the "grade" field in the mutation.
func (m *ShenbiProfileMutation) Grade() (r int, exists bool) {
	v := m.grade
	if v == nil {
		return
	}
	return *v, true
}

// OldGrade returns the old "grade" field's value of the ShenbiProfile entity.
// If the ShenbiProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShenbiProfileMutation) OldGrade(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrade: %w", err)
	}
	return oldValue.Grade, nil
}

// AddGrade adds i to the "grade" field.
func (m *ShenbiProfileMutation) AddGrade(i int) {
	if m.addgrade != nil {
		*m.addgrade += i
	} else {
		m.addgrade = &i
	}
}

// AddedGrade returns the value that was added to the "grade" field in this mutation.
func (m *ShenbiProfileMutation) AddedGrade() (r int, exists bool) {
	v := m.addgrade
	if v == nil {
		return
	}
	return *v, true
}

// ClearGrade clears the value of the "grade" field.
func (m *ShenbiProfileMutation) ClearGrade() {
	m.grade = nil
	m.addgrade = nil
	m.clearedFields[shenbiprofile.FieldGrade] = struct{}{}
}

// GradeCleared returns if the "grade" field was cleared in this mutation.
func (m *ShenbiProfileMutation) GradeCleared() bool {
	_, ok := m.clearedFields[shenbiprofile.FieldGrade]
	return ok
}

// ResetGrade resets all changes to the "grade" field.
func (m *ShenbiProfileMutation) ResetGrade() {
	m.grade = nil
	m.addgrade = nil
	delete(m.clearedFields, shenbiprofile.FieldGrade)
}

// SetAge sets the "age" field.
func (m *ShenbiProfileMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *ShenbiProfileMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the ShenbiProfile entity.
// If the ShenbiProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShenbiProfileMutation) OldAge(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *ShenbiProfileMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *ShenbiProfileMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ClearAge clears the value of the "age" field.
func (m *ShenbiProfileMutation) ClearAge() {
	m.age = nil
	m.addage = nil
	m.clearedFields[shenbiprofile.FieldAge] = struct{}{}
}

// AgeCleared returns if the "age" field was cleared in this mutation.
func (m *ShenbiProfileMutation) AgeCleared() bool {
	_, ok := m.clearedFields[shenbiprofile.FieldAge]
	return ok
}

// ResetAge resets all changes to the "age" field.
func (m *ShenbiProfileMutation) ResetAge() {
	m.age = nil
	m.addage = nil
	delete(m.clearedFields, shenbiprofile.FieldAge)
}

// SetCreatedAt sets the "created_at" field.
func (m *ShenbiProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShenbiProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShenbiProfile entity.
// If the ShenbiProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShenbiProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShenbiProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShenbiProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShenbiProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShenbiProfile entity.
// If the ShenbiProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShenbiProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShenbiProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *ShenbiProfileMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *ShenbiProfileMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *ShenbiProfileMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *ShenbiProfileMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *ShenbiProfileMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *ShenbiProfileMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ShenbiProfileMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ShenbiProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ShenbiProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ShenbiProfileMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ShenbiProfileMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ShenbiProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ShenbiProfileMutation builder.
func (m *ShenbiProfileMutation) Where(ps ...predicate.ShenbiProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShenbiProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShenbiProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShenbiProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShenbiProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShenbiProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShenbiProfile).
func (m *ShenbiProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShenbiProfileMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.role != nil {
		fields = append(fields, shenbiprofile.FieldRole)
	}
	if m.display_name != nil {
		fields = append(fields, shenbiprofile.FieldDisplayName)
	}
	if m.avatar_url != nil {
		fields = append(fields, shenbiprofile.FieldAvatarURL)
	}
	if m.grade != nil {
		fields = append(fields, shenbiprofile.FieldGrade)
	}
	if m.age != nil {
		fields = append(fields, shenbiprofile.FieldAge)
	}
	if m.created_at != nil {
		fields = append(fields, shenbiprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shenbiprofile.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShenbiProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shenbiprofile.FieldRole:
		return m.Role()
	case shenbiprofile.FieldDisplayName:
		return m.DisplayName()
	case shenbiprofile.FieldAvatarURL:
		return m.AvatarURL()
	case shenbiprofile.FieldGrade:
		return m.Grade()
	case shenbiprofile.FieldAge:
		return m.Age()
	case shenbiprofile.FieldCreatedAt:
		return m.CreatedAt()
	case shenbiprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShenbiProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shenbiprofile.FieldRole:
		return m.OldRole(ctx)
	case shenbiprofile.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case shenbiprofile.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case shenbiprofile.FieldGrade:
		return m.OldGrade(ctx)
	case shenbiprofile.FieldAge:
		return m.OldAge(ctx)
	case shenbiprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shenbiprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ShenbiProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShenbiProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shenbiprofile.FieldRole:
		v, ok := value.(shenbiprofile.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case shenbiprofile.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case shenbiprofile.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case shenbiprofile.FieldGrade:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrade(v)
		return nil
	case shenbiprofile.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case shenbiprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shenbiprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ShenbiProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShenbiProfileMutation) AddedFields() []string {
	var fields []string
	if m.addgrade != nil {
		fields = append(fields, shenbiprofile.FieldGrade)
	}
	if m.addage != nil {
		fields = append(fields, shenbiprofile.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShenbiProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shenbiprofile.FieldGrade:
		return m.AddedGrade()
	case shenbiprofile.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShenbiProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shenbiprofile.FieldGrade:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrade(v)
		return nil
	case shenbiprofile.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown ShenbiProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShenbiProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shenbiprofile.FieldDisplayName) {
		fields = append(fields, shenbiprofile.FieldDisplayName)
	}
	if m.FieldCleared(shenbiprofile.FieldAvatarURL) {
		fields = append(fields, shenbiprofile.FieldAvatarURL)
	}
	if m.FieldCleared(shenbiprofile.FieldGrade) {
		fields = append(fields, shenbiprofile.FieldGrade)
	}
	if m.FieldCleared(shenbiprofile.FieldAge) {
		fields = append(fields, shenbiprofile.FieldAge)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShenbiProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShenbiProfileMutation) ClearField(name string) error {
	switch name {
	case shenbiprofile.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case shenbiprofile.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case shenbiprofile.FieldGrade:
		m.ClearGrade()
		return nil
	case shenbiprofile.FieldAge:
		m.ClearAge()
		return nil
	}
	return fmt.Errorf("unknown ShenbiProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShenbiProfileMutation) ResetField(name string) error {
	switch name {
	case shenbiprofile.FieldRole:
		m.ResetRole()
		return nil
	case shenbiprofile.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case shenbiprofile.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case shenbiprofile.FieldGrade:
		m.ResetGrade()
		return nil
	case shenbiprofile.FieldAge:
		m.ResetAge()
		return nil
	case shenbiprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shenbiprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ShenbiProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShenbiProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, shenbiprofile.EdgeApp)
	}
	if m.user != nil {
		edges = append(edges, shenbiprofile.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShenbiProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shenbiprofile.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case shenbiprofile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShenbiProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShenbiProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShenbiProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, shenbiprofile.EdgeApp)
	}
	if m.cleareduser {
		edges = append(edges, shenbiprofile.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShenbiProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case shenbiprofile.EdgeApp:
		return m.clearedapp
	case shenbiprofile.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShenbiProfileMutation) ClearEdge(name string) error {
	switch name {
	case shenbiprofile.EdgeApp:
		m.ClearApp()
		return nil
	case shenbiprofile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ShenbiProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShenbiProfileMutation) ResetEdge(name string) error {
	switch name {
	case shenbiprofile.EdgeApp:
		m.ResetApp()
		return nil
	case shenbiprofile.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ShenbiProfile edge %s", name)
}

// ShenbiSettingsMutation represents an operation that mutates the ShenbiSettings nodes in the graph.
type ShenbiSettingsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	sound_enabled   *bool
	preferred_theme *string
	tour_completed  *map[string]bool
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	app             *int
	clearedapp      bool
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*ShenbiSettings, error)
	predicates      []predicate.ShenbiSettings
}

var _ ent.Mutation = (*ShenbiSettingsMutation)(nil)

// shenbisettingsOption allows management of the mutation configuration using functional options.
type shenbisettingsOption func(*ShenbiSettingsMutation)

// newShenbiSettingsMutation creates new mutation for the ShenbiSettings entity.
func newShenbiSettingsMutation(c config, op Op, opts ...shenbisettingsOption) *ShenbiSettingsMutation {
	m := &ShenbiSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeShenbiSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShenbiSettingsID sets the ID field of the mutation.
func withShenbiSettingsID(id int) shenbisettingsOption {
	return func(m *ShenbiSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *ShenbiSettings
		)
		m.oldValue = func(ctx context.Context) (*ShenbiSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShenbiSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShenbiSettings sets the old ShenbiSettings of the mutation.
func withShenbiSettings(node *ShenbiSettings) shenbisettingsOption {
	return func(m *ShenbiSettingsMutation) {
		m.oldValue = func(context.Context) (*ShenbiSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShenbiSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShenbiSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShenbiSettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShenbiSettingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShenbiSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSoundEnabled sets the "sound_enabled" field.
func (m *ShenbiSettingsMutation) SetSoundEnabled(b bool) {
	m.sound_enabled = &b
}

// SoundEnabled returns the value of the "sound_enabled" field in the mutation.
func (m *ShenbiSettingsMutation) SoundEnabled() (r bool, exists bool) {
	v := m.sound_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldSoundEnabled returns the old "sound_enabled" field's value of the ShenbiSettings entity.
// If the ShenbiSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShenbiSettingsMutation) OldSoundEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoundEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoundEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoundEnabled: %w", err)
	}
	return oldValue.SoundEnabled, nil
}

// ResetSoundEnabled resets all changes to the "sound_enabled" field.
func (m *ShenbiSettingsMutation) ResetSoundEnabled() {
	m.sound_enabled = nil
}

// SetPreferredTheme sets the "preferred_theme" field.
func (m *ShenbiSettingsMutation) SetPreferredTheme(s string) {
	m.preferred_theme = &s
}

// PreferredTheme returns the value of the "preferred_theme" field in the mutation.
func (m *ShenbiSettingsMutation) PreferredTheme() (r string, exists bool) {
	v := m.preferred_theme
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferredTheme returns the old "preferred_theme" field's value of the ShenbiSettings entity.
// If the ShenbiSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShenbiSettingsMutation) OldPreferredTheme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferredTheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferredTheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferredTheme: %w", err)
	}
	return oldValue.PreferredTheme, nil
}

// ResetPreferredTheme resets all changes to the "preferred_theme" field.
func (m *ShenbiSettingsMutation) ResetPreferredTheme() {
	m.preferred_theme = nil
}

// SetTourCompleted sets the "tour_completed" field.
func (m *ShenbiSettingsMutation) SetTourCompleted(value map[string]bool) {
	m.tour_completed = &value
}

// TourCompleted returns the value of the "tour_completed" field in the mutation.
func (m *ShenbiSettingsMutation) TourCompleted() (r map[string]bool, exists bool) {
	v := m.tour_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldTourCompleted returns the old "tour_completed" field's value of the ShenbiSettings entity.
// If the ShenbiSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShenbiSettingsMutation) OldTourCompleted(ctx context.Context) (v map[string]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTourCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTourCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTourCompleted: %w", err)
	}
	return oldValue.TourCompleted, nil
}

// ClearTourCompleted clears the value of the "tour_completed" field.
func (m *ShenbiSettingsMutation) ClearTourCompleted() {
	m.tour_completed = nil
	m.clearedFields[shenbisettings.FieldTourCompleted] = struct{}{}
}

// TourCompletedCleared returns if the "tour_completed" field was cleared in this mutation.
func (m *ShenbiSettingsMutation) TourCompletedCleared() bool {
	_, ok := m.clearedFields[shenbisettings.FieldTourCompleted]
	return ok
}

// ResetTourCompleted resets all changes to the "tour_completed" field.
func (m *ShenbiSettingsMutation) ResetTourCompleted() {
	m.tour_completed = nil
	delete(m.clearedFields, shenbisettings.FieldTourCompleted)
}

// SetCreatedAt sets the "created_at" field.
func (m *ShenbiSettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShenbiSettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShenbiSettings entity.
// If the ShenbiSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShenbiSettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShenbiSettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShenbiSettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShenbiSettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShenbiSettings entity.
// If the ShenbiSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShenbiSettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShenbiSettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *ShenbiSettingsMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *ShenbiSettingsMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *ShenbiSettingsMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *ShenbiSettingsMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *ShenbiSettingsMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *ShenbiSettingsMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ShenbiSettingsMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ShenbiSettingsMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ShenbiSettingsMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ShenbiSettingsMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ShenbiSettingsMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ShenbiSettingsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ShenbiSettingsMutation builder.
func (m *ShenbiSettingsMutation) Where(ps ...predicate.ShenbiSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShenbiSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShenbiSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShenbiSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShenbiSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShenbiSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShenbiSettings).
func (m *ShenbiSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShenbiSettingsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.sound_enabled != nil {
		fields = append(fields, shenbisettings.FieldSoundEnabled)
	}
	if m.preferred_theme != nil {
		fields = append(fields, shenbisettings.FieldPreferredTheme)
	}
	if m.tour_completed != nil {
		fields = append(fields, shenbisettings.FieldTourCompleted)
	}
	if m.created_at != nil {
		fields = append(fields, shenbisettings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shenbisettings.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShenbiSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shenbisettings.FieldSoundEnabled:
		return m.SoundEnabled()
	case shenbisettings.FieldPreferredTheme:
		return m.PreferredTheme()
	case shenbisettings.FieldTourCompleted:
		return m.TourCompleted()
	case shenbisettings.FieldCreatedAt:
		return m.CreatedAt()
	case shenbisettings.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShenbiSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shenbisettings.FieldSoundEnabled:
		return m.OldSoundEnabled(ctx)
	case shenbisettings.FieldPreferredTheme:
		return m.OldPreferredTheme(ctx)
	case shenbisettings.FieldTourCompleted:
		return m.OldTourCompleted(ctx)
	case shenbisettings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shenbisettings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ShenbiSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShenbiSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shenbisettings.FieldSoundEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoundEnabled(v)
		return nil
	case shenbisettings.FieldPreferredTheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferredTheme(v)
		return nil
	case shenbisettings.FieldTourCompleted:
		v, ok := value.(map[string]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTourCompleted(v)
		return nil
	case shenbisettings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shenbisettings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ShenbiSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShenbiSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShenbiSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShenbiSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShenbiSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShenbiSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shenbisettings.FieldTourCompleted) {
		fields = append(fields, shenbisettings.FieldTourCompleted)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShenbiSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShenbiSettingsMutation) ClearField(name string) error {
	switch name {
	case shenbisettings.FieldTourCompleted:
		m.ClearTourCompleted()
		return nil
	}
	return fmt.Errorf("unknown ShenbiSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShenbiSettingsMutation) ResetField(name string) error {
	switch name {
	case shenbisettings.FieldSoundEnabled:
		m.ResetSoundEnabled()
		return nil
	case shenbisettings.FieldPreferredTheme:
		m.ResetPreferredTheme()
		return nil
	case shenbisettings.FieldTourCompleted:
		m.ResetTourCompleted()
		return nil
	case shenbisettings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shenbisettings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ShenbiSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShenbiSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, shenbisettings.EdgeApp)
	}
	if m.user != nil {
		edges = append(edges, shenbisettings.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShenbiSettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shenbisettings.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case shenbisettings.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShenbiSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShenbiSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShenbiSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, shenbisettings.EdgeApp)
	}
	if m.cleareduser {
		edges = append(edges, shenbisettings.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShenbiSettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case shenbisettings.EdgeApp:
		return m.clearedapp
	case shenbisettings.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShenbiSettingsMutation) ClearEdge(name string) error {
	switch name {
	case shenbisettings.EdgeApp:
		m.ClearApp()
		return nil
	case shenbisettings.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ShenbiSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShenbiSettingsMutation) ResetEdge(name string) error {
	switch name {
	case shenbisettings.EdgeApp:
		m.ResetApp()
		return nil
	case shenbisettings.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ShenbiSettings edge %s", name)
}

// SubscriptionMutation represents an operation that mutates the Subscription nodes in the graph.
type SubscriptionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	status                 *subscription.Status
	stripe_subscription_id *string
	current_period_start   *time.Time
	current_period_end     *time.Time
	canceled_at            *time.Time
	trial_end              *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	user                   *int
	cleareduser            bool
	organization           *int
	clearedorganization    bool
	app                    *int
	clearedapp             bool
	plan                   *int
	clearedplan            bool
	done                   bool
	oldValue               func(context.Context) (*Subscription, error)
	predicates             []predicate.Subscription
}

var _ ent.Mutation = (*SubscriptionMutation)(nil)

// subscriptionOption allows management of the mutation configuration using functional options.
type subscriptionOption func(*SubscriptionMutation)

// newSubscriptionMutation creates new mutation for the Subscription entity.
func newSubscriptionMutation(c config, op Op, opts ...subscriptionOption) *SubscriptionMutation {
	m := &SubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionID sets the ID field of the mutation.
func withSubscriptionID(id int) subscriptionOption {
	return func(m *SubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscription
		)
		m.oldValue = func(ctx context.Context) (*Subscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscription sets the old Subscription of the mutation.
func withSubscription(node *Subscription) subscriptionOption {
	return func(m *SubscriptionMutation) {
		m.oldValue = func(context.Context) (*Subscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *SubscriptionMutation) SetStatus(s subscription.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SubscriptionMutation) Status() (r subscription.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldStatus(ctx context.Context) (v subscription.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SubscriptionMutation) ResetStatus() {
	m.status = nil
}

// SetStripeSubscriptionID sets the "stripe_subscription_id" field.
func (m *SubscriptionMutation) SetStripeSubscriptionID(s string) {
	m.stripe_subscription_id = &s
}

// StripeSubscriptionID returns the value of the "stripe_subscription_id" field in the mutation.
func (m *SubscriptionMutation) StripeSubscriptionID() (r string, exists bool) {
	v := m.stripe_subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeSubscriptionID returns the old "stripe_subscription_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldStripeSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeSubscriptionID: %w", err)
	}
	return oldValue.StripeSubscriptionID, nil
}

// ClearStripeSubscriptionID clears the value of the "stripe_subscription_id" field.
func (m *SubscriptionMutation) ClearStripeSubscriptionID() {
	m.stripe_subscription_id = nil
	m.clearedFields[subscription.FieldStripeSubscriptionID] = struct{}{}
}

// StripeSubscriptionIDCleared returns if the "stripe_subscription_id" field was cleared in this mutation.
func (m *SubscriptionMutation) StripeSubscriptionIDCleared() bool {
	_, ok := m.clearedFields[subscription.FieldStripeSubscriptionID]
	return ok
}

// ResetStripeSubscriptionID resets all changes to the "stripe_subscription_id" field.
func (m *SubscriptionMutation) ResetStripeSubscriptionID() {
	m.stripe_subscription_id = nil
	delete(m.clearedFields, subscription.FieldStripeSubscriptionID)
}

// SetCurrentPeriodStart sets the "current_period_start" field.
func (m *SubscriptionMutation) SetCurrentPeriodStart(t time.Time) {
	m.current_period_start = &t
}

// CurrentPeriodStart returns the value of the "current_period_start" field in the mutation.
func (m *SubscriptionMutation) CurrentPeriodStart() (r time.Time, exists bool) {
	v := m.current_period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPeriodStart returns the old "current_period_start" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCurrentPeriodStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPeriodStart: %w", err)
	}
	return oldValue.CurrentPeriodStart, nil
}

// ClearCurrentPeriodStart clears the value of the "current_period_start" field.
func (m *SubscriptionMutation) ClearCurrentPeriodStart() {
	m.current_period_start = nil
	m.clearedFields[subscription.FieldCurrentPeriodStart] = struct{}{}
}

// CurrentPeriodStartCleared returns if the "current_period_start" field was cleared in this mutation.
func (m *SubscriptionMutation) CurrentPeriodStartCleared() bool {
	_, ok := m.clearedFields[subscription.FieldCurrentPeriodStart]
	return ok
}

// ResetCurrentPeriodStart resets all changes to the "current_period_start" field.
func (m *SubscriptionMutation) ResetCurrentPeriodStart() {
	m.current_period_start = nil
	delete(m.clearedFields, subscription.FieldCurrentPeriodStart)
}

// SetCurrentPeriodEnd sets the "current_period_end" field.
func (m *SubscriptionMutation) SetCurrentPeriodEnd(t time.Time) {
	m.current_period_end = &t
}

// CurrentPeriodEnd returns the value of the "current_period_end" field in the mutation.
func (m *SubscriptionMutation) CurrentPeriodEnd() (r time.Time, exists bool) {
	v := m.current_period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPeriodEnd returns the old "current_period_end" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCurrentPeriodEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPeriodEnd: %w", err)
	}
	return oldValue.CurrentPeriodEnd, nil
}

// ClearCurrentPeriodEnd clears the value of the "current_period_end" field.
func (m *SubscriptionMutation) ClearCurrentPeriodEnd() {
	m.current_period_end = nil
	m.clearedFields[subscription.FieldCurrentPeriodEnd] = struct{}{}
}

// CurrentPeriodEndCleared returns if the "current_period_end" field was cleared in this mutation.
func (m *SubscriptionMutation) CurrentPeriodEndCleared() bool {
	_, ok := m.clearedFields[subscription.FieldCurrentPeriodEnd]
	return ok
}

// ResetCurrentPeriodEnd resets all changes to the "current_period_end" field.
func (m *SubscriptionMutation) ResetCurrentPeriodEnd() {
	m.current_period_end = nil
	delete(m.clearedFields, subscription.FieldCurrentPeriodEnd)
}

// SetCanceledAt sets the "canceled_at" field.
func (m *SubscriptionMutation) SetCanceledAt(t time.Time) {
	m.canceled_at = &t
}

// CanceledAt returns the value of the "canceled_at" field in the mutation.
func (m *SubscriptionMutation) CanceledAt() (r time.Time, exists bool) {
	v := m.canceled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCanceledAt returns the old "canceled_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCanceledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanceledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanceledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanceledAt: %w", err)
	}
	return oldValue.CanceledAt, nil
}

// ClearCanceledAt clears the value of the "canceled_at" field.
func (m *SubscriptionMutation) ClearCanceledAt() {
	m.canceled_at = nil
	m.clearedFields[subscription.FieldCanceledAt] = struct{}{}
}

// CanceledAtCleared returns if the "canceled_at" field was cleared in this mutation.
func (m *SubscriptionMutation) CanceledAtCleared() bool {
	_, ok := m.clearedFields[subscription.FieldCanceledAt]
	return ok
}

// ResetCanceledAt resets all changes to the "canceled_at" field.
func (m *SubscriptionMutation) ResetCanceledAt() {
	m.canceled_at = nil
	delete(m.clearedFields, subscription.FieldCanceledAt)
}

// SetTrialEnd sets the "trial_end" field.
func (m *SubscriptionMutation) SetTrialEnd(t time.Time) {
	m.trial_end = &t
}

// TrialEnd returns the value of the "trial_end" field in the mutation.
func (m *SubscriptionMutation) TrialEnd() (r time.Time, exists bool) {
	v := m.trial_end
	if v == nil {
		return
	}
	return *v, true
}

// OldTrialEnd returns the old "trial_end" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldTrialEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrialEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrialEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrialEnd: %w", err)
	}
	return oldValue.TrialEnd, nil
}

// ClearTrialEnd clears the value of the "trial_end" field.
func (m *SubscriptionMutation) ClearTrialEnd() {
	m.trial_end = nil
	m.clearedFields[subscription.FieldTrialEnd] = struct{}{}
}

// TrialEndCleared returns if the "trial_end" field was cleared in this mutation.
func (m *SubscriptionMutation) TrialEndCleared() bool {
	_, ok := m.clearedFields[subscription.FieldTrialEnd]
	return ok
}

// ResetTrialEnd resets all changes to the "trial_end" field.
func (m *SubscriptionMutation) ResetTrialEnd() {
	m.trial_end = nil
	delete(m.clearedFields, subscription.FieldTrialEnd)
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SubscriptionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SubscriptionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SubscriptionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *SubscriptionMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *SubscriptionMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *SubscriptionMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *SubscriptionMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *SubscriptionMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *SubscriptionMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *SubscriptionMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *SubscriptionMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *SubscriptionMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *SubscriptionMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetPlanID sets the "plan" edge to the Plan entity by id.
func (m *SubscriptionMutation) SetPlanID(id int) {
	m.plan = &id
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *SubscriptionMutation) ClearPlan() {
	m.clearedplan = true
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *SubscriptionMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanID returns the "plan" edge ID in the mutation.
func (m *SubscriptionMutation) PlanID() (id int, exists bool) {
	if m.plan != nil {
		return *m.plan, true
	}
	return
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) PlanIDs() (ids []int) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *SubscriptionMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// Where appends a list predicates to the SubscriptionMutation builder.
func (m *SubscriptionMutation) Where(ps ...predicate.Subscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscription).
func (m *SubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.status != nil {
		fields = append(fields, subscription.FieldStatus)
	}
	if m.stripe_subscription_id != nil {
		fields = append(fields, subscription.FieldStripeSubscriptionID)
	}
	if m.current_period_start != nil {
		fields = append(fields, subscription.FieldCurrentPeriodStart)
	}
	if m.current_period_end != nil {
		fields = append(fields, subscription.FieldCurrentPeriodEnd)
	}
	if m.canceled_at != nil {
		fields = append(fields, subscription.FieldCanceledAt)
	}
	if m.trial_end != nil {
		fields = append(fields, subscription.FieldTrialEnd)
	}
	if m.created_at != nil {
		fields = append(fields, subscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscription.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldStatus:
		return m.Status()
	case subscription.FieldStripeSubscriptionID:
		return m.StripeSubscriptionID()
	case subscription.FieldCurrentPeriodStart:
		return m.CurrentPeriodStart()
	case subscription.FieldCurrentPeriodEnd:
		return m.CurrentPeriodEnd()
	case subscription.FieldCanceledAt:
		return m.CanceledAt()
	case subscription.FieldTrialEnd:
		return m.TrialEnd()
	case subscription.FieldCreatedAt:
		return m.CreatedAt()
	case subscription.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscription.FieldStatus:
		return m.OldStatus(ctx)
	case subscription.FieldStripeSubscriptionID:
		return m.OldStripeSubscriptionID(ctx)
	case subscription.FieldCurrentPeriodStart:
		return m.OldCurrentPeriodStart(ctx)
	case subscription.FieldCurrentPeriodEnd:
		return m.OldCurrentPeriodEnd(ctx)
	case subscription.FieldCanceledAt:
		return m.OldCanceledAt(ctx)
	case subscription.FieldTrialEnd:
		return m.OldTrialEnd(ctx)
	case subscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Subscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldStatus:
		v, ok := value.(subscription.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case subscription.FieldStripeSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeSubscriptionID(v)
		return nil
	case subscription.FieldCurrentPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPeriodStart(v)
		return nil
	case subscription.FieldCurrentPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPeriodEnd(v)
		return nil
	case subscription.FieldCanceledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanceledAt(v)
		return nil
	case subscription.FieldTrialEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrialEnd(v)
		return nil
	case subscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscription.FieldStripeSubscriptionID) {
		fields = append(fields, subscription.FieldStripeSubscriptionID)
	}
	if m.FieldCleared(subscription.FieldCurrentPeriodStart) {
		fields = append(fields, subscription.FieldCurrentPeriodStart)
	}
	if m.FieldCleared(subscription.FieldCurrentPeriodEnd) {
		fields = append(fields, subscription.FieldCurrentPeriodEnd)
	}
	if m.FieldCleared(subscription.FieldCanceledAt) {
		fields = append(fields, subscription.FieldCanceledAt)
	}
	if m.FieldCleared(subscription.FieldTrialEnd) {
		fields = append(fields, subscription.FieldTrialEnd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionMutation) ClearField(name string) error {
	switch name {
	case subscription.FieldStripeSubscriptionID:
		m.ClearStripeSubscriptionID()
		return nil
	case subscription.FieldCurrentPeriodStart:
		m.ClearCurrentPeriodStart()
		return nil
	case subscription.FieldCurrentPeriodEnd:
		m.ClearCurrentPeriodEnd()
		return nil
	case subscription.FieldCanceledAt:
		m.ClearCanceledAt()
		return nil
	case subscription.FieldTrialEnd:
		m.ClearTrialEnd()
		return nil
	}
	return fmt.Errorf("unknown Subscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionMutation) ResetField(name string) error {
	switch name {
	case subscription.FieldStatus:
		m.ResetStatus()
		return nil
	case subscription.FieldStripeSubscriptionID:
		m.ResetStripeSubscriptionID()
		return nil
	case subscription.FieldCurrentPeriodStart:
		m.ResetCurrentPeriodStart()
		return nil
	case subscription.FieldCurrentPeriodEnd:
		m.ResetCurrentPeriodEnd()
		return nil
	case subscription.FieldCanceledAt:
		m.ResetCanceledAt()
		return nil
	case subscription.FieldTrialEnd:
		m.ResetTrialEnd()
		return nil
	case subscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, subscription.EdgeUser)
	}
	if m.organization != nil {
		edges = append(edges, subscription.EdgeOrganization)
	}
	if m.app != nil {
		edges = append(edges, subscription.EdgeApp)
	}
	if m.plan != nil {
		edges = append(edges, subscription.EdgePlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case subscription.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case subscription.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case subscription.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, subscription.EdgeUser)
	}
	if m.clearedorganization {
		edges = append(edges, subscription.EdgeOrganization)
	}
	if m.clearedapp {
		edges = append(edges, subscription.EdgeApp)
	}
	if m.clearedplan {
		edges = append(edges, subscription.EdgePlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case subscription.EdgeUser:
		return m.cleareduser
	case subscription.EdgeOrganization:
		return m.clearedorganization
	case subscription.EdgeApp:
		return m.clearedapp
	case subscription.EdgePlan:
		return m.clearedplan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ClearUser()
		return nil
	case subscription.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case subscription.EdgeApp:
		m.ClearApp()
		return nil
	case subscription.EdgePlan:
		m.ClearPlan()
		return nil
	}
	return fmt.Errorf("unknown Subscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ResetUser()
		return nil
	case subscription.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case subscription.EdgeApp:
		m.ResetApp()
		return nil
	case subscription.EdgePlan:
		m.ResetPlan()
		return nil
	}
	return fmt.Errorf("unknown Subscription edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	email                              *string
	password_hash                      *string
	name                               *string
	avatar_url                         *string
	device_id                          *string
	google_id                          *string
	apple_id                           *string
	google_access_token                *string
	google_refresh_token               *string
	google_token_expires_at            *time.Time
	is_active                          *bool
	is_verified                        *bool
	extra_data                         *map[string]interface{}
	created_at                         *time.Time
	updated_at                         *time.Time
	last_login_at                      *time.Time
	clearedFields                      map[string]struct{}
	user_apps                          map[int]struct{}
	removeduser_apps                   map[int]struct{}
	cleareduser_apps                   bool
	organization_memberships           map[int]struct{}
	removedorganization_memberships    map[int]struct{}
	clearedorganization_memberships    bool
	subscriptions                      map[int]struct{}
	removedsubscriptions               map[int]struct{}
	clearedsubscriptions               bool
	shenbi_profile                     *int
	clearedshenbi_profile              bool
	classrooms_teaching                map[int]struct{}
	removedclassrooms_teaching         map[int]struct{}
	clearedclassrooms_teaching         bool
	classroom_memberships              map[int]struct{}
	removedclassroom_memberships       map[int]struct{}
	clearedclassroom_memberships       bool
	assignment_submissions             map[int]struct{}
	removedassignment_submissions      map[int]struct{}
	clearedassignment_submissions      bool
	user_progress                      map[int]struct{}
	removeduser_progress               map[int]struct{}
	cleareduser_progress               bool
	achievements                       map[int]struct{}
	removedachievements                map[int]struct{}
	clearedachievements                bool
	battle_rooms_hosted                map[int]struct{}
	removedbattle_rooms_hosted         map[int]struct{}
	clearedbattle_rooms_hosted         bool
	battle_sessions                    map[int]struct{}
	removedbattle_sessions             map[int]struct{}
	clearedbattle_sessions             bool
	live_sessions_teaching             map[int]struct{}
	removedlive_sessions_teaching      map[int]struct{}
	clearedlive_sessions_teaching      bool
	live_session_participations        map[int]struct{}
	removedlive_session_participations map[int]struct{}
	clearedlive_session_participations bool
	classroom_sessions                 map[int]struct{}
	removedclassroom_sessions          map[int]struct{}
	clearedclassroom_sessions          bool
	shenbi_settings                    *int
	clearedshenbi_settings             bool
	sent_invitations                   map[int]struct{}
	removedsent_invitations            map[int]struct{}
	clearedsent_invitations            bool
	done                               bool
	oldValue                           func(context.Context) (*User, error)
	predicates                         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetDeviceID sets the "device_id" field.
func (m *UserMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *UserMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeviceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of the "device_id" field.
func (m *UserMutation) ClearDeviceID() {
	m.device_id = nil
	m.clearedFields[user.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the "device_id" field was cleared in this mutation.
func (m *UserMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[user.FieldDeviceID]
	return ok
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *UserMutation) ResetDeviceID() {
	m.device_id = nil
	delete(m.clearedFields, user.FieldDeviceID)
}

// SetGoogleID sets the "google_id" field.
func (m *UserMutation) SetGoogleID(s string) {
	m.google_id = &s
}

// GoogleID returns the value of the "google_id" field in the mutation.
func (m *UserMutation) GoogleID() (r string, exists bool) {
	v := m.google_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleID returns the old "google_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGoogleID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleID: %w", err)
	}
	return oldValue.GoogleID, nil
}

// ClearGoogleID clears the value of the "google_id" field.
func (m *UserMutation) ClearGoogleID() {
	m.google_id = nil
	m.clearedFields[user.FieldGoogleID] = struct{}{}
}

// GoogleIDCleared returns if the "google_id" field was cleared in this mutation.
func (m *UserMutation) GoogleIDCleared() bool {
	_, ok := m.clearedFields[user.FieldGoogleID]
	return ok
}

// ResetGoogleID resets all changes to the "google_id" field.
func (m *UserMutation) ResetGoogleID() {
	m.google_id = nil
	delete(m.clearedFields, user.FieldGoogleID)
}

// SetAppleID sets the "apple_id" field.
func (m *UserMutation) SetAppleID(s string) {
	m.apple_id = &s
}

// AppleID returns the value of the "apple_id" field in the mutation.
func (m *UserMutation) AppleID() (r string, exists bool) {
	v := m.apple_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppleID returns the old "apple_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAppleID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppleID: %w", err)
	}
	return oldValue.AppleID, nil
}

// ClearAppleID clears the value of the "apple_id" field.
func (m *UserMutation) ClearAppleID() {
	m.apple_id = nil
	m.clearedFields[user.FieldAppleID] = struct{}{}
}

// AppleIDCleared returns if the "apple_id" field was cleared in this mutation.
func (m *UserMutation) AppleIDCleared() bool {
	_, ok := m.clearedFields[user.FieldAppleID]
	return ok
}

// ResetAppleID resets all changes to the "apple_id" field.
func (m *UserMutation) ResetAppleID() {
	m.apple_id = nil
	delete(m.clearedFields, user.FieldAppleID)
}

// SetGoogleAccessToken sets the "google_access_token" field.
func (m *UserMutation) SetGoogleAccessToken(s string) {
	m.google_access_token = &s
}

// GoogleAccessToken returns the value of the "google_access_token" field in the mutation.
func (m *UserMutation) GoogleAccessToken() (r string, exists bool) {
	v := m.google_access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleAccessToken returns the old "google_access_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGoogleAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleAccessToken: %w", err)
	}
	return oldValue.GoogleAccessToken, nil
}

// ClearGoogleAccessToken clears the value of the "google_access_token" field.
func (m *UserMutation) ClearGoogleAccessToken() {
	m.google_access_token = nil
	m.clearedFields[user.FieldGoogleAccessToken] = struct{}{}
}

// GoogleAccessTokenCleared returns if the "google_access_token" field was cleared in this mutation.
func (m *UserMutation) GoogleAccessTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldGoogleAccessToken]
	return ok
}

// ResetGoogleAccessToken resets all changes to the "google_access_token" field.
func (m *UserMutation) ResetGoogleAccessToken() {
	m.google_access_token = nil
	delete(m.clearedFields, user.FieldGoogleAccessToken)
}

// SetGoogleRefreshToken sets the "google_refresh_token" field.
func (m *UserMutation) SetGoogleRefreshToken(s string) {
	m.google_refresh_token = &s
}

// GoogleRefreshToken returns the value of the "google_refresh_token" field in the mutation.
func (m *UserMutation) GoogleRefreshToken() (r string, exists bool) {
	v := m.google_refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleRefreshToken returns the old "google_refresh_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGoogleRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleRefreshToken: %w", err)
	}
	return oldValue.GoogleRefreshToken, nil
}

// ClearGoogleRefreshToken clears the value of the "google_refresh_token" field.
func (m *UserMutation) ClearGoogleRefreshToken() {
	m.google_refresh_token = nil
	m.clearedFields[user.FieldGoogleRefreshToken] = struct{}{}
}

// GoogleRefreshTokenCleared returns if the "google_refresh_token" field was cleared in this mutation.
func (m *UserMutation) GoogleRefreshTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldGoogleRefreshToken]
	return ok
}

// ResetGoogleRefreshToken resets all changes to the "google_refresh_token" field.
func (m *UserMutation) ResetGoogleRefreshToken() {
	m.google_refresh_token = nil
	delete(m.clearedFields, user.FieldGoogleRefreshToken)
}

// SetGoogleTokenExpiresAt sets the "google_token_expires_at" field.
func (m *UserMutation) SetGoogleTokenExpiresAt(t time.Time) {
	m.google_token_expires_at = &t
}

// GoogleTokenExpiresAt returns the value of the "google_token_expires_at" field in the mutation.
func (m *UserMutation) GoogleTokenExpiresAt() (r time.Time, exists bool) {
	v := m.google_token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleTokenExpiresAt returns the old "google_token_expires_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGoogleTokenExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleTokenExpiresAt: %w", err)
	}
	return oldValue.GoogleTokenExpiresAt, nil
}

// ClearGoogleTokenExpiresAt clears the value of the "google_token_expires_at" field.
func (m *UserMutation) ClearGoogleTokenExpiresAt() {
	m.google_token_expires_at = nil
	m.clearedFields[user.FieldGoogleTokenExpiresAt] = struct{}{}
}

// GoogleTokenExpiresAtCleared returns if the "google_token_expires_at" field was cleared in this mutation.
func (m *UserMutation) GoogleTokenExpiresAtCleared() bool {
	_, ok := m.clearedFields[user.FieldGoogleTokenExpiresAt]
	return ok
}

// ResetGoogleTokenExpiresAt resets all changes to the "google_token_expires_at" field.
func (m *UserMutation) ResetGoogleTokenExpiresAt() {
	m.google_token_expires_at = nil
	delete(m.clearedFields, user.FieldGoogleTokenExpiresAt)
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsVerified sets the "is_verified" field.
func (m *UserMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *UserMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *UserMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetExtraData sets the "extra_data" field.
func (m *UserMutation) SetExtraData(value map[string]interface{}) {
	m.extra_data = &value
}

// ExtraData returns the value of the "extra_data" field in the mutation.
func (m *UserMutation) ExtraData() (r map[string]interface{}, exists bool) {
	v := m.extra_data
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraData returns the old "extra_data" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExtraData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraData: %w", err)
	}
	return oldValue.ExtraData, nil
}

// ClearExtraData clears the value of the "extra_data" field.
func (m *UserMutation) ClearExtraData() {
	m.extra_data = nil
	m.clearedFields[user.FieldExtraData] = struct{}{}
}

// ExtraDataCleared returns if the "extra_data" field was cleared in this mutation.
func (m *UserMutation) ExtraDataCleared() bool {
	_, ok := m.clearedFields[user.FieldExtraData]
	return ok
}

// ResetExtraData resets all changes to the "extra_data" field.
func (m *UserMutation) ResetExtraData() {
	m.extra_data = nil
	delete(m.clearedFields, user.FieldExtraData)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// AddUserAppIDs adds the "user_apps" edge to the UserApp entity by ids.
func (m *UserMutation) AddUserAppIDs(ids ...int) {
	if m.user_apps == nil {
		m.user_apps = make(map[int]struct{})
	}
	for i := range ids {
		m.user_apps[ids[i]] = struct{}{}
	}
}

// ClearUserApps clears the "user_apps" edge to the UserApp entity.
func (m *UserMutation) ClearUserApps() {
	m.cleareduser_apps = true
}

// UserAppsCleared reports if the "user_apps" edge to the UserApp entity was cleared.
func (m *UserMutation) UserAppsCleared() bool {
	return m.cleareduser_apps
}

// RemoveUserAppIDs removes the "user_apps" edge to the UserApp entity by IDs.
func (m *UserMutation) RemoveUserAppIDs(ids ...int) {
	if m.removeduser_apps == nil {
		m.removeduser_apps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_apps, ids[i])
		m.removeduser_apps[ids[i]] = struct{}{}
	}
}

// RemovedUserApps returns the removed IDs of the "user_apps" edge to the UserApp entity.
func (m *UserMutation) RemovedUserAppsIDs() (ids []int) {
	for id := range m.removeduser_apps {
		ids = append(ids, id)
	}
	return
}

// UserAppsIDs returns the "user_apps" edge IDs in the mutation.
func (m *UserMutation) UserAppsIDs() (ids []int) {
	for id := range m.user_apps {
		ids = append(ids, id)
	}
	return
}

// ResetUserApps resets all changes to the "user_apps" edge.
func (m *UserMutation) ResetUserApps() {
	m.user_apps = nil
	m.cleareduser_apps = false
	m.removeduser_apps = nil
}

// AddOrganizationMembershipIDs adds the "organization_memberships" edge to the OrganizationMember entity by ids.
func (m *UserMutation) AddOrganizationMembershipIDs(ids ...int) {
	if m.organization_memberships == nil {
		m.organization_memberships = make(map[int]struct{})
	}
	for i := range ids {
		m.organization_memberships[ids[i]] = struct{}{}
	}
}

// ClearOrganizationMemberships clears the "organization_memberships" edge to the OrganizationMember entity.
func (m *UserMutation) ClearOrganizationMemberships() {
	m.clearedorganization_memberships = true
}

// OrganizationMembershipsCleared reports if the "organization_memberships" edge to the OrganizationMember entity was cleared.
func (m *UserMutation) OrganizationMembershipsCleared() bool {
	return m.clearedorganization_memberships
}

// RemoveOrganizationMembershipIDs removes the "organization_memberships" edge to the OrganizationMember entity by IDs.
func (m *UserMutation) RemoveOrganizationMembershipIDs(ids ...int) {
	if m.removedorganization_memberships == nil {
		m.removedorganization_memberships = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organization_memberships, ids[i])
		m.removedorganization_memberships[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationMemberships returns the removed IDs of the "organization_memberships" edge to the OrganizationMember entity.
func (m *UserMutation) RemovedOrganizationMembershipsIDs() (ids []int) {
	for id := range m.removedorganization_memberships {
		ids = append(ids, id)
	}
	return
}

// OrganizationMembershipsIDs returns the "organization_memberships" edge IDs in the mutation.
func (m *UserMutation) OrganizationMembershipsIDs() (ids []int) {
	for id := range m.organization_memberships {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationMemberships resets all changes to the "organization_memberships" edge.
func (m *UserMutation) ResetOrganizationMemberships() {
	m.organization_memberships = nil
	m.clearedorganization_memberships = false
	m.removedorganization_memberships = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *UserMutation) AddSubscriptionIDs(ids ...int) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *UserMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *UserMutation) RemoveSubscriptionIDs(ids ...int) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) RemovedSubscriptionsIDs() (ids []int) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *UserMutation) SubscriptionsIDs() (ids []int) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *UserMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// SetShenbiProfileID sets the "shenbi_profile" edge to the ShenbiProfile entity by id.
func (m *UserMutation) SetShenbiProfileID(id int) {
	m.shenbi_profile = &id
}

// ClearShenbiProfile clears the "shenbi_profile" edge to the ShenbiProfile entity.
func (m *UserMutation) ClearShenbiProfile() {
	m.clearedshenbi_profile = true
}

// ShenbiProfileCleared reports if the "shenbi_profile" edge to the ShenbiProfile entity was cleared.
func (m *UserMutation) ShenbiProfileCleared() bool {
	return m.clearedshenbi_profile
}

// ShenbiProfileID returns the "shenbi_profile" edge ID in the mutation.
func (m *UserMutation) ShenbiProfileID() (id int, exists bool) {
	if m.shenbi_profile != nil {
		return *m.shenbi_profile, true
	}
	return
}

// ShenbiProfileIDs returns the "shenbi_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShenbiProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ShenbiProfileIDs() (ids []int) {
	if id := m.shenbi_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShenbiProfile resets all changes to the "shenbi_profile" edge.
func (m *UserMutation) ResetShenbiProfile() {
	m.shenbi_profile = nil
	m.clearedshenbi_profile = false
}

// AddClassroomsTeachingIDs adds the "classrooms_teaching" edge to the Classroom entity by ids.
func (m *UserMutation) AddClassroomsTeachingIDs(ids ...int) {
	if m.classrooms_teaching == nil {
		m.classrooms_teaching = make(map[int]struct{})
	}
	for i := range ids {
		m.classrooms_teaching[ids[i]] = struct{}{}
	}
}

// ClearClassroomsTeaching clears the "classrooms_teaching" edge to the Classroom entity.
func (m *UserMutation) ClearClassroomsTeaching() {
	m.clearedclassrooms_teaching = true
}

// ClassroomsTeachingCleared reports if the "classrooms_teaching" edge to the Classroom entity was cleared.
func (m *UserMutation) ClassroomsTeachingCleared() bool {
	return m.clearedclassrooms_teaching
}

// RemoveClassroomsTeachingIDs removes the "classrooms_teaching" edge to the Classroom entity by IDs.
func (m *UserMutation) RemoveClassroomsTeachingIDs(ids ...int) {
	if m.removedclassrooms_teaching == nil {
		m.removedclassrooms_teaching = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.classrooms_teaching, ids[i])
		m.removedclassrooms_teaching[ids[i]] = struct{}{}
	}
}

// RemovedClassroomsTeaching returns the removed IDs of the "classrooms_teaching" edge to the Classroom entity.
func (m *UserMutation) RemovedClassroomsTeachingIDs() (ids []int) {
	for id := range m.removedclassrooms_teaching {
		ids = append(ids, id)
	}
	return
}

// ClassroomsTeachingIDs returns the "classrooms_teaching" edge IDs in the mutation.
func (m *UserMutation) ClassroomsTeachingIDs() (ids []int) {
	for id := range m.classrooms_teaching {
		ids = append(ids, id)
	}
	return
}

// ResetClassroomsTeaching resets all changes to the "classrooms_teaching" edge.
func (m *UserMutation) ResetClassroomsTeaching() {
	m.classrooms_teaching = nil
	m.clearedclassrooms_teaching = false
	m.removedclassrooms_teaching = nil
}

// AddClassroomMembershipIDs adds the "classroom_memberships" edge to the ClassroomMembership entity by ids.
func (m *UserMutation) AddClassroomMembershipIDs(ids ...int) {
	if m.classroom_memberships == nil {
		m.classroom_memberships = make(map[int]struct{})
	}
	for i := range ids {
		m.classroom_memberships[ids[i]] = struct{}{}
	}
}

// ClearClassroomMemberships clears the "classroom_memberships" edge to the ClassroomMembership entity.
func (m *UserMutation) ClearClassroomMemberships() {
	m.clearedclassroom_memberships = true
}

// ClassroomMembershipsCleared reports if the "classroom_memberships" edge to the ClassroomMembership entity was cleared.
func (m *UserMutation) ClassroomMembershipsCleared() bool {
	return m.clearedclassroom_memberships
}

// RemoveClassroomMembershipIDs removes the "classroom_memberships" edge to the ClassroomMembership entity by IDs.
func (m *UserMutation) RemoveClassroomMembershipIDs(ids ...int) {
	if m.removedclassroom_memberships == nil {
		m.removedclassroom_memberships = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.classroom_memberships, ids[i])
		m.removedclassroom_memberships[ids[i]] = struct{}{}
	}
}

// RemovedClassroomMemberships returns the removed IDs of the "classroom_memberships" edge to the ClassroomMembership entity.
func (m *UserMutation) RemovedClassroomMembershipsIDs() (ids []int) {
	for id := range m.removedclassroom_memberships {
		ids = append(ids, id)
	}
	return
}

// ClassroomMembershipsIDs returns the "classroom_memberships" edge IDs in the mutation.
func (m *UserMutation) ClassroomMembershipsIDs() (ids []int) {
	for id := range m.classroom_memberships {
		ids = append(ids, id)
	}
	return
}

// ResetClassroomMemberships resets all changes to the "classroom_memberships" edge.
func (m *UserMutation) ResetClassroomMemberships() {
	m.classroom_memberships = nil
	m.clearedclassroom_memberships = false
	m.removedclassroom_memberships = nil
}

// AddAssignmentSubmissionIDs adds the "assignment_submissions" edge to the AssignmentSubmission entity by ids.
func (m *UserMutation) AddAssignmentSubmissionIDs(ids ...int) {
	if m.assignment_submissions == nil {
		m.assignment_submissions = make(map[int]struct{})
	}
	for i := range ids {
		m.assignment_submissions[ids[i]] = struct{}{}
	}
}

// ClearAssignmentSubmissions clears the "assignment_submissions" edge to the AssignmentSubmission entity.
func (m *UserMutation) ClearAssignmentSubmissions() {
	m.clearedassignment_submissions = true
}

// AssignmentSubmissionsCleared reports if the "assignment_submissions" edge to the AssignmentSubmission entity was cleared.
func (m *UserMutation) AssignmentSubmissionsCleared() bool {
	return m.clearedassignment_submissions
}

// RemoveAssignmentSubmissionIDs removes the "assignment_submissions" edge to the AssignmentSubmission entity by IDs.
func (m *UserMutation) RemoveAssignmentSubmissionIDs(ids ...int) {
	if m.removedassignment_submissions == nil {
		m.removedassignment_submissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignment_submissions, ids[i])
		m.removedassignment_submissions[ids[i]] = struct{}{}
	}
}

// RemovedAssignmentSubmissions returns the removed IDs of the "assignment_submissions" edge to the AssignmentSubmission entity.
func (m *UserMutation) RemovedAssignmentSubmissionsIDs() (ids []int) {
	for id := range m.removedassignment_submissions {
		ids = append(ids, id)
	}
	return
}

// AssignmentSubmissionsIDs returns the "assignment_submissions" edge IDs in the mutation.
func (m *UserMutation) AssignmentSubmissionsIDs() (ids []int) {
	for id := range m.assignment_submissions {
		ids = append(ids, id)
	}
	return
}

// ResetAssignmentSubmissions resets all changes to the "assignment_submissions" edge.
func (m *UserMutation) ResetAssignmentSubmissions() {
	m.assignment_submissions = nil
	m.clearedassignment_submissions = false
	m.removedassignment_submissions = nil
}

// AddUserProgresIDs adds the "user_progress" edge to the UserProgress entity by ids.
func (m *UserMutation) AddUserProgresIDs(ids ...int) {
	if m.user_progress == nil {
		m.user_progress = make(map[int]struct{})
	}
	for i := range ids {
		m.user_progress[ids[i]] = struct{}{}
	}
}

// ClearUserProgress clears the "user_progress" edge to the UserProgress entity.
func (m *UserMutation) ClearUserProgress() {
	m.cleareduser_progress = true
}

// UserProgressCleared reports if the "user_progress" edge to the UserProgress entity was cleared.
func (m *UserMutation) UserProgressCleared() bool {
	return m.cleareduser_progress
}

// RemoveUserProgresIDs removes the "user_progress" edge to the UserProgress entity by IDs.
func (m *UserMutation) RemoveUserProgresIDs(ids ...int) {
	if m.removeduser_progress == nil {
		m.removeduser_progress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_progress, ids[i])
		m.removeduser_progress[ids[i]] = struct{}{}
	}
}

// RemovedUserProgress returns the removed IDs of the "user_progress" edge to the UserProgress entity.
func (m *UserMutation) RemovedUserProgressIDs() (ids []int) {
	for id := range m.removeduser_progress {
		ids = append(ids, id)
	}
	return
}

// UserProgressIDs returns the "user_progress" edge IDs in the mutation.
func (m *UserMutation) UserProgressIDs() (ids []int) {
	for id := range m.user_progress {
		ids = append(ids, id)
	}
	return
}

// ResetUserProgress resets all changes to the "user_progress" edge.
func (m *UserMutation) ResetUserProgress() {
	m.user_progress = nil
	m.cleareduser_progress = false
	m.removeduser_progress = nil
}

// AddAchievementIDs adds the "achievements" edge to the Achievement entity by ids.
func (m *UserMutation) AddAchievementIDs(ids ...int) {
	if m.achievements == nil {
		m.achievements = make(map[int]struct{})
	}
	for i := range ids {
		m.achievements[ids[i]] = struct{}{}
	}
}

// ClearAchievements clears the "achievements" edge to the Achievement entity.
func (m *UserMutation) ClearAchievements() {
	m.clearedachievements = true
}

// AchievementsCleared reports if the "achievements" edge to the Achievement entity was cleared.
func (m *UserMutation) AchievementsCleared() bool {
	return m.clearedachievements
}

// RemoveAchievementIDs removes the "achievements" edge to the Achievement entity by IDs.
func (m *UserMutation) RemoveAchievementIDs(ids ...int) {
	if m.removedachievements == nil {
		m.removedachievements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.achievements, ids[i])
		m.removedachievements[ids[i]] = struct{}{}
	}
}

// RemovedAchievements returns the removed IDs of the "achievements" edge to the Achievement entity.
func (m *UserMutation) RemovedAchievementsIDs() (ids []int) {
	for id := range m.removedachievements {
		ids = append(ids, id)
	}
	return
}

// AchievementsIDs returns the "achievements" edge IDs in the mutation.
func (m *UserMutation) AchievementsIDs() (ids []int) {
	for id := range m.achievements {
		ids = append(ids, id)
	}
	return
}

// ResetAchievements resets all changes to the "achievements" edge.
func (m *UserMutation) ResetAchievements() {
	m.achievements = nil
	m.clearedachievements = false
	m.removedachievements = nil
}

// AddBattleRoomsHostedIDs adds the "battle_rooms_hosted" edge to the BattleRoom entity by ids.
func (m *UserMutation) AddBattleRoomsHostedIDs(ids ...int) {
	if m.battle_rooms_hosted == nil {
		m.battle_rooms_hosted = make(map[int]struct{})
	}
	for i := range ids {
		m.battle_rooms_hosted[ids[i]] = struct{}{}
	}
}

// ClearBattleRoomsHosted clears the "battle_rooms_hosted" edge to the BattleRoom entity.
func (m *UserMutation) ClearBattleRoomsHosted() {
	m.clearedbattle_rooms_hosted = true
}

// BattleRoomsHostedCleared reports if the "battle_rooms_hosted" edge to the BattleRoom entity was cleared.
func (m *UserMutation) BattleRoomsHostedCleared() bool {
	return m.clearedbattle_rooms_hosted
}

// RemoveBattleRoomsHostedIDs removes the "battle_rooms_hosted" edge to the BattleRoom entity by IDs.
func (m *UserMutation) RemoveBattleRoomsHostedIDs(ids ...int) {
	if m.removedbattle_rooms_hosted == nil {
		m.removedbattle_rooms_hosted = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.battle_rooms_hosted, ids[i])
		m.removedbattle_rooms_hosted[ids[i]] = struct{}{}
	}
}

// RemovedBattleRoomsHosted returns the removed IDs of the "battle_rooms_hosted" edge to the BattleRoom entity.
func (m *UserMutation) RemovedBattleRoomsHostedIDs() (ids []int) {
	for id := range m.removedbattle_rooms_hosted {
		ids = append(ids, id)
	}
	return
}

// BattleRoomsHostedIDs returns the "battle_rooms_hosted" edge IDs in the mutation.
func (m *UserMutation) BattleRoomsHostedIDs() (ids []int) {
	for id := range m.battle_rooms_hosted {
		ids = append(ids, id)
	}
	return
}

// ResetBattleRoomsHosted resets all changes to the "battle_rooms_hosted" edge.
func (m *UserMutation) ResetBattleRoomsHosted() {
	m.battle_rooms_hosted = nil
	m.clearedbattle_rooms_hosted = false
	m.removedbattle_rooms_hosted = nil
}

// AddBattleSessionIDs adds the "battle_sessions" edge to the BattleSession entity by ids.
func (m *UserMutation) AddBattleSessionIDs(ids ...int) {
	if m.battle_sessions == nil {
		m.battle_sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.battle_sessions[ids[i]] = struct{}{}
	}
}

// ClearBattleSessions clears the "battle_sessions" edge to the BattleSession entity.
func (m *UserMutation) ClearBattleSessions() {
	m.clearedbattle_sessions = true
}

// BattleSessionsCleared reports if the "battle_sessions" edge to the BattleSession entity was cleared.
func (m *UserMutation) BattleSessionsCleared() bool {
	return m.clearedbattle_sessions
}

// RemoveBattleSessionIDs removes the "battle_sessions" edge to the BattleSession entity by IDs.
func (m *UserMutation) RemoveBattleSessionIDs(ids ...int) {
	if m.removedbattle_sessions == nil {
		m.removedbattle_sessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.battle_sessions, ids[i])
		m.removedbattle_sessions[ids[i]] = struct{}{}
	}
}

// RemovedBattleSessions returns the removed IDs of the "battle_sessions" edge to the BattleSession entity.
func (m *UserMutation) RemovedBattleSessionsIDs() (ids []int) {
	for id := range m.removedbattle_sessions {
		ids = append(ids, id)
	}
	return
}

// BattleSessionsIDs returns the "battle_sessions" edge IDs in the mutation.
func (m *UserMutation) BattleSessionsIDs() (ids []int) {
	for id := range m.battle_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetBattleSessions resets all changes to the "battle_sessions" edge.
func (m *UserMutation) ResetBattleSessions() {
	m.battle_sessions = nil
	m.clearedbattle_sessions = false
	m.removedbattle_sessions = nil
}

// AddLiveSessionsTeachingIDs adds the "live_sessions_teaching" edge to the LiveSession entity by ids.
func (m *UserMutation) AddLiveSessionsTeachingIDs(ids ...int) {
	if m.live_sessions_teaching == nil {
		m.live_sessions_teaching = make(map[int]struct{})
	}
	for i := range ids {
		m.live_sessions_teaching[ids[i]] = struct{}{}
	}
}

// ClearLiveSessionsTeaching clears the "live_sessions_teaching" edge to the LiveSession entity.
func (m *UserMutation) ClearLiveSessionsTeaching() {
	m.clearedlive_sessions_teaching = true
}

// LiveSessionsTeachingCleared reports if the "live_sessions_teaching" edge to the LiveSession entity was cleared.
func (m *UserMutation) LiveSessionsTeachingCleared() bool {
	return m.clearedlive_sessions_teaching
}

// RemoveLiveSessionsTeachingIDs removes the "live_sessions_teaching" edge to the LiveSession entity by IDs.
func (m *UserMutation) RemoveLiveSessionsTeachingIDs(ids ...int) {
	if m.removedlive_sessions_teaching == nil {
		m.removedlive_sessions_teaching = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.live_sessions_teaching, ids[i])
		m.removedlive_sessions_teaching[ids[i]] = struct{}{}
	}
}

// RemovedLiveSessionsTeaching returns the removed IDs of the "live_sessions_teaching" edge to the LiveSession entity.
func (m *UserMutation) RemovedLiveSessionsTeachingIDs() (ids []int) {
	for id := range m.removedlive_sessions_teaching {
		ids = append(ids, id)
	}
	return
}

// LiveSessionsTeachingIDs returns the "live_sessions_teaching" edge IDs in the mutation.
func (m *UserMutation) LiveSessionsTeachingIDs() (ids []int) {
	for id := range m.live_sessions_teaching {
		ids = append(ids, id)
	}
	return
}

// ResetLiveSessionsTeaching resets all changes to the "live_sessions_teaching" edge.
func (m *UserMutation) ResetLiveSessionsTeaching() {
	m.live_sessions_teaching = nil
	m.clearedlive_sessions_teaching = false
	m.removedlive_sessions_teaching = nil
}

// AddLiveSessionParticipationIDs adds the "live_session_participations" edge to the LiveSessionStudent entity by ids.
func (m *UserMutation) AddLiveSessionParticipationIDs(ids ...int) {
	if m.live_session_participations == nil {
		m.live_session_participations = make(map[int]struct{})
	}
	for i := range ids {
		m.live_session_participations[ids[i]] = struct{}{}
	}
}

// ClearLiveSessionParticipations clears the "live_session_participations" edge to the LiveSessionStudent entity.
func (m *UserMutation) ClearLiveSessionParticipations() {
	m.clearedlive_session_participations = true
}

// LiveSessionParticipationsCleared reports if the "live_session_participations" edge to the LiveSessionStudent entity was cleared.
func (m *UserMutation) LiveSessionParticipationsCleared() bool {
	return m.clearedlive_session_participations
}

// RemoveLiveSessionParticipationIDs removes the "live_session_participations" edge to the LiveSessionStudent entity by IDs.
func (m *UserMutation) RemoveLiveSessionParticipationIDs(ids ...int) {
	if m.removedlive_session_participations == nil {
		m.removedlive_session_participations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.live_session_participations, ids[i])
		m.removedlive_session_participations[ids[i]] = struct{}{}
	}
}

// RemovedLiveSessionParticipations returns the removed IDs of the "live_session_participations" edge to the LiveSessionStudent entity.
func (m *UserMutation) RemovedLiveSessionParticipationsIDs() (ids []int) {
	for id := range m.removedlive_session_participations {
		ids = append(ids, id)
	}
	return
}

// LiveSessionParticipationsIDs returns the "live_session_participations" edge IDs in the mutation.
func (m *UserMutation) LiveSessionParticipationsIDs() (ids []int) {
	for id := range m.live_session_participations {
		ids = append(ids, id)
	}
	return
}

// ResetLiveSessionParticipations resets all changes to the "live_session_participations" edge.
func (m *UserMutation) ResetLiveSessionParticipations() {
	m.live_session_participations = nil
	m.clearedlive_session_participations = false
	m.removedlive_session_participations = nil
}

// AddClassroomSessionIDs adds the "classroom_sessions" edge to the ClassroomSession entity by ids.
func (m *UserMutation) AddClassroomSessionIDs(ids ...int) {
	if m.classroom_sessions == nil {
		m.classroom_sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.classroom_sessions[ids[i]] = struct{}{}
	}
}

// ClearClassroomSessions clears the "classroom_sessions" edge to the ClassroomSession entity.
func (m *UserMutation) ClearClassroomSessions() {
	m.clearedclassroom_sessions = true
}

// ClassroomSessionsCleared reports if the "classroom_sessions" edge to the ClassroomSession entity was cleared.
func (m *UserMutation) ClassroomSessionsCleared() bool {
	return m.clearedclassroom_sessions
}

// RemoveClassroomSessionIDs removes the "classroom_sessions" edge to the ClassroomSession entity by IDs.
func (m *UserMutation) RemoveClassroomSessionIDs(ids ...int) {
	if m.removedclassroom_sessions == nil {
		m.removedclassroom_sessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.classroom_sessions, ids[i])
		m.removedclassroom_sessions[ids[i]] = struct{}{}
	}
}

// RemovedClassroomSessions returns the removed IDs of the "classroom_sessions" edge to the ClassroomSession entity.
func (m *UserMutation) RemovedClassroomSessionsIDs() (ids []int) {
	for id := range m.removedclassroom_sessions {
		ids = append(ids, id)
	}
	return
}

// ClassroomSessionsIDs returns the "classroom_sessions" edge IDs in the mutation.
func (m *UserMutation) ClassroomSessionsIDs() (ids []int) {
	for id := range m.classroom_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetClassroomSessions resets all changes to the "classroom_sessions" edge.
func (m *UserMutation) ResetClassroomSessions() {
	m.classroom_sessions = nil
	m.clearedclassroom_sessions = false
	m.removedclassroom_sessions = nil
}

// SetShenbiSettingsID sets the "shenbi_settings" edge to the ShenbiSettings entity by id.
func (m *UserMutation) SetShenbiSettingsID(id int) {
	m.shenbi_settings = &id
}

// ClearShenbiSettings clears the "shenbi_settings" edge to the ShenbiSettings entity.
func (m *UserMutation) ClearShenbiSettings() {
	m.clearedshenbi_settings = true
}

// ShenbiSettingsCleared reports if the "shenbi_settings" edge to the ShenbiSettings entity was cleared.
func (m *UserMutation) ShenbiSettingsCleared() bool {
	return m.clearedshenbi_settings
}

// ShenbiSettingsID returns the "shenbi_settings" edge ID in the mutation.
func (m *UserMutation) ShenbiSettingsID() (id int, exists bool) {
	if m.shenbi_settings != nil {
		return *m.shenbi_settings, true
	}
	return
}

// ShenbiSettingsIDs returns the "shenbi_settings" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShenbiSettingsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ShenbiSettingsIDs() (ids []int) {
	if id := m.shenbi_settings; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShenbiSettings resets all changes to the "shenbi_settings" edge.
func (m *UserMutation) ResetShenbiSettings() {
	m.shenbi_settings = nil
	m.clearedshenbi_settings = false
}

// AddSentInvitationIDs adds the "sent_invitations" edge to the OrganizationInvitation entity by ids.
func (m *UserMutation) AddSentInvitationIDs(ids ...int) {
	if m.sent_invitations == nil {
		m.sent_invitations = make(map[int]struct{})
	}
	for i := range ids {
		m.sent_invitations[ids[i]] = struct{}{}
	}
}

// ClearSentInvitations clears the "sent_invitations" edge to the OrganizationInvitation entity.
func (m *UserMutation) ClearSentInvitations() {
	m.clearedsent_invitations = true
}

// SentInvitationsCleared reports if the "sent_invitations" edge to the OrganizationInvitation entity was cleared.
func (m *UserMutation) SentInvitationsCleared() bool {
	return m.clearedsent_invitations
}

// RemoveSentInvitationIDs removes the "sent_invitations" edge to the OrganizationInvitation entity by IDs.
func (m *UserMutation) RemoveSentInvitationIDs(ids ...int) {
	if m.removedsent_invitations == nil {
		m.removedsent_invitations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sent_invitations, ids[i])
		m.removedsent_invitations[ids[i]] = struct{}{}
	}
}

// RemovedSentInvitations returns the removed IDs of the "sent_invitations" edge to the OrganizationInvitation entity.
func (m *UserMutation) RemovedSentInvitationsIDs() (ids []int) {
	for id := range m.removedsent_invitations {
		ids = append(ids, id)
	}
	return
}

// SentInvitationsIDs returns the "sent_invitations" edge IDs in the mutation.
func (m *UserMutation) SentInvitationsIDs() (ids []int) {
	for id := range m.sent_invitations {
		ids = append(ids, id)
	}
	return
}

// ResetSentInvitations resets all changes to the "sent_invitations" edge.
func (m *UserMutation) ResetSentInvitations() {
	m.sent_invitations = nil
	m.clearedsent_invitations = false
	m.removedsent_invitations = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.device_id != nil {
		fields = append(fields, user.FieldDeviceID)
	}
	if m.google_id != nil {
		fields = append(fields, user.FieldGoogleID)
	}
	if m.apple_id != nil {
		fields = append(fields, user.FieldAppleID)
	}
	if m.google_access_token != nil {
		fields = append(fields, user.FieldGoogleAccessToken)
	}
	if m.google_refresh_token != nil {
		fields = append(fields, user.FieldGoogleRefreshToken)
	}
	if m.google_token_expires_at != nil {
		fields = append(fields, user.FieldGoogleTokenExpiresAt)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	if m.is_verified != nil {
		fields = append(fields, user.FieldIsVerified)
	}
	if m.extra_data != nil {
		fields = append(fields, user.FieldExtraData)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldName:
		return m.Name()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldDeviceID:
		return m.DeviceID()
	case user.FieldGoogleID:
		return m.GoogleID()
	case user.FieldAppleID:
		return m.AppleID()
	case user.FieldGoogleAccessToken:
		return m.GoogleAccessToken()
	case user.FieldGoogleRefreshToken:
		return m.GoogleRefreshToken()
	case user.FieldGoogleTokenExpiresAt:
		return m.GoogleTokenExpiresAt()
	case user.FieldIsActive:
		return m.IsActive()
	case user.FieldIsVerified:
		return m.IsVerified()
	case user.FieldExtraData:
		return m.ExtraData()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case user.FieldGoogleID:
		return m.OldGoogleID(ctx)
	case user.FieldAppleID:
		return m.OldAppleID(ctx)
	case user.FieldGoogleAccessToken:
		return m.OldGoogleAccessToken(ctx)
	case user.FieldGoogleRefreshToken:
		return m.OldGoogleRefreshToken(ctx)
	case user.FieldGoogleTokenExpiresAt:
		return m.OldGoogleTokenExpiresAt(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	case user.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case user.FieldExtraData:
		return m.OldExtraData(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case user.FieldGoogleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleID(v)
		return nil
	case user.FieldAppleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppleID(v)
		return nil
	case user.FieldGoogleAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleAccessToken(v)
		return nil
	case user.FieldGoogleRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleRefreshToken(v)
		return nil
	case user.FieldGoogleTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleTokenExpiresAt(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case user.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case user.FieldExtraData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraData(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldDeviceID) {
		fields = append(fields, user.FieldDeviceID)
	}
	if m.FieldCleared(user.FieldGoogleID) {
		fields = append(fields, user.FieldGoogleID)
	}
	if m.FieldCleared(user.FieldAppleID) {
		fields = append(fields, user.FieldAppleID)
	}
	if m.FieldCleared(user.FieldGoogleAccessToken) {
		fields = append(fields, user.FieldGoogleAccessToken)
	}
	if m.FieldCleared(user.FieldGoogleRefreshToken) {
		fields = append(fields, user.FieldGoogleRefreshToken)
	}
	if m.FieldCleared(user.FieldGoogleTokenExpiresAt) {
		fields = append(fields, user.FieldGoogleTokenExpiresAt)
	}
	if m.FieldCleared(user.FieldExtraData) {
		fields = append(fields, user.FieldExtraData)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	case user.FieldGoogleID:
		m.ClearGoogleID()
		return nil
	case user.FieldAppleID:
		m.ClearAppleID()
		return nil
	case user.FieldGoogleAccessToken:
		m.ClearGoogleAccessToken()
		return nil
	case user.FieldGoogleRefreshToken:
		m.ClearGoogleRefreshToken()
		return nil
	case user.FieldGoogleTokenExpiresAt:
		m.ClearGoogleTokenExpiresAt()
		return nil
	case user.FieldExtraData:
		m.ClearExtraData()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case user.FieldGoogleID:
		m.ResetGoogleID()
		return nil
	case user.FieldAppleID:
		m.ResetAppleID()
		return nil
	case user.FieldGoogleAccessToken:
		m.ResetGoogleAccessToken()
		return nil
	case user.FieldGoogleRefreshToken:
		m.ResetGoogleRefreshToken()
		return nil
	case user.FieldGoogleTokenExpiresAt:
		m.ResetGoogleTokenExpiresAt()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	case user.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case user.FieldExtraData:
		m.ResetExtraData()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.user_apps != nil {
		edges = append(edges, user.EdgeUserApps)
	}
	if m.organization_memberships != nil {
		edges = append(edges, user.EdgeOrganizationMemberships)
	}
	if m.subscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.shenbi_profile != nil {
		edges = append(edges, user.EdgeShenbiProfile)
	}
	if m.classrooms_teaching != nil {
		edges = append(edges, user.EdgeClassroomsTeaching)
	}
	if m.classroom_memberships != nil {
		edges = append(edges, user.EdgeClassroomMemberships)
	}
	if m.assignment_submissions != nil {
		edges = append(edges, user.EdgeAssignmentSubmissions)
	}
	if m.user_progress != nil {
		edges = append(edges, user.EdgeUserProgress)
	}
	if m.achievements != nil {
		edges = append(edges, user.EdgeAchievements)
	}
	if m.battle_rooms_hosted != nil {
		edges = append(edges, user.EdgeBattleRoomsHosted)
	}
	if m.battle_sessions != nil {
		edges = append(edges, user.EdgeBattleSessions)
	}
	if m.live_sessions_teaching != nil {
		edges = append(edges, user.EdgeLiveSessionsTeaching)
	}
	if m.live_session_participations != nil {
		edges = append(edges, user.EdgeLiveSessionParticipations)
	}
	if m.classroom_sessions != nil {
		edges = append(edges, user.EdgeClassroomSessions)
	}
	if m.shenbi_settings != nil {
		edges = append(edges, user.EdgeShenbiSettings)
	}
	if m.sent_invitations != nil {
		edges = append(edges, user.EdgeSentInvitations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserApps:
		ids := make([]ent.Value, 0, len(m.user_apps))
		for id := range m.user_apps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizationMemberships:
		ids := make([]ent.Value, 0, len(m.organization_memberships))
		for id := range m.organization_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeShenbiProfile:
		if id := m.shenbi_profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeClassroomsTeaching:
		ids := make([]ent.Value, 0, len(m.classrooms_teaching))
		for id := range m.classrooms_teaching {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClassroomMemberships:
		ids := make([]ent.Value, 0, len(m.classroom_memberships))
		for id := range m.classroom_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignmentSubmissions:
		ids := make([]ent.Value, 0, len(m.assignment_submissions))
		for id := range m.assignment_submissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserProgress:
		ids := make([]ent.Value, 0, len(m.user_progress))
		for id := range m.user_progress {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAchievements:
		ids := make([]ent.Value, 0, len(m.achievements))
		for id := range m.achievements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBattleRoomsHosted:
		ids := make([]ent.Value, 0, len(m.battle_rooms_hosted))
		for id := range m.battle_rooms_hosted {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBattleSessions:
		ids := make([]ent.Value, 0, len(m.battle_sessions))
		for id := range m.battle_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLiveSessionsTeaching:
		ids := make([]ent.Value, 0, len(m.live_sessions_teaching))
		for id := range m.live_sessions_teaching {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLiveSessionParticipations:
		ids := make([]ent.Value, 0, len(m.live_session_participations))
		for id := range m.live_session_participations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClassroomSessions:
		ids := make([]ent.Value, 0, len(m.classroom_sessions))
		for id := range m.classroom_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeShenbiSettings:
		if id := m.shenbi_settings; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeSentInvitations:
		ids := make([]ent.Value, 0, len(m.sent_invitations))
		for id := range m.sent_invitations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removeduser_apps != nil {
		edges = append(edges, user.EdgeUserApps)
	}
	if m.removedorganization_memberships != nil {
		edges = append(edges, user.EdgeOrganizationMemberships)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.removedclassrooms_teaching != nil {
		edges = append(edges, user.EdgeClassroomsTeaching)
	}
	if m.removedclassroom_memberships != nil {
		edges = append(edges, user.EdgeClassroomMemberships)
	}
	if m.removedassignment_submissions != nil {
		edges = append(edges, user.EdgeAssignmentSubmissions)
	}
	if m.removeduser_progress != nil {
		edges = append(edges, user.EdgeUserProgress)
	}
	if m.removedachievements != nil {
		edges = append(edges, user.EdgeAchievements)
	}
	if m.removedbattle_rooms_hosted != nil {
		edges = append(edges, user.EdgeBattleRoomsHosted)
	}
	if m.removedbattle_sessions != nil {
		edges = append(edges, user.EdgeBattleSessions)
	}
	if m.removedlive_sessions_teaching != nil {
		edges = append(edges, user.EdgeLiveSessionsTeaching)
	}
	if m.removedlive_session_participations != nil {
		edges = append(edges, user.EdgeLiveSessionParticipations)
	}
	if m.removedclassroom_sessions != nil {
		edges = append(edges, user.EdgeClassroomSessions)
	}
	if m.removedsent_invitations != nil {
		edges = append(edges, user.EdgeSentInvitations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserApps:
		ids := make([]ent.Value, 0, len(m.removeduser_apps))
		for id := range m.removeduser_apps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizationMemberships:
		ids := make([]ent.Value, 0, len(m.removedorganization_memberships))
		for id := range m.removedorganization_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClassroomsTeaching:
		ids := make([]ent.Value, 0, len(m.removedclassrooms_teaching))
		for id := range m.removedclassrooms_teaching {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClassroomMemberships:
		ids := make([]ent.Value, 0, len(m.removedclassroom_memberships))
		for id := range m.removedclassroom_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignmentSubmissions:
		ids := make([]ent.Value, 0, len(m.removedassignment_submissions))
		for id := range m.removedassignment_submissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserProgress:
		ids := make([]ent.Value, 0, len(m.removeduser_progress))
		for id := range m.removeduser_progress {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAchievements:
		ids := make([]ent.Value, 0, len(m.removedachievements))
		for id := range m.removedachievements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBattleRoomsHosted:
		ids := make([]ent.Value, 0, len(m.removedbattle_rooms_hosted))
		for id := range m.removedbattle_rooms_hosted {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBattleSessions:
		ids := make([]ent.Value, 0, len(m.removedbattle_sessions))
		for id := range m.removedbattle_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLiveSessionsTeaching:
		ids := make([]ent.Value, 0, len(m.removedlive_sessions_teaching))
		for id := range m.removedlive_sessions_teaching {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLiveSessionParticipations:
		ids := make([]ent.Value, 0, len(m.removedlive_session_participations))
		for id := range m.removedlive_session_participations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClassroomSessions:
		ids := make([]ent.Value, 0, len(m.removedclassroom_sessions))
		for id := range m.removedclassroom_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentInvitations:
		ids := make([]ent.Value, 0, len(m.removedsent_invitations))
		for id := range m.removedsent_invitations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.cleareduser_apps {
		edges = append(edges, user.EdgeUserApps)
	}
	if m.clearedorganization_memberships {
		edges = append(edges, user.EdgeOrganizationMemberships)
	}
	if m.clearedsubscriptions {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.clearedshenbi_profile {
		edges = append(edges, user.EdgeShenbiProfile)
	}
	if m.clearedclassrooms_teaching {
		edges = append(edges, user.EdgeClassroomsTeaching)
	}
	if m.clearedclassroom_memberships {
		edges = append(edges, user.EdgeClassroomMemberships)
	}
	if m.clearedassignment_submissions {
		edges = append(edges, user.EdgeAssignmentSubmissions)
	}
	if m.cleareduser_progress {
		edges = append(edges, user.EdgeUserProgress)
	}
	if m.clearedachievements {
		edges = append(edges, user.EdgeAchievements)
	}
	if m.clearedbattle_rooms_hosted {
		edges = append(edges, user.EdgeBattleRoomsHosted)
	}
	if m.clearedbattle_sessions {
		edges = append(edges, user.EdgeBattleSessions)
	}
	if m.clearedlive_sessions_teaching {
		edges = append(edges, user.EdgeLiveSessionsTeaching)
	}
	if m.clearedlive_session_participations {
		edges = append(edges, user.EdgeLiveSessionParticipations)
	}
	if m.clearedclassroom_sessions {
		edges = append(edges, user.EdgeClassroomSessions)
	}
	if m.clearedshenbi_settings {
		edges = append(edges, user.EdgeShenbiSettings)
	}
	if m.clearedsent_invitations {
		edges = append(edges, user.EdgeSentInvitations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserApps:
		return m.cleareduser_apps
	case user.EdgeOrganizationMemberships:
		return m.clearedorganization_memberships
	case user.EdgeSubscriptions:
		return m.clearedsubscriptions
	case user.EdgeShenbiProfile:
		return m.clearedshenbi_profile
	case user.EdgeClassroomsTeaching:
		return m.clearedclassrooms_teaching
	case user.EdgeClassroomMemberships:
		return m.clearedclassroom_memberships
	case user.EdgeAssignmentSubmissions:
		return m.clearedassignment_submissions
	case user.EdgeUserProgress:
		return m.cleareduser_progress
	case user.EdgeAchievements:
		return m.clearedachievements
	case user.EdgeBattleRoomsHosted:
		return m.clearedbattle_rooms_hosted
	case user.EdgeBattleSessions:
		return m.clearedbattle_sessions
	case user.EdgeLiveSessionsTeaching:
		return m.clearedlive_sessions_teaching
	case user.EdgeLiveSessionParticipations:
		return m.clearedlive_session_participations
	case user.EdgeClassroomSessions:
		return m.clearedclassroom_sessions
	case user.EdgeShenbiSettings:
		return m.clearedshenbi_settings
	case user.EdgeSentInvitations:
		return m.clearedsent_invitations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeShenbiProfile:
		m.ClearShenbiProfile()
		return nil
	case user.EdgeShenbiSettings:
		m.ClearShenbiSettings()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserApps:
		m.ResetUserApps()
		return nil
	case user.EdgeOrganizationMemberships:
		m.ResetOrganizationMemberships()
		return nil
	case user.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case user.EdgeShenbiProfile:
		m.ResetShenbiProfile()
		return nil
	case user.EdgeClassroomsTeaching:
		m.ResetClassroomsTeaching()
		return nil
	case user.EdgeClassroomMemberships:
		m.ResetClassroomMemberships()
		return nil
	case user.EdgeAssignmentSubmissions:
		m.ResetAssignmentSubmissions()
		return nil
	case user.EdgeUserProgress:
		m.ResetUserProgress()
		return nil
	case user.EdgeAchievements:
		m.ResetAchievements()
		return nil
	case user.EdgeBattleRoomsHosted:
		m.ResetBattleRoomsHosted()
		return nil
	case user.EdgeBattleSessions:
		m.ResetBattleSessions()
		return nil
	case user.EdgeLiveSessionsTeaching:
		m.ResetLiveSessionsTeaching()
		return nil
	case user.EdgeLiveSessionParticipations:
		m.ResetLiveSessionParticipations()
		return nil
	case user.EdgeClassroomSessions:
		m.ResetClassroomSessions()
		return nil
	case user.EdgeShenbiSettings:
		m.ResetShenbiSettings()
		return nil
	case user.EdgeSentInvitations:
		m.ResetSentInvitations()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAppMutation represents an operation that mutates the UserApp nodes in the graph.
type UserAppMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	stripe_customer_id *string
	enabled_at         *time.Time
	clearedFields      map[string]struct{}
	user               *int
	cleareduser        bool
	app                *int
	clearedapp         bool
	done               bool
	oldValue           func(context.Context) (*UserApp, error)
	predicates         []predicate.UserApp
}

var _ ent.Mutation = (*UserAppMutation)(nil)

// userappOption allows management of the mutation configuration using functional options.
type userappOption func(*UserAppMutation)

// newUserAppMutation creates new mutation for the UserApp entity.
func newUserAppMutation(c config, op Op, opts ...userappOption) *UserAppMutation {
	m := &UserAppMutation{
		config:        c,
		op:            op,
		typ:           TypeUserApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAppID sets the ID field of the mutation.
func withUserAppID(id int) userappOption {
	return func(m *UserAppMutation) {
		var (
			err   error
			once  sync.Once
			value *UserApp
		)
		m.oldValue = func(ctx context.Context) (*UserApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserApp sets the old UserApp of the mutation.
func withUserApp(node *UserApp) userappOption {
	return func(m *UserAppMutation) {
		m.oldValue = func(context.Context) (*UserApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *UserAppMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *UserAppMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the UserApp entity.
// If the UserApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAppMutation) OldStripeCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (m *UserAppMutation) ClearStripeCustomerID() {
	m.stripe_customer_id = nil
	m.clearedFields[userapp.FieldStripeCustomerID] = struct{}{}
}

// StripeCustomerIDCleared returns if the "stripe_customer_id" field was cleared in this mutation.
func (m *UserAppMutation) StripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[userapp.FieldStripeCustomerID]
	return ok
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *UserAppMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
	delete(m.clearedFields, userapp.FieldStripeCustomerID)
}

// SetEnabledAt sets the "enabled_at" field.
func (m *UserAppMutation) SetEnabledAt(t time.Time) {
	m.enabled_at = &t
}

// EnabledAt returns the value of the "enabled_at" field in the mutation.
func (m *UserAppMutation) EnabledAt() (r time.Time, exists bool) {
	v := m.enabled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabledAt returns the old "enabled_at" field's value of the UserApp entity.
// If the UserApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAppMutation) OldEnabledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabledAt: %w", err)
	}
	return oldValue.EnabledAt, nil
}

// ResetEnabledAt resets all changes to the "enabled_at" field.
func (m *UserAppMutation) ResetEnabledAt() {
	m.enabled_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserAppMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserAppMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserAppMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserAppMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserAppMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserAppMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *UserAppMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *UserAppMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *UserAppMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *UserAppMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *UserAppMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *UserAppMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the UserAppMutation builder.
func (m *UserAppMutation) Where(ps ...predicate.UserApp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserApp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserApp).
func (m *UserAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAppMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.stripe_customer_id != nil {
		fields = append(fields, userapp.FieldStripeCustomerID)
	}
	if m.enabled_at != nil {
		fields = append(fields, userapp.FieldEnabledAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userapp.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case userapp.FieldEnabledAt:
		return m.EnabledAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userapp.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case userapp.FieldEnabledAt:
		return m.OldEnabledAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userapp.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case userapp.FieldEnabledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabledAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userapp.FieldStripeCustomerID) {
		fields = append(fields, userapp.FieldStripeCustomerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAppMutation) ClearField(name string) error {
	switch name {
	case userapp.FieldStripeCustomerID:
		m.ClearStripeCustomerID()
		return nil
	}
	return fmt.Errorf("unknown UserApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAppMutation) ResetField(name string) error {
	switch name {
	case userapp.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case userapp.FieldEnabledAt:
		m.ResetEnabledAt()
		return nil
	}
	return fmt.Errorf("unknown UserApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userapp.EdgeUser)
	}
	if m.app != nil {
		edges = append(edges, userapp.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userapp.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userapp.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userapp.EdgeUser)
	}
	if m.clearedapp {
		edges = append(edges, userapp.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAppMutation) EdgeCleared(name string) bool {
	switch name {
	case userapp.EdgeUser:
		return m.cleareduser
	case userapp.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAppMutation) ClearEdge(name string) error {
	switch name {
	case userapp.EdgeUser:
		m.ClearUser()
		return nil
	case userapp.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown UserApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAppMutation) ResetEdge(name string) error {
	switch name {
	case userapp.EdgeUser:
		m.ResetUser()
		return nil
	case userapp.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown UserApp edge %s", name)
}

// UserProgressMutation represents an operation that mutates the UserProgress nodes in the graph.
type UserProgressMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	adventure_slug     *string
	level_slug         *string
	stars              *int
	addstars           *int
	completed          *bool
	attempts           *int
	addattempts        *int
	best_code          *string
	first_completed_at *time.Time
	last_attempt_at    *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	app                *int
	clearedapp         bool
	user               *int
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*UserProgress, error)
	predicates         []predicate.UserProgress
}

var _ ent.Mutation = (*UserProgressMutation)(nil)

// userprogressOption allows management of the mutation configuration using functional options.
type userprogressOption func(*UserProgressMutation)

// newUserProgressMutation creates new mutation for the UserProgress entity.
func newUserProgressMutation(c config, op Op, opts ...userprogressOption) *UserProgressMutation {
	m := &UserProgressMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProgress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProgressID sets the ID field of the mutation.
func withUserProgressID(id int) userprogressOption {
	return func(m *UserProgressMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProgress
		)
		m.oldValue = func(ctx context.Context) (*UserProgress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProgress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProgress sets the old UserProgress of the mutation.
func withUserProgress(node *UserProgress) userprogressOption {
	return func(m *UserProgressMutation) {
		m.oldValue = func(context.Context) (*UserProgress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProgressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProgressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProgressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProgressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProgress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAdventureSlug sets the "adventure_slug" field.
func (m *UserProgressMutation) SetAdventureSlug(s string) {
	m.adventure_slug = &s
}

// AdventureSlug returns the value of the "adventure_slug" field in the mutation.
func (m *UserProgressMutation) AdventureSlug() (r string, exists bool) {
	v := m.adventure_slug
	if v == nil {
		return
	}
	return *v, true
}

// OldAdventureSlug returns the old "adventure_slug" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldAdventureSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdventureSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdventureSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdventureSlug: %w", err)
	}
	return oldValue.AdventureSlug, nil
}

// ResetAdventureSlug resets all changes to the "adventure_slug" field.
func (m *UserProgressMutation) ResetAdventureSlug() {
	m.adventure_slug = nil
}

// SetLevelSlug sets the "level_slug" field.
func (m *UserProgressMutation) SetLevelSlug(s string) {
	m.level_slug = &s
}

// LevelSlug returns the value of the "level_slug" field in the mutation.
func (m *UserProgressMutation) LevelSlug() (r string, exists bool) {
	v := m.level_slug
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelSlug returns the old "level_slug" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldLevelSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelSlug: %w", err)
	}
	return oldValue.LevelSlug, nil
}

// ResetLevelSlug resets all changes to the "level_slug" field.
func (m *UserProgressMutation) ResetLevelSlug() {
	m.level_slug = nil
}

// SetStars sets the "stars" field.
func (m *UserProgressMutation) SetStars(i int) {
	m.stars = &i
	m.addstars = nil
}

// Stars returns the value of the "stars" field in the mutation.
func (m *UserProgressMutation) Stars() (r int, exists bool) {
	v := m.stars
	if v == nil {
		return
	}
	return *v, true
}

// OldStars returns the old "stars" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldStars(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStars: %w", err)
	}
	return oldValue.Stars, nil
}

// AddStars adds i to the "stars" field.
func (m *UserProgressMutation) AddStars(i int) {
	if m.addstars != nil {
		*m.addstars += i
	} else {
		m.addstars = &i
	}
}

// AddedStars returns the value that was added to the "stars" field in this mutation.
func (m *UserProgressMutation) AddedStars() (r int, exists bool) {
	v := m.addstars
	if v == nil {
		return
	}
	return *v, true
}

// ResetStars resets all changes to the "stars" field.
func (m *UserProgressMutation) ResetStars() {
	m.stars = nil
	m.addstars = nil
}

// SetCompleted sets the "completed" field.
func (m *UserProgressMutation) SetCompleted(b bool) {
	m.completed = &b
}

// Completed returns the value of the "completed" field in the mutation.
func (m *UserProgressMutation) Completed() (r bool, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ResetCompleted resets all changes to the "completed" field.
func (m *UserProgressMutation) ResetCompleted() {
	m.completed = nil
}

// SetAttempts sets the "attempts" field.
func (m *UserProgressMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *UserProgressMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *UserProgressMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *UserProgressMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *UserProgressMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
}

// SetBestCode sets the "best_code" field.
func (m *UserProgressMutation) SetBestCode(s string) {
	m.best_code = &s
}

// BestCode returns the value of the "best_code" field in the mutation.
func (m *UserProgressMutation) BestCode() (r string, exists bool) {
	v := m.best_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBestCode returns the old "best_code" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldBestCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBestCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBestCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBestCode: %w", err)
	}
	return oldValue.BestCode, nil
}

// ClearBestCode clears the value of the "best_code" field.
func (m *UserProgressMutation) ClearBestCode() {
	m.best_code = nil
	m.clearedFields[userprogress.FieldBestCode] = struct{}{}
}

// BestCodeCleared returns if the "best_code" field was cleared in this mutation.
func (m *UserProgressMutation) BestCodeCleared() bool {
	_, ok := m.clearedFields[userprogress.FieldBestCode]
	return ok
}

// ResetBestCode resets all changes to the "best_code" field.
func (m *UserProgressMutation) ResetBestCode() {
	m.best_code = nil
	delete(m.clearedFields, userprogress.FieldBestCode)
}

// SetFirstCompletedAt sets the "first_completed_at" field.
func (m *UserProgressMutation) SetFirstCompletedAt(t time.Time) {
	m.first_completed_at = &t
}

// FirstCompletedAt returns the value of the "first_completed_at" field in the mutation.
func (m *UserProgressMutation) FirstCompletedAt() (r time.Time, exists bool) {
	v := m.first_completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstCompletedAt returns the old "first_completed_at" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldFirstCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstCompletedAt: %w", err)
	}
	return oldValue.FirstCompletedAt, nil
}

// ClearFirstCompletedAt clears the value of the "first_completed_at" field.
func (m *UserProgressMutation) ClearFirstCompletedAt() {
	m.first_completed_at = nil
	m.clearedFields[userprogress.FieldFirstCompletedAt] = struct{}{}
}

// FirstCompletedAtCleared returns if the "first_completed_at" field was cleared in this mutation.
func (m *UserProgressMutation) FirstCompletedAtCleared() bool {
	_, ok := m.clearedFields[userprogress.FieldFirstCompletedAt]
	return ok
}

// ResetFirstCompletedAt resets all changes to the "first_completed_at" field.
func (m *UserProgressMutation) ResetFirstCompletedAt() {
	m.first_completed_at = nil
	delete(m.clearedFields, userprogress.FieldFirstCompletedAt)
}

// SetLastAttemptAt sets the "last_attempt_at" field.
func (m *UserProgressMutation) SetLastAttemptAt(t time.Time) {
	m.last_attempt_at = &t
}

// LastAttemptAt returns the value of the "last_attempt_at" field in the mutation.
func (m *UserProgressMutation) LastAttemptAt() (r time.Time, exists bool) {
	v := m.last_attempt_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAttemptAt returns the old "last_attempt_at" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldLastAttemptAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastAttemptAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastAttemptAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAttemptAt: %w", err)
	}
	return oldValue.LastAttemptAt, nil
}

// ClearLastAttemptAt clears the value of the "last_attempt_at" field.
func (m *UserProgressMutation) ClearLastAttemptAt() {
	m.last_attempt_at = nil
	m.clearedFields[userprogress.FieldLastAttemptAt] = struct{}{}
}

// LastAttemptAtCleared returns if the "last_attempt_at" field was cleared in this mutation.
func (m *UserProgressMutation) LastAttemptAtCleared() bool {
	_, ok := m.clearedFields[userprogress.FieldLastAttemptAt]
	return ok
}

// ResetLastAttemptAt resets all changes to the "last_attempt_at" field.
func (m *UserProgressMutation) ResetLastAttemptAt() {
	m.last_attempt_at = nil
	delete(m.clearedFields, userprogress.FieldLastAttemptAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserProgressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserProgressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserProgressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserProgressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserProgressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserProgressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *UserProgressMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *UserProgressMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *UserProgressMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *UserProgressMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *UserProgressMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *UserProgressMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserProgressMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserProgressMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserProgressMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserProgressMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserProgressMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserProgressMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserProgressMutation builder.
func (m *UserProgressMutation) Where(ps ...predicate.UserProgress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProgressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProgressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProgress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProgressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProgressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProgress).
func (m *UserProgressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProgressMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.adventure_slug != nil {
		fields = append(fields, userprogress.FieldAdventureSlug)
	}
	if m.level_slug != nil {
		fields = append(fields, userprogress.FieldLevelSlug)
	}
	if m.stars != nil {
		fields = append(fields, userprogress.FieldStars)
	}
	if m.completed != nil {
		fields = append(fields, userprogress.FieldCompleted)
	}
	if m.attempts != nil {
		fields = append(fields, userprogress.FieldAttempts)
	}
	if m.best_code != nil {
		fields = append(fields, userprogress.FieldBestCode)
	}
	if m.first_completed_at != nil {
		fields = append(fields, userprogress.FieldFirstCompletedAt)
	}
	if m.last_attempt_at != nil {
		fields = append(fields, userprogress.FieldLastAttemptAt)
	}
	if m.created_at != nil {
		fields = append(fields, userprogress.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userprogress.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProgressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userprogress.FieldAdventureSlug:
		return m.AdventureSlug()
	case userprogress.FieldLevelSlug:
		return m.LevelSlug()
	case userprogress.FieldStars:
		return m.Stars()
	case userprogress.FieldCompleted:
		return m.Completed()
	case userprogress.FieldAttempts:
		return m.Attempts()
	case userprogress.FieldBestCode:
		return m.BestCode()
	case userprogress.FieldFirstCompletedAt:
		return m.FirstCompletedAt()
	case userprogress.FieldLastAttemptAt:
		return m.LastAttemptAt()
	case userprogress.FieldCreatedAt:
		return m.CreatedAt()
	case userprogress.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProgressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userprogress.FieldAdventureSlug:
		return m.OldAdventureSlug(ctx)
	case userprogress.FieldLevelSlug:
		return m.OldLevelSlug(ctx)
	case userprogress.FieldStars:
		return m.OldStars(ctx)
	case userprogress.FieldCompleted:
		return m.OldCompleted(ctx)
	case userprogress.FieldAttempts:
		return m.OldAttempts(ctx)
	case userprogress.FieldBestCode:
		return m.OldBestCode(ctx)
	case userprogress.FieldFirstCompletedAt:
		return m.OldFirstCompletedAt(ctx)
	case userprogress.FieldLastAttemptAt:
		return m.OldLastAttemptAt(ctx)
	case userprogress.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userprogress.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserProgress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProgressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userprogress.FieldAdventureSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdventureSlug(v)
		return nil
	case userprogress.FieldLevelSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelSlug(v)
		return nil
	case userprogress.FieldStars:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStars(v)
		return nil
	case userprogress.FieldCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	case userprogress.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case userprogress.FieldBestCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBestCode(v)
		return nil
	case userprogress.FieldFirstCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstCompletedAt(v)
		return nil
	case userprogress.FieldLastAttemptAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAttemptAt(v)
		return nil
	case userprogress.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userprogress.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserProgress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProgressMutation) AddedFields() []string {
	var fields []string
	if m.addstars != nil {
		fields = append(fields, userprogress.FieldStars)
	}
	if m.addattempts != nil {
		fields = append(fields, userprogress.FieldAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProgressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userprogress.FieldStars:
		return m.AddedStars()
	case userprogress.FieldAttempts:
		return m.AddedAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProgressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userprogress.FieldStars:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStars(v)
		return nil
	case userprogress.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown UserProgress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProgressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userprogress.FieldBestCode) {
		fields = append(fields, userprogress.FieldBestCode)
	}
	if m.FieldCleared(userprogress.FieldFirstCompletedAt) {
		fields = append(fields, userprogress.FieldFirstCompletedAt)
	}
	if m.FieldCleared(userprogress.FieldLastAttemptAt) {
		fields = append(fields, userprogress.FieldLastAttemptAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProgressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProgressMutation) ClearField(name string) error {
	switch name {
	case userprogress.FieldBestCode:
		m.ClearBestCode()
		return nil
	case userprogress.FieldFirstCompletedAt:
		m.ClearFirstCompletedAt()
		return nil
	case userprogress.FieldLastAttemptAt:
		m.ClearLastAttemptAt()
		return nil
	}
	return fmt.Errorf("unknown UserProgress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProgressMutation) ResetField(name string) error {
	switch name {
	case userprogress.FieldAdventureSlug:
		m.ResetAdventureSlug()
		return nil
	case userprogress.FieldLevelSlug:
		m.ResetLevelSlug()
		return nil
	case userprogress.FieldStars:
		m.ResetStars()
		return nil
	case userprogress.FieldCompleted:
		m.ResetCompleted()
		return nil
	case userprogress.FieldAttempts:
		m.ResetAttempts()
		return nil
	case userprogress.FieldBestCode:
		m.ResetBestCode()
		return nil
	case userprogress.FieldFirstCompletedAt:
		m.ResetFirstCompletedAt()
		return nil
	case userprogress.FieldLastAttemptAt:
		m.ResetLastAttemptAt()
		return nil
	case userprogress.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userprogress.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserProgress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProgressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, userprogress.EdgeApp)
	}
	if m.user != nil {
		edges = append(edges, userprogress.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProgressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userprogress.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case userprogress.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProgressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProgressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProgressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, userprogress.EdgeApp)
	}
	if m.cleareduser {
		edges = append(edges, userprogress.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProgressMutation) EdgeCleared(name string) bool {
	switch name {
	case userprogress.EdgeApp:
		return m.clearedapp
	case userprogress.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProgressMutation) ClearEdge(name string) error {
	switch name {
	case userprogress.EdgeApp:
		m.ClearApp()
		return nil
	case userprogress.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserProgress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProgressMutation) ResetEdge(name string) error {
	switch name {
	case userprogress.EdgeApp:
		m.ResetApp()
		return nil
	case userprogress.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserProgress edge %s", name)
}
